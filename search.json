[{"title":"Alluxio","url":"/2025/10/13/Alluxio/","content":""},{"title":"cephä¸­çš„å­˜å‚¨ç©ºé—´åˆ†é…å™¨","url":"/2025/09/30/ceph%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E5%99%A8/","content":"Ceph BlueStore åˆ†é…å™¨æ·±åº¦è§£æç›®å½•\n1. å¼•è¨€\n2. ä¸ºä»€ä¹ˆéœ€è¦åˆ†é…å™¨\n3. åˆ†é…å™¨æ¶æ„è®¾è®¡\n4. äº”ç§åˆ†é…å™¨å®ç°è¯¦è§£\n5. æ€§èƒ½å¯¹æ¯”ä¸é€‰æ‹©\n6. æºç è§£æ\n7. æœ€ä½³å®è·µ\n8. é—®é¢˜æ’æŸ¥\n9. æ€»ç»“\n\n\n\n\n1. å¼•è¨€åœ¨ Ceph å­˜å‚¨ç³»ç»Ÿä¸­ï¼ŒBlueStore ä½œä¸ºæ–°ä¸€ä»£å¯¹è±¡å­˜å‚¨å¼•æ“ï¼Œç›´æ¥ç®¡ç†è£¸å—è®¾å¤‡ï¼Œæ‘’å¼ƒäº†ä¼ ç»Ÿæ–‡ä»¶ç³»ç»Ÿçš„å¼€é”€ã€‚åœ¨è¿™ç§æ¶æ„ä¸‹ï¼Œåˆ†é…å™¨ï¼ˆAllocatorï¼‰ æˆä¸ºäº†è‡³å…³é‡è¦çš„ç»„ä»¶â€”â€”å®ƒè´Ÿè´£ç®¡ç†ç£ç›˜ç©ºé—²ç©ºé—´çš„åˆ†é…å’Œå›æ”¶ï¼Œç›´æ¥å½±å“ç€å­˜å‚¨æ€§èƒ½ã€ç¢ç‰‡åŒ–ç¨‹åº¦å’Œå†…å­˜å ç”¨ã€‚\næœ¬æ–‡å°†æ·±å…¥å‰–æ Ceph åˆ†é…å™¨çš„è®¾è®¡åŸç†ã€å®ç°ç»†èŠ‚å’Œä½¿ç”¨åœºæ™¯ï¼Œå¸®åŠ©ä½ å…¨é¢ç†è§£è¿™ä¸€æ ¸å¿ƒç»„ä»¶ã€‚\næœ¬æ–‡é€‚åˆè°ï¼Ÿ\nCeph è¿ç»´å·¥ç¨‹å¸ˆï¼šäº†è§£å¦‚ä½•é€‰æ‹©å’Œè°ƒä¼˜åˆ†é…å™¨\nå­˜å‚¨å¼€å‘è€…ï¼šç†è§£åˆ†é…å™¨çš„è®¾è®¡æ€æƒ³å’Œå®ç°ç»†èŠ‚\nç³»ç»Ÿæ¶æ„å¸ˆï¼šè¯„ä¼°ä¸åŒåˆ†é…å™¨å¯¹ç³»ç»Ÿçš„å½±å“\n\n\n2. ä¸ºä»€ä¹ˆéœ€è¦åˆ†é…å™¨2.1 BlueStore çš„å­˜å‚¨æ¶æ„åœ¨ BlueStore ä¸­ï¼Œæ•°æ®æµè½¬è·¯å¾„å¦‚ä¸‹ï¼š\nç”¨æˆ·å†™å…¥å¯¹è±¡    â†“BlueStore æ¥æ”¶è¯·æ±‚    â†“Allocator åˆ†é…ç£ç›˜ç©ºé—´ â† æœ¬æ–‡é‡ç‚¹    â†“å†™å…¥è£¸å—è®¾å¤‡    â†“å…ƒæ•°æ®å­˜å‚¨åˆ° RocksDB\n\nBlueStore ç›´æ¥ç®¡ç†è£¸è®¾å¤‡ï¼Œéœ€è¦è‡ªå·±å®ç°ï¼š\n\nç©ºé—²ç©ºé—´ç®¡ç†ï¼šå“ªäº›ç£ç›˜å—æ˜¯ç©ºé—²çš„ï¼Ÿ\nç©ºé—´åˆ†é…ï¼šä¸ºæ–°æ•°æ®æ‰¾åˆ°åˆé€‚çš„å­˜å‚¨ä½ç½®\nç©ºé—´å›æ”¶ï¼šåˆ é™¤æ•°æ®åå›æ”¶ç£ç›˜å—\nç¢ç‰‡ç®¡ç†ï¼šé¿å…ç£ç›˜ç©ºé—´ç¢ç‰‡åŒ–\n\nè¿™å°±æ˜¯åˆ†é…å™¨çš„èŒè´£æ‰€åœ¨ã€‚\n2.2 åˆ†é…å™¨çš„æ ¸å¿ƒé—®é¢˜åˆ†é…å™¨éœ€è¦è§£å†³ä»¥ä¸‹å…³é”®é—®é¢˜ï¼š\né—®é¢˜ 1ï¼šå¦‚ä½•é«˜æ•ˆæŸ¥æ‰¾ç©ºé—²ç©ºé—´ï¼Ÿ\nå¯¹äº 10TB ç£ç›˜ï¼Œæœ‰æ•°ç™¾ä¸‡ä¸ª 4KB å—\néœ€è¦å¿«é€Ÿæ‰¾åˆ°æ»¡è¶³å¤§å°è¦æ±‚çš„è¿ç»­ç©ºé—´\n\né—®é¢˜ 2ï¼šå¦‚ä½•æ§åˆ¶å†…å­˜å ç”¨ï¼Ÿ\nè®°å½•æ‰€æœ‰ç©ºé—²åŒºé—´éœ€è¦å†…å­˜\nç¢ç‰‡è¶Šå¤šï¼Œå†…å­˜å ç”¨è¶Šå¤§\néœ€è¦åœ¨æ€§èƒ½å’Œå†…å­˜é—´å¹³è¡¡\n\né—®é¢˜ 3ï¼šå¦‚ä½•å‡å°‘ç¢ç‰‡ï¼Ÿ\néšæœºåˆ†é…å¯¼è‡´ç¢ç‰‡åŒ–\néœ€è¦æ™ºèƒ½çš„åˆ†é…ç­–ç•¥\n\né—®é¢˜ 4ï¼šå¦‚ä½•ä¿è¯å¹¶å‘æ€§èƒ½ï¼Ÿ\nå¤šçº¿ç¨‹å¹¶å‘è¯»å†™\né”ç«äº‰å½±å“æ€§èƒ½\n\n\n3. åˆ†é…å™¨æ¶æ„è®¾è®¡3.1 æ ¸å¿ƒæ¥å£Ceph å®šä¹‰äº†ç»Ÿä¸€çš„åˆ†é…å™¨æ¥å£ï¼š\nclass Allocator &#123;public:  // åˆ†é…æŒ‡å®šå¤§å°çš„ç©ºé—´  virtual int64_t allocate(    uint64_t want_size,      // æœŸæœ›åˆ†é…çš„å¤§å°    uint64_t alloc_unit,     // åˆ†é…å•å…ƒï¼ˆé€šå¸¸ 4KBï¼‰    uint64_t max_alloc_size, // å•ä¸ª extent æœ€å¤§å¤§å°    int64_t hint,            // ä½ç½®æç¤ºï¼ˆä¼˜åŒ–å±€éƒ¨æ€§ï¼‰    PExtentVector *extents   // [è¾“å‡º] åˆ†é…çš„ç‰©ç† extent åˆ—è¡¨  ) = 0;  // é‡Šæ”¾ç©ºé—´  virtual void release(    const interval_set&lt;uint64_t&gt;&amp; release_set  ) = 0;  // è·å–å¯ç”¨ç©ºé—´å¤§å°  virtual uint64_t get_free() = 0;  // è·å–ç¢ç‰‡ç‡  virtual double get_fragmentation() = 0;  // åˆå§‹åŒ–æ—¶æ·»åŠ ç©ºé—²ç©ºé—´  virtual void init_add_free(uint64_t offset, uint64_t length) = 0;  // åˆå§‹åŒ–æ—¶ç§»é™¤å·²ä½¿ç”¨ç©ºé—´  virtual void init_rm_free(uint64_t offset, uint64_t length) = 0;&#125;;\n\n3.2 å…³é”®æ•°æ®ç»“æ„Extentï¼ˆåŒºæ®µï¼‰è¡¨ç¤ºä¸€æ®µè¿ç»­çš„ç£ç›˜ç©ºé—´ï¼š\nstruct bluestore_pextent_t &#123;  uint64_t offset;  // èµ·å§‹åç§»  uint64_t length;  // é•¿åº¦&#125;;typedef std::vector&lt;bluestore_pextent_t&gt; PExtentVector;\n\nåˆ†é…ç¤ºä¾‹ç£ç›˜å¸ƒå±€ï¼š[å·²ç”¨][  ç©ºé—²100MB  ][å·²ç”¨][  ç©ºé—²50MB  ]åˆ†é… 60MBï¼š  - æŸ¥æ‰¾ï¼šæ‰¾åˆ° 100MB ç©ºé—²å—  - åˆ†é…ï¼š[offset: 1000MB, length: 60MB]  - æ›´æ–°ï¼šå‰©ä½™ [offset: 1060MB, length: 40MB] æ ‡è®°ä¸ºç©ºé—²\n\n3.3 å·¥ä½œæµç¨‹â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚                      BlueStore                          â”‚â”‚                                                         â”‚â”‚  å†™å…¥å¯¹è±¡ â”€â”€â”                                           â”‚â”‚            â”‚                                            â”‚â”‚            â†“                                            â”‚â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚â”‚  â”‚   Allocator      â”‚â—„â”€â”€â”€â”€â”€â”€â–ºâ”‚  FreelistManager â”‚     â”‚â”‚  â”‚                  â”‚        â”‚   (RocksDB)      â”‚     â”‚â”‚  â”‚ â€¢ å†…å­˜ä¸­ç®¡ç†     â”‚        â”‚  æŒä¹…åŒ–ç©ºé—²ä¿¡æ¯   â”‚     â”‚â”‚  â”‚ â€¢ å¿«é€Ÿåˆ†é…       â”‚        â”‚                  â”‚     â”‚â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚â”‚            â”‚                                            â”‚â”‚            â†“                                            â”‚â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                  â”‚â”‚  â”‚   Block Device   â”‚                                  â”‚â”‚  â”‚   (è£¸å—è®¾å¤‡)     â”‚                                  â”‚â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                  â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nå…³é”®ç‚¹ï¼š\n\nAllocatorï¼šå†…å­˜ä¸­ç®¡ç†ï¼Œæ€§èƒ½å…³é”®è·¯å¾„\nFreelistManagerï¼šæŒä¹…åŒ–åˆ° RocksDBï¼Œé‡å¯æ—¶æ¢å¤\n\n\n4. äº”ç§åˆ†é…å™¨å®ç°è¯¦è§£Ceph æä¾›äº† 5 ç§åˆ†é…å™¨å®ç°ï¼Œæ¯ç§éƒ½æœ‰ä¸åŒçš„è®¾è®¡æƒè¡¡ã€‚\n4.1 StupidAllocatorï¼ˆç®€å•åˆ†é…å™¨ï¼‰è®¾è®¡åŸç†StupidAllocator ä½¿ç”¨ interval_set ç»“æ„ï¼ŒæŒ‰å¤§å°åˆ†æ¡¶ï¼ˆbinï¼‰ç®¡ç†ç©ºé—²å—ï¼š\nclass StupidAllocator : public Allocator &#123;  // å¤šä¸ªæ¡¶ï¼ŒæŒ‰ 2 çš„å¹‚æ¬¡åˆ†ç»„  std::vector&lt;interval_set_t&gt; free;    // [0-64KB] â†’ bin 0  // [64KB-512KB] â†’ bin 1  // [512KB-4MB] â†’ bin 2  // ...&#125;;\n\nåˆ†é…ç­–ç•¥\næ ¹æ®è¯·æ±‚å¤§å°è®¡ç®— bin\nä»å¯¹åº” bin ä¸­æŸ¥æ‰¾\næ‰¾ä¸åˆ°åˆ™å»æ›´å¤§çš„ bin\nSimple first-fit ç­–ç•¥\n\nä¼˜ç¼ºç‚¹ä¼˜ç‚¹ï¼š\n\nâœ… å®ç°ç®€å•ï¼Œæ˜“äºç†è§£\nâœ… å†…å­˜å ç”¨ä¸­ç­‰\n\nç¼ºç‚¹ï¼š\n\nâŒ æ€§èƒ½ä¸€èˆ¬\nâŒ ç¢ç‰‡æ§åˆ¶å·®\nâŒ ä¸é€‚åˆç”Ÿäº§ç¯å¢ƒ\n\né€‚ç”¨åœºæ™¯ï¼š æµ‹è¯•ã€å¼€å‘ç¯å¢ƒ\n\n4.2 BitmapAllocatorï¼ˆä½å›¾åˆ†é…å™¨ï¼‰è®¾è®¡åŸç†ä½¿ç”¨ ä½å›¾ï¼ˆBitmapï¼‰ è¡¨ç¤ºæ¯ä¸ªåˆ†é…å•å…ƒçš„çŠ¶æ€ï¼š\nç£ç›˜åˆ’åˆ†ï¼šæ¯ 4KB ä¸€ä¸ªåˆ†é…å•å…ƒä½å›¾è¡¨ç¤ºï¼šBit:    0  1  2  3  4  5  6  7  8  9  10 11 12çŠ¶æ€:   å·² ç©º ç©º ç©º å·² å·² ç©º ç©º ç©º ç©º å·² ç©º ç©º       ç”¨ é—² é—² é—² ç”¨ ç”¨ é—² é—² é—² é—² ç”¨ é—² é—²åˆ†é… 16KB (4ä¸ªå•å…ƒ)ï¼š  - æ‰«æä½å›¾æ‰¾åˆ°è¿ç»­çš„ 4 ä¸ª 1  - ä½ç½® 6-9 å¯ç”¨  - æ ‡è®°ä¸ºå·²ç”¨ï¼š...00000111...\n\næ•°æ®ç»“æ„class BitmapAllocator : public Allocator,  public AllocatorLevel02&lt;AllocatorLevel01Loose&gt; &#123;    // ä¸¤å±‚ä½å›¾ç»“æ„  // L1: ç²—ç²’åº¦ä½å›¾ï¼ˆæ¯ bit ä»£è¡¨å¤šä¸ª L2 å—ï¼‰  // L2: ç»†ç²’åº¦ä½å›¾ï¼ˆæ¯ bit ä»£è¡¨ 4KBï¼‰&#125;;\n\nåˆ†é…ç­–ç•¥\nåœ¨ L1 ä½å›¾å¿«é€Ÿå®šä½å¯èƒ½çš„ç©ºé—²åŒºåŸŸ\nåœ¨ L2 ä½å›¾ç²¾ç¡®æŸ¥æ‰¾è¿ç»­ç©ºé—²å—\nåˆ©ç”¨ä½è¿ç®—åŠ é€ŸæŸ¥æ‰¾\n\nä¼˜ç¼ºç‚¹ä¼˜ç‚¹ï¼š\n\nâœ… å†…å­˜å ç”¨å¯é¢„æµ‹ï¼šO(è®¾å¤‡å¤§å°&#x2F;åˆ†é…å•å…ƒ)\n10TB è®¾å¤‡ï¼Œ4KB å•å…ƒ â†’ 320MB å†…å­˜\n\n\nâœ… æŸ¥æ‰¾å¿«é€Ÿï¼šä½è¿ç®—é«˜æ•ˆ\nâœ… ç¢ç‰‡å¤„ç†å¥½\n\nç¼ºç‚¹ï¼š\n\nâŒ å¤§è®¾å¤‡å†…å­˜å ç”¨é«˜\nâŒ åˆå§‹åŒ–æ—¶é—´é•¿\n\né€‚ç”¨åœºæ™¯ï¼š\n\nâœ… SSD è®¾å¤‡\nâœ… å°æ–‡ä»¶è´Ÿè½½\nâœ… å†…å­˜å……è¶³åœºæ™¯\n\n\n4.3 AvlAllocatorï¼ˆAVL æ ‘åˆ†é…å™¨ï¼‰è®¾è®¡åŸç†ä½¿ç”¨ ä¸¤æ£µ AVL æ ‘ ç®¡ç†ç©ºé—²åŒºé—´ï¼š\nstruct range_seg_t &#123;  uint64_t start;  // èµ·å§‹ä½ç½®  uint64_t end;    // ç»“æŸä½ç½®&#125;;class AvlAllocator : public Allocator &#123;  // æ ‘ 1ï¼šæŒ‰åç§»é‡æ’åºï¼ˆç”¨äºä½ç½®æŸ¥æ‰¾ï¼‰  avl_set&lt;range_seg_t, by_offset&gt; range_tree;    // æ ‘ 2ï¼šæŒ‰å¤§å°æ’åºï¼ˆç”¨äºå¤§å°æŸ¥æ‰¾ï¼‰  avl_multiset&lt;range_seg_t, by_size&gt; range_size_tree;&#125;;\n\nå¯è§†åŒ–ç¤ºä¾‹ç©ºé—²åŒºé—´ï¼š[100MB-200MB] [500MB-600MB] [800MB-1000MB]range_tree (æŒ‰åç§»):         [500-600]        /         \\   [100-200]    [800-1000]range_size_tree (æŒ‰å¤§å°):         [500-600]  100MB        /         \\   [100-200]    [800-1000]    100MB         200MB\n\nåŠ¨æ€åˆ†é…ç­–ç•¥// ç©ºé—´å……è¶³æ—¶ (&gt;1% ç©ºé—²)if (free_space_pct &gt; threshold) &#123;  // First-Fitï¼šæŒ‰åç§»æŸ¥æ‰¾  // ä¼˜ç‚¹ï¼šå‡å°‘ç¢ç‰‡ï¼Œæé«˜å±€éƒ¨æ€§  search_by_offset(range_tree, cursor);&#125;// ç©ºé—´ç´§å¼ æ—¶else &#123;  // Best-Fitï¼šæŒ‰å¤§å°æŸ¥æ‰¾  // ä¼˜ç‚¹ï¼šæé«˜ç©ºé—´åˆ©ç”¨ç‡  search_by_size(range_size_tree, want_size);&#125;\n\nä¼˜ç¼ºç‚¹ä¼˜ç‚¹ï¼š\n\nâœ… åŠ¨æ€ç­–ç•¥ï¼šæ ¹æ®ç©ºé—²åº¦è‡ªåŠ¨è°ƒæ•´\nâœ… æ€§èƒ½å‡è¡¡ï¼šO(log N) æŸ¥æ‰¾æ—¶é—´\nâœ… ç¢ç‰‡æ§åˆ¶å¥½\nâœ… ç”Ÿäº§ç¯å¢ƒæ¨è\n\nç¼ºç‚¹ï¼š\n\nâŒ å†…å­˜ä¸å¯æ§ï¼šç¢ç‰‡å¤šæ—¶å ç”¨é«˜\næç«¯æƒ…å†µï¼šæ•°ç™¾ä¸‡ä¸ªå°ç©ºé—²å— â†’ æ•° GB å†…å­˜\n\n\nâŒ é«˜ç¢ç‰‡ä¸‹æ€§èƒ½ä¸‹é™\n\né€‚ç”¨åœºæ™¯ï¼š\n\nâœ… é€šç”¨åœºæ™¯\nâœ… ç¢ç‰‡å¯æ§ç¯å¢ƒ\nâœ… ä¸­ç­‰è§„æ¨¡è®¾å¤‡\n\n\n4.4 BtreeAllocatorï¼ˆB æ ‘åˆ†é…å™¨ï¼‰è®¾è®¡åŸç†ä¸ AvlAllocator ç±»ä¼¼ï¼Œä½†ä½¿ç”¨ B-tree æ›¿ä»£ AVL æ ‘ï¼š\nclass BtreeAllocator : public Allocator &#123;  // ä½¿ç”¨ B-tree ç»“æ„  btree::btree_map&lt;uint64_t, range_seg_t&gt; range_tree;  btree::btree_multimap&lt;uint64_t, range_seg_t&gt; range_size_tree;&#125;;\n\nB-tree vs AVLAVL Tree (äºŒå‰æ ‘):       [50]      /    \\   [30]    [70]   /  \\    /  \\[20][40][60][80]B-tree (å¤šå‰æ ‘):    [30 | 60]    /    |    \\[10,20][40,50][70,80,90]\n\nä¼˜ç¼ºç‚¹ä¼˜ç‚¹ï¼š\n\nâœ… æ›´å¥½çš„ç¼“å­˜å±€éƒ¨æ€§ï¼šèŠ‚ç‚¹å­˜å‚¨å¤šä¸ªå…ƒç´ \nâœ… æ ‘é«˜åº¦æ›´ä½ï¼šå‡å°‘æŒ‡é’ˆè·³è½¬\nâœ… å¤§è§„æ¨¡æ•°æ®æ€§èƒ½å¥½\n\nç¼ºç‚¹ï¼š\n\nâŒ å®ç°å¤æ‚\nâŒ å°è§„æ¨¡æ•°æ®å¼€é”€å¤§\n\né€‚ç”¨åœºæ™¯ï¼š\n\nâœ… å¤§å‹è®¾å¤‡ï¼ˆ&gt;10TBï¼‰\nâœ… é«˜ç¢ç‰‡åœºæ™¯\n\n\n4.5 HybridAllocatorï¼ˆæ··åˆåˆ†é…å™¨ï¼‰â­ æ¨èè®¾è®¡åŸç†ç»“åˆ AVL å’Œ Bitmap çš„ä¼˜åŠ¿ï¼Œæ§åˆ¶å†…å­˜å ç”¨ï¼š\nclass HybridAllocator : public AvlAllocator &#123;  uint64_t max_mem;        // å†…å­˜ä¸Šé™  BitmapAllocator* bitmap; // æº¢å‡ºå­˜å‚¨    virtual void _spillover_range(uint64_t start, uint64_t end) override &#123;    // å½“ AVL æ ‘è¶…è¿‡å†…å­˜é™åˆ¶æ—¶    // å°†æœ€å°çš„ç©ºé—²å—æº¢å‡ºåˆ° Bitmap    bitmap-&gt;init_add_free(start, end);  &#125;&#125;;\n\nå·¥ä½œæµç¨‹â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚           HybridAllocator                   â”‚â”‚                                             â”‚â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚â”‚  â”‚   AVL Tree (in-memory)  â”‚               â”‚â”‚  â”‚   å­˜å‚¨å¤§ç©ºé—²å—           â”‚  å†…å­˜ &lt; 256MB â”‚â”‚  â”‚   [1GB-2GB]             â”‚               â”‚â”‚  â”‚   [5GB-6GB]             â”‚               â”‚â”‚  â”‚   ...                   â”‚               â”‚â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚â”‚              â†“ æº¢å‡º                         â”‚â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚â”‚  â”‚   Bitmap (spillover)    â”‚               â”‚â”‚  â”‚   å­˜å‚¨å°ç¢ç‰‡å—           â”‚               â”‚â”‚  â”‚   [4KB] [8KB] [12KB]... â”‚               â”‚â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜åˆ†é…é€»è¾‘ï¼š1. ä¼˜å…ˆä» AVL æ ‘åˆ†é…ï¼ˆå¿«é€Ÿï¼‰2. æ‰¾ä¸åˆ°åˆ™æŸ¥è¯¢ Bitmap3. å®šæœŸæ•´ç†ï¼šBitmap ä¸­å¤§å—åˆå¹¶å› AVL\n\nå†…å­˜æ§åˆ¶ç­–ç•¥// é…ç½®ï¼šæœ€å¤§ 256MBbluestore_hybrid_alloc_mem_cap = 268435456// å½“ AVL æ ‘è¾¾åˆ°å®¹é‡é™åˆ¶if (range_tree.size() &gt;= max_ranges) &#123;  // ç§»é™¤æœ€å°çš„ç©ºé—²å—åˆ° Bitmap  auto smallest = range_size_tree.begin();  spillover_to_bitmap(smallest);&#125;\n\nä¼˜ç¼ºç‚¹ä¼˜ç‚¹ï¼š\n\nâœ… å†…å­˜å¯æ§ï¼šè®¾ç½®ä¸Šé™ï¼Œå¯é¢„æµ‹\nâœ… æ€§èƒ½ä¼˜ç§€ï¼šå¤§å—åˆ†é…å¿«é€Ÿï¼ˆAVLï¼‰\nâœ… ç¢ç‰‡å¤„ç†å¥½ï¼šå°ç¢ç‰‡äº¤ç»™ Bitmap\nâœ… ç”Ÿäº§ç¯å¢ƒé¦–é€‰ â­â­â­\n\nç¼ºç‚¹ï¼š\n\nâŒ å®ç°æœ€å¤æ‚\nâŒ éœ€è¦è°ƒä¼˜å‚æ•°\n\né€‚ç”¨åœºæ™¯ï¼š\n\nâœ… æ‰€æœ‰ç”Ÿäº§ç¯å¢ƒ ğŸ†\nâœ… å¤§è§„æ¨¡éƒ¨ç½²\nâœ… æ··åˆè´Ÿè½½\n\n\n5. æ€§èƒ½å¯¹æ¯”ä¸é€‰æ‹©5.1 ç»¼åˆå¯¹æ¯”è¡¨\n\n\nåˆ†é…å™¨\nå†…å­˜å ç”¨\nåˆ†é…é€Ÿåº¦\nç¢ç‰‡å¤„ç†\nå¤æ‚åº¦\nç”Ÿäº§æ¨è\n\n\n\nStupid\nä¸­ç­‰\nâ­â­\nâ­â­\nç®€å•\nâŒ ä»…æµ‹è¯•\n\n\nBitmap\nå›ºå®šï¼ˆé«˜ï¼‰\nâ­â­â­â­\nâ­â­â­â­\nä¸­ç­‰\nâœ… SSD\n\n\nAVL\nåŠ¨æ€\nâ­â­â­\nâ­â­â­â­\nä¸­ç­‰\nâœ… é€šç”¨\n\n\nBtree\nåŠ¨æ€\nâ­â­â­\nâ­â­â­â­\né«˜\nâœ… å¤§è®¾å¤‡\n\n\nHybrid\nå¯æ§\nâ­â­â­â­â­\nâ­â­â­â­â­\né«˜\nâœ…âœ… é¦–é€‰\n\n\n5.2 é€‰æ‹©å»ºè®®å†³ç­–æ ‘å¼€å§‹ â”‚ â”œâ”€ æµ‹è¯•/å¼€å‘ç¯å¢ƒï¼Ÿ â”‚   â””â”€ æ˜¯ â†’ StupidAllocator â”‚ â”œâ”€ å†…å­˜ä¸¥æ ¼å—é™ï¼Ÿ â”‚   â””â”€ æ˜¯ â†’ HybridAllocator (è®¾ç½® mem_cap) â”‚ â”œâ”€ è®¾å¤‡ç±»å‹ï¼Ÿ â”‚   â”œâ”€ SSD + å°æ–‡ä»¶è´Ÿè½½ â†’ BitmapAllocator â”‚   â”œâ”€ å¤§è®¾å¤‡ (&gt;20TB) â†’ BtreeAllocator â”‚   â””â”€ å…¶ä»– â†’ HybridAllocator â­ â”‚ â””â”€ ä¸ç¡®å®šï¼Ÿâ†’ HybridAllocator (é»˜è®¤æ¨è)\n\nåœºæ™¯æ¨èåœºæ™¯ 1ï¼šé«˜æ€§èƒ½ SSD é›†ç¾¤\nbluestore_allocator = hybridbluestore_hybrid_alloc_mem_cap = 536870912  # 512MB\n\nåœºæ™¯ 2ï¼šHDD å¤§å®¹é‡å­˜å‚¨\nbluestore_allocator = btree\n\nåœºæ™¯ 3ï¼šå†…å­˜å—é™ç¯å¢ƒ\nbluestore_allocator = hybridbluestore_hybrid_alloc_mem_cap = 134217728  # 128MB\n\n\n6. æºç è§£æ6.1 æ ¸å¿ƒåˆ†é…æµç¨‹// src/os/bluestore/BlueStore.ccint BlueStore::_do_alloc_write(    TransContext *txc,    CollectionRef&amp; c,    OnodeRef o,    BlueStore::WriteContext *wctx)&#123;  uint64_t need = wctx-&gt;logical_length;    // 1. è°ƒç”¨åˆ†é…å™¨åˆ†é…ç©ºé—´  PExtentVector extents;  int64_t got = alloc-&gt;allocate(    need,                    // éœ€è¦çš„å¤§å°    min_alloc_size,          // æœ€å°åˆ†é…å•å…ƒ (4KB)    need,                    // æœ€å¤§åˆ†é…å¤§å°    0,                       // hint (ä½ç½®æç¤º)    &amp;extents                 // è¾“å‡ºï¼šåˆ†é…çš„ extent åˆ—è¡¨  );    if (got &lt; 0) &#123;    // åˆ†é…å¤±è´¥    return got;  &#125;    // 2. å†™å…¥æ•°æ®åˆ°åˆ†é…çš„ç‰©ç†ä½ç½®  for (auto&amp; p : extents) &#123;    r = bdev-&gt;aio_write(      p.offset,              // ç‰©ç†åç§»      bl,                    // æ•°æ®      &amp;txc-&gt;ioc,            // IO ä¸Šä¸‹æ–‡      false    );  &#125;    // 3. æ›´æ–°å…ƒæ•°æ®  o-&gt;extent_map.punch_hole(offset, length);  o-&gt;extent_map.add_extent(offset, extents);    return 0;&#125;\n\n6.2 AVL åˆ†é…å™¨æ ¸å¿ƒä»£ç // src/os/bluestore/AvlAllocator.ccint64_t AvlAllocator::_allocate(    uint64_t want,    uint64_t unit,    uint64_t max_alloc_size,    int64_t  hint,    PExtentVector *extents)&#123;  std::lock_guard&lt;std::mutex&gt; l(lock);    uint64_t allocated = 0;    while (allocated &lt; want) &#123;    uint64_t offset, length;        // é€‰æ‹©åˆ†é…ç­–ç•¥    if (_use_first_fit()) &#123;      // First-fit: æŒ‰åç§»æŸ¥æ‰¾ï¼ˆå‡å°‘ç¢ç‰‡ï¼‰      offset = _pick_block_after(&amp;cursor, want - allocated, unit);    &#125; else &#123;      // Best-fit: æŒ‰å¤§å°æŸ¥æ‰¾ï¼ˆæé«˜åˆ©ç”¨ç‡ï¼‰      offset = _pick_block_fits(want - allocated, unit);    &#125;        if (offset == 0) &#123;      break;  // æ‰¾ä¸åˆ°åˆé€‚çš„å—    &#125;        // ä»æ ‘ä¸­ç§»é™¤åˆ†é…çš„åŒºé—´    _remove_from_tree(offset, length);        // è®°å½•åˆ†é…ç»“æœ    extents-&gt;emplace_back(offset, length);    allocated += length;  &#125;    return allocated;&#125;// æŒ‰å¤§å°æŸ¥æ‰¾uint64_t AvlAllocator::_pick_block_fits(uint64_t size, uint64_t align)&#123;  // åœ¨ range_size_tree ä¸­æŸ¥æ‰¾ &gt;= size çš„æœ€å°å—  range_seg_t search_node(0, size);  auto rs_it = range_size_tree.lower_bound(search_node);    if (rs_it == range_size_tree.end()) &#123;    return 0;  // æ²¡æœ‰è¶³å¤Ÿå¤§çš„å—  &#125;    uint64_t offset = p2roundup(rs_it-&gt;start, align);  return offset;&#125;\n\n6.3 åˆ†é…å™¨åˆ›å»º// src/os/bluestore/Allocator.ccAllocator *Allocator::create(    CephContext* cct,    std::string_view type,    int64_t size,    int64_t block_size,    std::string_view name)&#123;  Allocator* alloc = nullptr;    if (type == &quot;stupid&quot;) &#123;    alloc = new StupidAllocator(cct, size, block_size, name);  &#125; else if (type == &quot;bitmap&quot;) &#123;    alloc = new BitmapAllocator(cct, size, block_size, name);  &#125; else if (type == &quot;avl&quot;) &#123;    alloc = new AvlAllocator(cct, size, block_size, name);  &#125; else if (type == &quot;btree&quot;) &#123;    alloc = new BtreeAllocator(cct, size, block_size, name);  &#125; else if (type == &quot;hybrid&quot;) &#123;    uint64_t mem_cap = cct-&gt;_conf.get_val&lt;uint64_t&gt;(      &quot;bluestore_hybrid_alloc_mem_cap&quot;    );    alloc = new HybridAllocator(cct, size, block_size, mem_cap, name);  &#125;    return alloc;&#125;\n\n\n7. æœ€ä½³å®è·µ7.1 é…ç½®ä¼˜åŒ–åŸºç¡€é…ç½®# ceph.conf[osd]# é€‰æ‹©åˆ†é…å™¨ç±»å‹bluestore_allocator = hybrid# Hybrid åˆ†é…å™¨å†…å­˜ä¸Šé™ (256MB)bluestore_hybrid_alloc_mem_cap = 268435456# æœ€å°åˆ†é…å•å…ƒ (HDD: 64KB, SSD: 4KB)bluestore_min_alloc_size_hdd = 65536bluestore_min_alloc_size_ssd = 4096# AVL åˆ†é…å™¨å‚æ•°bluestore_avl_alloc_ff_max_search_count = 100bluestore_avl_alloc_ff_max_search_bytes = 1048576\n\né«˜æ€§èƒ½ SSD é…ç½®[osd]bluestore_allocator = hybridbluestore_hybrid_alloc_mem_cap = 536870912  # 512MBbluestore_min_alloc_size_ssd = 4096\n\nå¤§å®¹é‡ HDD é…ç½®[osd]bluestore_allocator = btreebluestore_min_alloc_size_hdd = 65536\n\n7.2 ç›‘æ§æŒ‡æ ‡æŸ¥çœ‹åˆ†é…å™¨çŠ¶æ€# æŸ¥çœ‹ OSD åˆ†é…å™¨ä¿¡æ¯ceph daemon osd.0 bluestore allocator dump# è¾“å‡ºç¤ºä¾‹&#123;    &quot;allocator_type&quot;: &quot;hybrid&quot;,    &quot;capacity&quot;: 10737418240,    &quot;alloc_unit&quot;: 4096,    &quot;alloc_size_min&quot;: 4096,    &quot;free&quot;: 8589934592,    &quot;fragmentation&quot;: 0.15,    &quot;num_free_ranges&quot;: 12450&#125;\n\nå…³é”®æŒ‡æ ‡# ç¢ç‰‡ç‡fragmentation_score = num_free_ranges / (free_blocks - 1)# ç©ºé—´åˆ©ç”¨ç‡utilization = (capacity - free) / capacity# åˆ†é…æˆåŠŸç‡alloc_success_rate = allocated / requested\n\nPrometheus ç›‘æ§# æ·»åŠ ç›‘æ§å‘Šè­¦groups:- name: ceph_allocator  rules:  # ç¢ç‰‡ç‡è¿‡é«˜  - alert: HighFragmentation    expr: ceph_bluestore_fragmentation &gt; 0.3    for: 10m    annotations:      summary: &quot;OSD &#123;&#123; $labels.osd &#125;&#125; fragmentation high&quot;        # å¯ç”¨ç©ºé—´ä¸è¶³  - alert: LowFreeSpace    expr: ceph_bluestore_free_bytes / ceph_bluestore_capacity_bytes &lt; 0.1    for: 5m\n\n7.3 æ€§èƒ½è°ƒä¼˜è°ƒä¼˜æ­¥éª¤1. åŸºçº¿æµ‹è¯•\n# ä½¿ç”¨ fio æµ‹è¯•åŸºçº¿æ€§èƒ½fio --name=test --ioengine=libaio --direct=1 \\    --bs=4k --rw=randwrite --numjobs=4 \\    --size=10G --runtime=300\n\n2. è°ƒæ•´åˆ†é…å™¨\n# ä¿®æ”¹é…ç½®ceph config set osd.* bluestore_allocator hybridceph config set osd.* bluestore_hybrid_alloc_mem_cap 536870912# é‡å¯ OSDsystemctl restart ceph-osd@0\n\n3. å‹åŠ›æµ‹è¯•\n# RBD æµ‹è¯•rbd bench --io-type write --io-size 4K --io-pattern rand test-pool/test-image# RADOS æµ‹è¯•rados bench -p test-pool 300 write -t 32\n\n4. å¯¹æ¯”ç»“æœ\n# æŸ¥çœ‹æ€§èƒ½æŒ‡æ ‡ceph osd perfceph daemon osd.0 perf dump\n\nå¸¸è§é—®é¢˜è°ƒä¼˜é—®é¢˜ 1ï¼šåˆ†é…å»¶è¿Ÿé«˜\n# ç—‡çŠ¶ï¼šapply_latency å’Œ commit_latency é«˜# æ–¹æ¡ˆ 1ï¼šå¢åŠ å†…å­˜ä¸Šé™ceph config set osd.* bluestore_hybrid_alloc_mem_cap 1073741824  # 1GB# æ–¹æ¡ˆ 2ï¼šåˆ‡æ¢åˆ° bitmap (SSD)ceph config set osd.* bluestore_allocator bitmap\n\né—®é¢˜ 2ï¼šå†…å­˜å ç”¨è¿‡é«˜\n# ç—‡çŠ¶ï¼šOSD å†…å­˜ä½¿ç”¨æŒç»­å¢é•¿# æ–¹æ¡ˆ 1ï¼šé™åˆ¶ hybrid å†…å­˜ceph config set osd.* bluestore_hybrid_alloc_mem_cap 134217728  # 128MB# æ–¹æ¡ˆ 2ï¼šè§¦å‘ç¢ç‰‡æ•´ç†ceph osd compact &lt;osd-id&gt;\n\né—®é¢˜ 3ï¼šç¢ç‰‡ç‡è¿‡é«˜\n# ç—‡çŠ¶ï¼šfragmentation &gt; 0.3# æ–¹æ¡ˆ 1ï¼šç¦»çº¿ç¢ç‰‡æ•´ç†systemctl stop ceph-osd@0ceph-bluestore-tool --path /var/lib/ceph/osd/ceph-0 \\                    fsck --deep# æ–¹æ¡ˆ 2ï¼šæ•°æ®é‡å¹³è¡¡ceph osd out osd.0# ç­‰å¾…æ•°æ®è¿ç§»ceph osd in osd.0\n\n7.4 å‡çº§å’Œè¿ç§»åœ¨çº¿åˆ‡æ¢åˆ†é…å™¨# 1. è®¾ç½®æ–°åˆ†é…å™¨ (ä¸‹æ¬¡é‡å¯ç”Ÿæ•ˆ)ceph config set osd.0 bluestore_allocator hybrid# 2. å®‰å…¨é‡å¯ OSDceph osd set nooutceph osd set norebalancesystemctl restart ceph-osd@0ceph osd unset nooutceph osd unset norebalance# 3. éªŒè¯ceph daemon osd.0 config get bluestore_allocator\n\næ‰¹é‡è¿ç§»#!/bin/bash# æ‰¹é‡åˆ‡æ¢æ‰€æœ‰ OSD åˆ° hybrid åˆ†é…å™¨for osd in $(ceph osd ls); do  echo &quot;Processing OSD.$osd&quot;    # è®¾ç½®é…ç½®  ceph config set osd.$osd bluestore_allocator hybrid    # é‡å¯  ceph osd set noout  systemctl restart ceph-osd@$osd    # ç­‰å¾… OSD æ¢å¤  while ! ceph osd stat | grep -q &quot;up $((osd+1))&quot;; do    sleep 5  done    ceph osd unset noout  sleep 30  # é—´éš” 30 ç§’done\n\n\n8. é—®é¢˜æ’æŸ¥8.1 å¸¸è§é—®é¢˜é—®é¢˜ 1ï¼šåˆ†é…å¤±è´¥ (ENOSPC)ç°è±¡ï¼š\nå®¢æˆ·ç«¯å†™å…¥å¤±è´¥: No space left on deviceä½† ceph df æ˜¾ç¤ºè¿˜æœ‰ç©ºé—´\n\nåŸå› ï¼š\n\nç¢ç‰‡åŒ–ä¸¥é‡ï¼Œæ‰¾ä¸åˆ°è¿ç»­ç©ºé—´\nåˆ†é…å™¨å†…éƒ¨æ•°æ®ç»“æ„ä¸ä¸€è‡´\n\næ’æŸ¥æ­¥éª¤ï¼š\n# 1. æ£€æŸ¥ç¢ç‰‡ç‡ceph daemon osd.0 bluestore allocator dump | grep fragmentation# 2. æ£€æŸ¥ç©ºé—²ç©ºé—´åˆ†å¸ƒceph daemon osd.0 bluestore allocator dump | grep num_free_ranges# 3. æŸ¥çœ‹ OSD æ—¥å¿—tail -f /var/log/ceph/ceph-osd.0.log | grep -i &quot;alloc\\|enospc&quot;\n\nè§£å†³æ–¹æ¡ˆï¼š\n# æ–¹æ¡ˆ 1ï¼šæ•´ç†ç¢ç‰‡ (ç¦»çº¿)ceph osd out 0systemctl stop ceph-osd@0ceph-objectstore-tool --data-path /var/lib/ceph/osd/ceph-0 \\                       --op compactsystemctl start ceph-osd@0ceph osd in 0# æ–¹æ¡ˆ 2ï¼šå¢å¤§åˆ†é…å•å…ƒ (é‡å»º OSD)bluestore_min_alloc_size_hdd = 131072  # 128KB\n\né—®é¢˜ 2ï¼šå†…å­˜æ³„æ¼ç°è±¡ï¼š\nOSD å†…å­˜æŒç»­å¢é•¿æœ€ç»ˆè§¦å‘ OOM killer\n\næ’æŸ¥æ­¥éª¤ï¼š\n# 1. æ£€æŸ¥åˆ†é…å™¨å†…å­˜ceph daemon osd.0 dump_mempools | grep bluestore_alloc# 2. æ£€æŸ¥ç©ºé—²åŒºé—´æ•°é‡ceph daemon osd.0 bluestore allocator dump | grep num_free_ranges# 3. å¦‚æœ num_free_ranges å¼‚å¸¸å¤§ (&gt;100ä¸‡)ï¼Œè¯´æ˜ç¢ç‰‡ä¸¥é‡\n\nè§£å†³æ–¹æ¡ˆï¼š\n# ä¸´æ—¶ï¼šé‡å¯ OSDsystemctl restart ceph-osd@0# é•¿æœŸï¼šåˆ‡æ¢åˆ°å†…å­˜å¯æ§çš„åˆ†é…å™¨ceph config set osd.0 bluestore_allocator hybridceph config set osd.0 bluestore_hybrid_alloc_mem_cap 268435456\n\né—®é¢˜ 3ï¼šæ€§èƒ½æŠ–åŠ¨ç°è±¡ï¼š\nå†™å…¥å»¶è¿Ÿå‘¨æœŸæ€§å‡é«˜iostat æ˜¾ç¤ºè®¾å¤‡åˆ©ç”¨ç‡ä¸é«˜\n\næ’æŸ¥æ­¥éª¤ï¼š\n# 1. æŸ¥çœ‹åˆ†é…è€—æ—¶ceph daemon osd.0 perf dump | grep -A 5 bluestore_alloc# 2. æŸ¥çœ‹ç¢ç‰‡æƒ…å†µceph daemon osd.0 bluestore allocator dump# 3. å¯ç”¨è¯¦ç»†æ—¥å¿—ceph daemon osd.0 config set debug_bluestore 10\n\nè§£å†³æ–¹æ¡ˆï¼š\n# å¢åŠ åˆ†é…å™¨æœç´¢é™åˆ¶ï¼Œé¿å…è¿‡åº¦æœç´¢ceph config set osd.* bluestore_avl_alloc_ff_max_search_count 50ceph config set osd.* bluestore_avl_alloc_ff_max_search_bytes 524288\n\n8.2 è°ƒè¯•å·¥å…·BlueStore Tool# æ£€æŸ¥ allocator çŠ¶æ€ceph-bluestore-tool --path /var/lib/ceph/osd/ceph-0 \\                    show-label# æ·±åº¦æ£€æŸ¥ceph-bluestore-tool --path /var/lib/ceph/osd/ceph-0 \\                    fsck --deep# æŸ¥çœ‹ç©ºé—²ç©ºé—´ceph-bluestore-tool --path /var/lib/ceph/osd/ceph-0 \\                    free-dump# ä¿®å¤ä¸ä¸€è‡´ceph-bluestore-tool --path /var/lib/ceph/osd/ceph-0 \\                    repair\n\næ€§èƒ½åˆ†æ# ä½¿ç”¨ perf åˆ†æåˆ†é…å™¨çƒ­ç‚¹perf record -g -p $(pidof ceph-osd) -- sleep 30perf report --stdio | grep -A 10 Allocator# ä½¿ç”¨ gdb è°ƒè¯•gdb -p $(pidof ceph-osd)(gdb) thread apply all bt(gdb) print allocator-&gt;get_free()\n\n\n9. æ€»ç»“9.1 æ ¸å¿ƒè¦ç‚¹\nåˆ†é…å™¨æ˜¯ BlueStore çš„æ ¸å¿ƒ\n\nç›´æ¥å½±å“æ€§èƒ½ã€å†…å­˜ã€ç¢ç‰‡\n\n\näº”ç§å®ç°ï¼Œå„æœ‰åƒç§‹\n\nStupid: æµ‹è¯•ç”¨\nBitmap: SSD ä¼˜åŒ–ï¼Œå†…å­˜å›ºå®š\nAVL: é€šç”¨ï¼ŒåŠ¨æ€å¹³è¡¡\nBtree: å¤§è®¾å¤‡ä¼˜åŒ–\nHybrid: ç”Ÿäº§é¦–é€‰ â­\n\n\nå…³é”®æƒè¡¡\n\næ€§èƒ½ vs å†…å­˜\nç¢ç‰‡æ§åˆ¶ vs åˆ†é…é€Ÿåº¦\nç®€å• vs åŠŸèƒ½\n\n\nå®è·µå»ºè®®\n\né»˜è®¤ä½¿ç”¨ Hybrid\nç›‘æ§ç¢ç‰‡ç‡å’Œå†…å­˜\nå®šæœŸæ•´ç†ç¢ç‰‡\næ ¹æ®è´Ÿè½½è°ƒä¼˜\n\n\n\n9.2 å†³ç­–å»ºè®®ä½ åº”è¯¥ä½¿ç”¨å“ªä¸ªåˆ†é…å™¨ï¼Ÿâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  ç”Ÿäº§ç¯å¢ƒï¼Ÿ                          â”‚â”‚  â”œâ”€ æ˜¯ â†’ Hybrid Allocator â­â­â­    â”‚â”‚  â””â”€ å¦ â†’ Stupid (æµ‹è¯•) / AVL        â”‚â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ç‰¹æ®Šåœºæ™¯ï¼šâ€¢ é«˜æ€§èƒ½ SSD + å†…å­˜å……è¶³ â†’ Bitmapâ€¢ è¶…å¤§è®¾å¤‡ (&gt;20TB) â†’ Btreeâ€¢ å†…å­˜ä¸¥æ ¼å—é™ â†’ Hybrid (è®¾ç½® mem_cap)\n\n9.3 æœªæ¥å±•æœ›Ceph ç¤¾åŒºæ­£åœ¨æŒç»­ä¼˜åŒ–åˆ†é…å™¨ï¼š\n\næ›´æ™ºèƒ½çš„ç­–ç•¥\n\nåŸºäº workload çš„è‡ªé€‚åº”åˆ†é…\næœºå™¨å­¦ä¹ ä¼˜åŒ–ä½ç½®é€‰æ‹©\n\n\næ›´ä½çš„å¼€é”€\n\næ— é”æ•°æ®ç»“æ„\nå¹¶è¡Œåˆ†é…\n\n\næ›´å¥½çš„ç¢ç‰‡æ§åˆ¶\n\nåœ¨çº¿ç¢ç‰‡æ•´ç†\né¢„æµ‹æ€§ç©ºé—´ç®¡ç†\n\n\næŒä¹…åŒ–å†…å­˜æ”¯æŒ\n\nPMem åŠ é€Ÿå…ƒæ•°æ®\né™ä½é‡å¯æ¢å¤æ—¶é—´\n\n\n\n\nå‚è€ƒèµ„æ–™\næºç \n\nsrc/os/bluestore/Allocator.h - åˆ†é…å™¨æ¥å£\nsrc/os/bluestore/*Allocator.cc - å„å®ç°\n\n\næ–‡æ¡£\n\nBlueStore Configuration Reference\nBlueStore Allocator Analysis\n\n\nè®ºæ–‡\n\nâ€œBlueStore: A New, Faster Storage Backend for Cephâ€\n\n\nç¤¾åŒº\n\nCeph Dev Mailing List\n#ceph-devel IRC\n\n\n\n\nå…³äºä½œè€…by hoshiæœ¬æ–‡åŸºäº Ceph æœ€æ–°ä»£ç ï¼ˆPacific&#x2F;Quincy ç‰ˆæœ¬ï¼‰åˆ†æç¼–å†™ï¼Œæ¶µç›–äº†åˆ†é…å™¨çš„è®¾è®¡åŸç†ã€å®ç°ç»†èŠ‚å’Œæœ€ä½³å®è·µã€‚\n\nå¦‚æœè§‰å¾—æœ¬æ–‡æœ‰å¸®åŠ©ï¼Œæ¬¢è¿åˆ†äº«ï¼ ğŸš€\næœ‰ä»»ä½•é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿æ Issue ã€‚\n","tags":["ceph","seastore"]},{"title":"LRU","url":"/2022/09/18/lru/","content":"ç”¨çº¿æ€§è¡¨åŠ å“ˆå¸Œè¡¨å®ç°LRU\n\n\nçº¿æ€§è¡¨+å“ˆå¸Œè¡¨&gt;&gt;LRUç®—æ³•æ–¹æ³•ï¼šå“ˆå¸Œè¡¨ + åŒå‘é“¾è¡¨ç®—æ³•LRU ç¼“å­˜æœºåˆ¶å¯ä»¥é€šè¿‡å“ˆå¸Œè¡¨è¾…ä»¥åŒå‘é“¾è¡¨å®ç°ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨å’Œä¸€ä¸ªåŒå‘é“¾è¡¨ç»´æŠ¤æ‰€æœ‰åœ¨ç¼“å­˜ä¸­çš„é”®å€¼å¯¹ã€‚\nåŒå‘é“¾è¡¨æŒ‰ç…§è¢«ä½¿ç”¨çš„é¡ºåºå­˜å‚¨äº†è¿™äº›é”®å€¼å¯¹ï¼Œé è¿‘å¤´éƒ¨çš„é”®å€¼å¯¹æ˜¯æœ€è¿‘ä½¿ç”¨çš„ï¼Œè€Œé è¿‘å°¾éƒ¨çš„é”®å€¼å¯¹æ˜¯æœ€ä¹…æœªä½¿ç”¨çš„ã€‚\nå“ˆå¸Œè¡¨å³ä¸ºæ™®é€šçš„å“ˆå¸Œæ˜ å°„ï¼ˆHashMapï¼‰ï¼Œé€šè¿‡ç¼“å­˜æ•°æ®çš„é”®æ˜ å°„åˆ°å…¶åœ¨åŒå‘é“¾è¡¨ä¸­çš„ä½ç½®ã€‚\nè¿™æ ·ä»¥æ¥ï¼Œæˆ‘ä»¬é¦–å…ˆä½¿ç”¨å“ˆå¸Œè¡¨è¿›è¡Œå®šä½ï¼Œæ‰¾å‡ºç¼“å­˜é¡¹åœ¨åŒå‘é“¾è¡¨ä¸­çš„ä½ç½®ï¼Œéšåå°†å…¶ç§»åŠ¨åˆ°åŒå‘é“¾è¡¨çš„å¤´éƒ¨ï¼Œå³å¯åœ¨ O(1)O(1)O(1) çš„æ—¶é—´å†…å®Œæˆ get æˆ–è€… put æ“ä½œã€‚å…·ä½“çš„æ–¹æ³•å¦‚ä¸‹ï¼š\nint LRU::get(int key)&#123;&#125;\n\nå¯¹äº get æ“ä½œï¼Œé¦–å…ˆåˆ¤æ–­ key æ˜¯å¦å­˜åœ¨ï¼š\nå¦‚æœ key ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› âˆ’1ï¼›\nå¦‚æœ key å­˜åœ¨ï¼Œåˆ™ key å¯¹åº”çš„èŠ‚ç‚¹æ˜¯æœ€è¿‘è¢«ä½¿ç”¨çš„èŠ‚ç‚¹ã€‚é€šè¿‡å“ˆå¸Œè¡¨å®šä½åˆ°è¯¥èŠ‚ç‚¹åœ¨åŒå‘é“¾è¡¨ä¸­çš„ä½ç½®ï¼Œå¹¶å°†å…¶ç§»åŠ¨åˆ°åŒå‘é“¾è¡¨çš„å¤´éƒ¨ï¼Œæœ€åè¿”å›è¯¥èŠ‚ç‚¹çš„å€¼ã€‚\nå¯¹äº put æ“ä½œï¼Œé¦–å…ˆåˆ¤æ–­ key æ˜¯å¦å­˜åœ¨ï¼š\nvoid LRU::put(int key,int value)&#123;&#125;\n\nå¦‚æœ key ä¸å­˜åœ¨ï¼Œä½¿ç”¨ key å’Œ value åˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œåœ¨åŒå‘é“¾è¡¨çš„å¤´éƒ¨æ·»åŠ è¯¥èŠ‚ç‚¹ï¼Œå¹¶å°† key å’Œè¯¥èŠ‚ç‚¹æ·»åŠ è¿›å“ˆå¸Œè¡¨ä¸­ã€‚ç„¶ååˆ¤æ–­åŒå‘é“¾è¡¨çš„èŠ‚ç‚¹æ•°æ˜¯å¦è¶…å‡ºå®¹é‡ï¼Œå¦‚æœè¶…å‡ºå®¹é‡ï¼Œåˆ™åˆ é™¤åŒå‘é“¾è¡¨çš„å°¾éƒ¨èŠ‚ç‚¹ï¼Œå¹¶åˆ é™¤å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„é¡¹ï¼›\nå¦‚æœ key å­˜åœ¨ï¼Œåˆ™ä¸ get æ“ä½œç±»ä¼¼ï¼Œå…ˆé€šè¿‡å“ˆå¸Œè¡¨å®šä½ï¼Œå†å°†å¯¹åº”çš„èŠ‚ç‚¹çš„å€¼æ›´æ–°ä¸º valueï¼Œå¹¶å°†è¯¥èŠ‚ç‚¹ç§»åˆ°åŒå‘é“¾è¡¨çš„å¤´éƒ¨ã€‚\nä¸Šè¿°å„é¡¹æ“ä½œä¸­ï¼Œè®¿é—®å“ˆå¸Œè¡¨çš„æ—¶é—´å¤æ‚åº¦ä¸º O(1)ï¼Œåœ¨åŒå‘é“¾è¡¨çš„å¤´éƒ¨æ·»åŠ èŠ‚ç‚¹ã€åœ¨åŒå‘é“¾è¡¨çš„å°¾éƒ¨åˆ é™¤èŠ‚ç‚¹çš„å¤æ‚åº¦ä¹Ÿä¸º O(1)ã€‚è€Œå°†ä¸€ä¸ªèŠ‚ç‚¹ç§»åˆ°åŒå‘é“¾è¡¨çš„å¤´éƒ¨ï¼Œå¯ä»¥åˆ†æˆã€Œåˆ é™¤è¯¥èŠ‚ç‚¹ã€å’Œã€Œåœ¨åŒå‘é“¾è¡¨çš„å¤´éƒ¨æ·»åŠ èŠ‚ç‚¹ã€ä¸¤æ­¥æ“ä½œï¼Œéƒ½å¯ä»¥åœ¨ O(1)æ—¶é—´å†…å®Œæˆã€‚\nå°è´´å£«åœ¨åŒå‘é“¾è¡¨çš„å®ç°ä¸­ï¼Œä½¿ç”¨ä¸€ä¸ªä¼ªå¤´éƒ¨ï¼ˆdummy headï¼‰å’Œä¼ªå°¾éƒ¨ï¼ˆdummy tailï¼‰æ ‡è®°ç•Œé™ï¼Œè¿™æ ·åœ¨æ·»åŠ èŠ‚ç‚¹å’Œåˆ é™¤èŠ‚ç‚¹çš„æ—¶å€™å°±ä¸éœ€è¦æ£€æŸ¥ç›¸é‚»çš„èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ã€‚\nå¤æ‚åº¦åˆ†ææ—¶é—´å¤æ‚åº¦ï¼šå¯¹äº put å’Œ get éƒ½æ˜¯ O(1)ã€‚\nç©ºé—´å¤æ‚åº¦ï¼šO(capacity)O(\\text{capacity})O(capacity)ï¼Œå› ä¸ºå“ˆå¸Œè¡¨å’ŒåŒå‘é“¾è¡¨æœ€å¤šå­˜å‚¨ capacity+1\\text{capacity} + 1capacity+1 ä¸ªå…ƒç´ ã€‚\n#include &lt;iostream&gt;#include&lt;list&gt;#include&lt;unordered_map&gt;using namespace std;using std::cout;using std::endl;class LRU&#123;public:    LRU(int cap)    :_capacity(cap)    &#123;        cout &lt;&lt; &quot;LRU(int cap)&quot; &lt;&lt; endl;            &#125;    int get(int key);    void put(int key,int value);private:    struct cacheNode    &#123;        cacheNode(int key,int v)        :_key(key)        ,_value(v)        &#123;            cout &lt;&lt; &quot;cacheNode(int key,int v)&quot; &lt;&lt; endl;        &#125;        int _key;        int _value;    &#125;;    list&lt;cacheNode&gt; _nodes;//åŒå‘é“¾è¡¨å­˜ï¼Œ    int _capacity;//ç¼“å­˜çš„å¤§å°    unordered_map&lt;int,list&lt;cacheNode&gt;::iterator &gt; _cache;//æ— åºmap ï¼Œ    //å­˜æ”¾çš„æ˜¯ keyå€¼ï¼Œå’Œé“¾è¡¨çš„è¿­ä»£å™¨&#125;;int LRU::get(int key)&#123;    //TODO åˆ¤æ–­keyå€¼æ˜¯å¦åœ¨mapä¸­ï¼Œå¦‚æœå­˜åœ¨ï¼Œç›´æ¥æŠŠä»–    //æ›´æ–°åœ¨é“¾è¡¨çš„å¤´ï¼Œå¹¶ä¸”è¿”å›ä»–çš„value,ä¸å­˜åœ¨åˆ™è¿”å›-1ï¼›        auto it = _cache.find(key);//unordered_map çš„ find å‡½æ•°è¿”å›å€¼ä¸º                            // è¯¥keyå€¼æ‰€å¯¹åº”çš„è¿­ä»£å™¨    if(it!=_cache.end())    &#123;        _nodes.splice(_nodes.begin(),_nodes,it-&gt;second);        //é“¾è¡¨çš„splice å‡½æ•°å¯ä»¥å°† _nodesé“¾è¡¨ä¸­çš„ it-&gt;secondæ‰€æŒ‡å‘çš„å…ƒç´         //è½¬ç§»åˆ°_nodes.begin()çš„å‰é¢        return it-&gt;second-&gt;_value;    &#125;    else    &#123;        return -1;    &#125;&#125;void LRU::put(int key,int value)&#123;    //TODO åˆ¤æ–­key æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨é‚£ä¹ˆï¼Œç›´æ¥æ”¾åœ¨é“¾è¡¨è¡¨å¤´    //å¦‚æœä¸å­˜åœ¨åˆ™åˆ¤æ–­é“¾è¡¨æ˜¯ä¸æ˜¯æ»¡çš„ï¼Œå¦‚æœæ»¡äº†åˆ é™¤æœ«å°¾å…ƒç´     //ç„¶ååœ¨é“¾è¡¨å¤´æ’å…¥ï¼Œå¹¶ä¸”æ’å…¥åˆ°mapä¸­        auto it = _cache.find(key);     if(it!=_cache.end())    &#123;        it-&gt;second-&gt;_value= value;        _nodes.splice(_nodes.begin(),_nodes,it-&gt;second);    &#125;    else    &#123;        if((int)_nodes.size()==_capacity)        &#123;            auto &amp;deleteNode = _nodes.back();            _cache.erase(deleteNode._key);//unordered_map çš„ earseæ“ä½œ                                        // size_type earse(const key_type&amp;key);            _nodes.pop_back();        &#125;        _nodes.push_front(cacheNode(key,value));        _cache.insert(std::make_pair(key,_nodes.begin()));    &#125;&#125;void test0()&#123;        LRU lru(2);    lru.put(1,88);    cout &lt;&lt; &quot;get(1)&quot; &lt;&lt; lru.get(1) &lt;&lt; endl;    lru.put(3,99);    lru.put(4,77);    cout &lt;&lt; &quot;get(1)&quot; &lt;&lt; lru.get(1) &lt;&lt; endl;&#125;int main(void)&#123;    test0();    return 0;&#125;\n\n","tags":["ç®—æ³•"]},{"title":"Ceph-RBDæºç é˜…è¯»","url":"/2025/10/13/Ceph-RBD%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","content":"\nRBD æ˜¯ Ceph åˆ†å¸ƒå¼å­˜å‚¨ç³»ç»Ÿä¸­æä¾›çš„å—å­˜å‚¨æœåŠ¡\nè¯¥ç¯‡ä¸»è¦é’ˆå¯¹ RBD ä¸­çš„æ•´ä½“æ¶æ„ä»¥åŠ IO æµç¨‹è¿›è¡Œä»‹ç»\né’ˆå¯¹ librbd ä¸­æä¾›çš„æ¥å£è¿›è¡Œç®€å•ä»‹ç»ï¼Œåç»­å°†åœ¨æ­¤åŸºç¡€ä¸Šè¿›è¡Œå®æˆ˜\n\nCeph RBD\nRBDï¼šRADOS Block Devices. Ceph block devices are thin-provisioned, resizable and store data striped over multiple OSDs in a Ceph cluster.\n\n\n\næ•´ä½“ä»‹ç»\nCeph RBD æ¨¡å—ä¸»è¦æä¾›äº†ä¸¤ç§å¯¹å¤–æ¥å£ï¼š\n\nä¸€ç§æ˜¯åŸºäº librados çš„ç”¨æˆ·æ€æ¥å£åº“ librbdï¼Œæ”¯æŒ C&#x2F;C++ æ¥å£ä»¥åŠ Python ç­‰é«˜çº§è¯­è¨€çš„ç»‘å®šï¼›\nå¦å¤–ä¸€ç§æ˜¯é€šè¿‡ kernel Module çš„æ–¹å¼ï¼ˆä¸€ä¸ªå« krbd çš„å†…æ ¸æ¨¡å—ï¼‰ï¼Œé€šè¿‡ç”¨æˆ·æ€çš„ rbd å‘½ä»¤è¡Œå·¥å…·ï¼Œå°† RBD å—è®¾å¤‡æ˜ å°„ä¸ºæœ¬åœ°çš„ä¸€ä¸ªå—è®¾å¤‡æ–‡ä»¶ã€‚\n\n\n\n\n\nRDB çš„å—è®¾å¤‡ç”±äºå…ƒæ•°æ®ä¿¡æ¯å°‘è€Œä¸”è®¿é—®ä¸é¢‘ç¹ï¼Œæ•… RBD åœ¨ Ceph é›†ç¾¤ä¸­ä¸éœ€è¦å•ç‹¬çš„å®ˆæŠ¤è¿›ç¨‹è®²å…ƒæ•°æ®åŠ è½½åˆ°å†…å­˜è¿›è¡Œå…ƒæ•°æ®è®¿é—®åŠ é€Ÿï¼Œæ‰€æœ‰çš„å…ƒæ•°æ®å’Œæ•°æ®æ“ä½œç›´æ¥ä¸é›†ç¾¤ä¸­çš„ Monitor æœåŠ¡å’Œ OSD æœåŠ¡è¿›è¡Œäº¤äº’ã€‚\n\nRBD IO æµ\n\nRBD æ¨¡å— IO æµå›¾\n\n\nå‡ ä¸ªé‡è¦çš„å­˜å‚¨ç»„ç»‡\nPoolï¼šå­˜å‚¨èµ„æºæ± ã€‚IO ä¹‹å‰ï¼Œéœ€è¦å…ˆåˆ›å»ºä¸€ä¸ªå­˜å‚¨æ± ï¼Œå­˜å‚¨æ± ç»Ÿä¸€åœ°å¯¹é€»è¾‘å­˜å‚¨å•å…ƒè¿›è¡Œç®¡ç†ï¼Œå¹¶å¯¹å…¶è¿›è¡Œåˆå§‹åŒ–ã€‚åŒæ—¶æŒ‡å®šä¸€ä¸ª Pool ä¸­çš„ PG æ•°é‡ã€‚æ˜¯ Ceph å­˜å‚¨æ•°æ®æ—¶çš„é€»è¾‘åˆ†åŒºï¼Œç±»ä¼¼äº HDFS ä¸­çš„ namespace\n\nceph osd pool create rbd 32rbd pool init rbd\n\n\nRBDï¼šå—è®¾å¤‡é•œåƒã€‚åœ¨åˆ›å»ºå¥½ Pool çš„åŸºç¡€ä¹‹ä¸Šï¼Œå¯¹åº”çš„åˆ›å»ºå—è®¾å¤‡é•œåƒå¹¶å’Œå­˜å‚¨æ± è¿›è¡Œæ˜ å°„ç»‘å®š\n\nObjectï¼šæŒ‰ç…§æ•°æ®åˆ‡ç‰‡çš„å¤§å°ï¼Œå°†æ‰€æœ‰æ•°æ®åˆ‡ç‰‡ä¸ºä¸€ä¸ªä¸ªå¯¹è±¡ï¼Œè¿›è¡Œç›¸åº”çš„å¯¹è±¡å­˜å‚¨æ“ä½œã€‚å…¶ä¸­ Key éœ€è¦æ ¹æ®åºå·è¿›è¡Œç”Ÿæˆä»è€Œè¿›è¡ŒåŒºåˆ†ã€‚\n\n\nrbd create --size &#123;megabytes&#125; &#123;pool-name&#125;/&#123;image-name&#125;rbd create --size 1024 swimmingpool/bar\n\n\nPGï¼šPlacement Groupï¼Œç”¨äºæ”¾ç½®æ ‡å‡†å¤§å°çš„ Object çš„è½½ä½“ã€‚å…¶æ•°é‡çš„è®¡ç®—å…¬å¼ï¼šTotal PGs = (Total_number_of_OSD * 100) / max_replication_count å†å¯¹ç»“æœå‘ä¸Šå– 2 çš„ N æ¬¡æ–¹ä½œä¸ºæœ€ç»ˆçš„æ•°é‡ã€‚PG åŒæ—¶ä½œä¸ºæ•°æ®å‡è¡¡å’Œè¿ç§»çš„æœ€å°å•ä½ï¼ŒPG ä¹Ÿæœ‰ç›¸åº”çš„ä¸»ä»ä¹‹åˆ†ã€‚\nOSDï¼šOSD æ˜¯è´Ÿè´£ç‰©ç†å­˜å‚¨çš„è¿›ç¨‹ï¼Œä¹Ÿå¯ä»¥ç†è§£ä¸ºæœ€ç»ˆçš„å¯¹è±¡å­˜å‚¨èŠ‚ç‚¹ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä¸€å—ç£ç›˜å¯åŠ¨ä¸€ä¸ª OSD è¿›ç¨‹ï¼Œä¸€ç»„ PG ï¼ˆå¤šå‰¯æœ¬ï¼‰åˆ†å¸ƒåœ¨ä¸åŒçš„ OSD ä¸Šã€‚\n\nIOæµç¨‹\nå®¢æˆ·ç«¯åˆ›å»ºå¯¹åº”çš„å­˜å‚¨æ±  Poolï¼ŒæŒ‡å®šç›¸åº”çš„ PG ä¸ªæ•°ä»¥åŠ PGP ä¸ªæ•°ï¼ˆç”¨äº PG ä¸­çš„æ•°æ®å‡è¡¡ï¼‰\nåˆ›å»º pool&#x2F;image rbdè®¾å¤‡è¿›è¡ŒæŒ‚è½½\nç”¨æˆ·å†™å…¥çš„æ•°æ®è¿›è¡Œåˆ‡å—ï¼Œæ¯ä¸ªå—æœ‰é»˜è®¤å¤§å°ï¼Œå¹¶ä¸”æ¯ä¸ªå—éƒ½æœ‰ä¸€ä¸ª Keyï¼ŒKey å°±æ˜¯ object+åºå·\nå°†æ¯ä¸ª object é€šè¿‡ pg è¿›è¡Œå‰¯æœ¬ä½ç½®çš„åˆ†é…\nPG æ ¹æ® cursh ç®—æ³•ä¼šå¯»æ‰¾æŒ‡å®šä¸ªæ•°çš„ osdï¼ˆä¸»ä»ä¸ªæ•°ï¼‰ï¼ŒæŠŠè¿™ä¸ª object åˆ†åˆ«ä¿å­˜åœ¨è¿™äº› osd ä¸Š\nosd ä¸Šå®é™…æ˜¯æŠŠåº•å±‚çš„ disk è¿›è¡Œäº†æ ¼å¼åŒ–æ“ä½œï¼Œä¸€èˆ¬éƒ¨ç½²å·¥å…·ä¼šå°†å®ƒæ ¼å¼åŒ–ä¸º xfs æ–‡ä»¶ç³»ç»Ÿ\nobject çš„å­˜å‚¨å°±å˜æˆäº†å­˜å‚¨ä¸€ä¸ªæ–‡ä»¶ rbd0.object1.file\n\nRBD IO æ¡†æ¶\nå®¢æˆ·ç«¯å†™æ•°æ®osdè¿‡ç¨‹ï¼š\né‡‡ç”¨çš„æ˜¯ librbd çš„å½¢å¼ï¼Œä½¿ç”¨ librbd åˆ›å»ºä¸€ä¸ªå—è®¾å¤‡ï¼Œå‘è¿™ä¸ªå—è®¾å¤‡ä¸­å†™å…¥æ•°æ®\nåœ¨å®¢æˆ·ç«¯æœ¬åœ°åŒè¿‡è°ƒç”¨ librados æ¥å£ï¼Œç„¶åç»è¿‡ poolï¼Œrbdï¼Œobjectï¼Œpg è¿›è¡Œå±‚å±‚æ˜ å°„ï¼ˆCRUSH ç®—æ³•ï¼‰,åœ¨ PG è¿™ä¸€å±‚ä¸­ï¼Œå¯ä»¥çŸ¥é“æ•°æ®ä¿å­˜åœ¨å“ªå‡ ä¸ª OSD ä¸Šï¼Œè¿™å‡ ä¸ª OSD åˆ†ä¸ºä¸»ä»çš„å…³ç³»\nå®¢æˆ·ç«¯ä¸ primary OSD å»ºç«‹ SOCKET é€šä¿¡ï¼Œå°†è¦å†™å…¥çš„æ•°æ®ä¼ ç»™ primary OSDï¼Œç”± primary OSD å†å°†æ•°æ®å‘é€ç»™å…¶ä»– replica OSD æ•°æ®èŠ‚ç‚¹ã€‚\n\nlibrbd\nlibrbd åˆ° OSD çš„æ•°æ®æµå‘å¦‚ä¸‹ï¼š\n\n\næ¨¡å—ä»‹ç»\nlibrbdï¼šLibrbd æ˜¯Cephæä¾›çš„å—å­˜å‚¨æ¥å£çš„æŠ½è±¡ï¼Œå®ƒæä¾›C&#x2F;C++ã€Pythonç­‰å¤šç§æ¥å£ã€‚å¯¹äºC++ï¼Œæœ€ä¸»è¦çš„ä¸¤ä¸ªç±»å°±æ˜¯RBD å’Œ Imageã€‚ RBD ä¸»è¦è´Ÿè´£åˆ›å»ºã€åˆ é™¤ã€å…‹éš†æ˜ åƒç­‰æ“ä½œï¼Œè€ŒImage ç±»è´Ÿè´£æ˜ åƒçš„è¯»å†™ç­‰æ“ä½œã€‚\ncls_rbdï¼šcls_rbdæ˜¯Clsçš„ä¸€ä¸ªæ‰©å±•æ¨¡å—ï¼ŒClså…è®¸ç”¨æˆ·è‡ªå®šä¹‰å¯¹è±¡çš„æ“ä½œæ¥å£å’Œå®ç°æ–¹æ³•ï¼Œä¸ºç”¨æˆ·æä¾›äº†ä¸€ç§æ¯”è¾ƒç›´æ¥çš„æ¥å£æ‰©å±•æ–¹å¼ã€‚é€šè¿‡åŠ¨æ€é“¾æ¥çš„å½¢å¼åŠ å…¥ osd ä¸­ï¼Œåœ¨ osd ä¸Šç›´æ¥æ‰§è¡Œã€‚\nlibradosï¼šlibrados æä¾›å®¢æˆ·ç«¯è®¿é—® Ceph é›†ç¾¤çš„åŸç”Ÿæ€ç»Ÿä¸€æ¥å£ã€‚å…¶å®ƒæ¥å£æˆ–è€…å‘½ä»¤è¡Œå·¥å…·éƒ½åŸºäºè¯¥åŠ¨æ€åº“å®ç°ã€‚åœ¨ librados ä¸­å®ç°äº† Crush ç®—æ³•å’Œç½‘ç»œé€šä¿¡ç­‰å…¬å…±åŠŸèƒ½ï¼Œæ•°æ®è¯·æ±‚æ“ä½œåœ¨ librados è®¡ç®—å®Œæˆåå¯ä»¥ç›´æ¥ä¸å¯¹åº”çš„ OSD äº¤äº’è¿›è¡Œæ•°æ®ä¼ è¾“ã€‚\nOSDCï¼šè¯¥æ¨¡å—æ˜¯å®¢æˆ·ç«¯æ¨¡å—æ¯”è¾ƒåº•å±‚çš„æ¨¡å—ï¼Œç”¨äºå°è£…æ“ä½œæ•°æ®ï¼Œè®¡ç®—å¯¹è±¡çš„åœ°å€ã€å‘é€è¯·æ±‚å’Œå¤„ç†è¶…æ—¶ã€‚\nOSDï¼šéƒ¨ç½²åœ¨æ¯ä¸€ä¸ªç¡¬ç›˜ä¸Šçš„ OSD è¿›ç¨‹ï¼Œä¸»è¦åŠŸèƒ½æ˜¯å­˜å‚¨æ•°æ®ã€å¤åˆ¶æ•°æ®ã€å¹³è¡¡æ•°æ®ã€æ¢å¤æ•°æ®ç­‰ï¼Œä¸å…¶å®ƒOSDé—´è¿›è¡Œå¿ƒè·³æ£€æŸ¥ç­‰ï¼Œå¹¶å°†ä¸€äº›å˜åŒ–æƒ…å†µä¸ŠæŠ¥ç»™Ceph Monitor\nOSï¼šæ“ä½œç³»ç»Ÿï¼Œåœ¨æ­¤å¤„åˆ™ä¸»è¦æ˜¯ OSD çš„ IO è¯·æ±‚ä¸‹å‘åˆ°å¯¹åº”çš„ç¡¬ç›˜ä¸Šçš„æ–‡ä»¶ç³»ç»Ÿï¼Œç”±æ–‡ä»¶ç³»ç»Ÿæ¥å®Œæˆåç»­çš„ IO æ“ä½œã€‚\n\nlibrbd è¯¦ç»†ä»‹ç»åŠŸèƒ½æ¨¡å—\næ ¸å¿ƒæœºåˆ¶\nlibrbd æ˜¯ä¸€ä¸ªå°† block io ï¼ˆ[off, len]ï¼‰è½¬æ¢æˆ rados object io ï¼ˆ[oid, off, len]ï¼‰çš„ä¸­é—´å±‚ã€‚ä¸ºäº†æ”¯æŒé«˜æ€§èƒ½ io å¤„ç†ï¼Œå…¶å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ª io é˜Ÿåˆ—ï¼Œä¸€ä¸ªå¼‚æ­¥å›è°ƒé˜Ÿåˆ—ï¼Œä»¥åŠå¯¹è¿™ä¸¤ä¸ªé˜Ÿåˆ—ä¸­çš„è¯·æ±‚è¿›è¡Œå¤„ç†çš„çº¿ç¨‹æ± ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚\n\n\n\nIO æ—¶åºå›¾\n\n\n\nlibrbd æä¾›äº†é’ˆå¯¹ image çš„æ•°æ®è¯»å†™å’Œç®¡ç†æ“ä½œä¸¤ç§è®¿é—®æ¥å£ï¼Œå…¶ä¸­æ•°æ®è¯»å†™è¯·æ±‚å…¥ io_work_queueï¼Œç„¶åç”±çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹å°† io è¯·æ±‚ä»¥ object ç²’åº¦åˆ‡åˆ†å¹¶åˆ†åˆ«è°ƒç”¨ rados å±‚çš„ aio æ¥å£ï¼ˆIoCtxImplï¼‰ä¸‹å‘ï¼Œå½“æ‰€æœ‰çš„ object è¯·æ±‚å®Œæˆæ—¶ï¼Œè°ƒç”¨ librbd io å›è°ƒï¼ˆlibrbd::io::AioCompletionï¼‰å®Œæˆç”¨æˆ·å±‚çš„æ•°æ® ioã€‚è€Œå¯¹ image çš„ç®¡ç†æ“ä½œé€šå¸¸éœ€è¦æ¶‰åŠå•ä¸ªæˆ–å¤šä¸ªå¯¹è±¡çš„å¤šæ¬¡è®¿é—®ä»¥åŠå¯¹å†…éƒ¨çŠ¶æ€çš„å¤šæ¬¡æ›´æ–°ï¼Œå…¶ç¬¬ä¸€æ¬¡è®¿é—®å°†ä»ç”¨æˆ·çº¿ç¨‹è°ƒç”¨è‡³ rados å±‚ aio æ¥å£æˆ–æ›´æ–°çŠ¶æ€åå…¥ op_work_queue é˜Ÿåˆ—è¿›è¡Œå¼‚æ­¥è°ƒç”¨ï¼Œå½“ rados aio å±‚å›è°ƒæˆ– Context å®Œæˆæ—¶å†æ ¹æ®å®ç°é€»è¾‘è°ƒç”¨æ–°çš„ rados aio æˆ–æ„é€  Context å›è°ƒï¼Œå¦‚æ­¤åå¤ï¼Œæœ€åè°ƒç”¨åº”ç”¨å±‚çš„å›è°ƒå®Œæˆç®¡ç†æ“ä½œè¯·æ±‚ã€‚\n\næ­¤å¤–ä¸ºäº†æ”¯æŒå¤šå®¢æˆ·ç«¯å…±äº«è®¿é—® imageï¼Œlibrbd æä¾›äº†æ„å»ºäº rados watch&#x2F;notify ä¹‹ä¸Šçš„é€šçŸ¥ã€è¿œç¨‹æ‰§è¡Œä»¥åŠ exclusive lock åˆ†å¸ƒå¼é”æœºåˆ¶ã€‚æ¯ä¸ª librbd å®¢æˆ·ç«¯åœ¨æ‰“å¼€ image æ—¶ï¼ˆä»¥éåªè¯»æ–¹å¼æ‰“å¼€ï¼‰éƒ½ä¼š watch image çš„ header å¯¹è±¡ï¼Œä»è¿œç¨‹å‘å¾€æœ¬åœ°å®¢æˆ·ç«¯çš„é€šçŸ¥æ¶ˆæ¯æˆ–è€…å†…éƒ¨çš„ watch é”™è¯¯æ¶ˆæ¯ä¼šé€šè¿‡ RadosClient çš„ Finisher çº¿ç¨‹å…¥ op_work_queue é˜Ÿåˆ—è¿›è¡Œå¼‚æ­¥å¤„ç†ã€‚\n\n\nç»„æˆå…ƒç´ \nimage ä¸»è¦ç”± rbd_header å…ƒæ•°æ® rados å¯¹è±¡åŠ rbd_data æ•°æ® rados å¯¹è±¡ç»„æˆï¼Œéšç€ç‰¹æ€§çš„å¢åŠ ä¼šå¢åŠ å…¶å®ƒä¸€äº›å…ƒæ•°æ®å¯¹è±¡ï¼Œä½† librbd å†…éƒ¨çš„è¿è¡Œæœºåˆ¶å¹¶ä¸ä¼šæœ‰å¤§çš„å˜åŒ–ï¼Œä¸€åˆ‡éƒ½ä»¥å¼‚æ­¥ ioã€äº‹ä»¶ï¼ˆè¯·æ±‚ï¼‰é©±åŠ¨ä¸ºåŸºç¡€ã€‚\n\nç›¸å…³æ¥å£å£°æ˜\næ­¤å¤„ä»¥ librbd çš„ C++ åº“ librbd.hpp ä¸ºä¾‹å¯¹ librbd æä¾›çš„ç›¸å…³åŠŸèƒ½ API è¿›è¡Œä»‹ç»ï¼ˆé™¤æ­¤ä»¥å¤–è¿˜æä¾›äº† C è¯­è¨€çš„ç›¸å…³åº“ librbd.hï¼‰\nlibrbd æä¾›çš„æ¥å£å¯¼å›¾å¦‚ä¸‹ï¼š\n\n\nnamespace librbd &#123; // åº“åœ¨librbdåå­—ç©ºé—´ä¸­  using librados::IoCtx; // librados åº“å¯¹å¤–æä¾›çš„æ¥å£  class Image;  class ImageOptions;  class PoolStats;  typedef void *image_ctx_t;  typedef void *completion_t;  typedef void (*callback_t)(completion_t cb, void *arg); // å¼‚æ­¥æ“ä½œå›è°ƒæ¥å£  ...class CEPH_RBD_API RBD&#123;public:  RBD();  ~RBD();  // This must be dynamically allocated with new, and  // must be released with release().  // Do not use delete.  struct AioCompletion &#123;    void *pc;    AioCompletion(void *cb_arg, callback_t complete_cb);    bool is_complete();    int wait_for_complete();    ssize_t get_return_value();    void release();  &#125;;  // æ¥ä¸‹æ¥ä¸€äº›API: open/create/clone/remove/rename/list/migration ç­‰  // RBD groups support functions  create/remove/list/renameprivate:  /* We don&#x27;t allow assignment or copying */  RBD(const RBD&amp; rhs);  const RBD&amp; operator=(const RBD&amp; rhs);&#125;;// Image å‚æ•°è®¾ç½®class CEPH_RBD_API ImageOptions &#123;public:  ImageOptions();  ImageOptions(rbd_image_options_t opts);  ImageOptions(const ImageOptions &amp;imgopts);  ~ImageOptions();  int set(int optname, const std::string&amp; optval);  int set(int optname, uint64_t optval);  int get(int optname, std::string* optval) const;  int get(int optname, uint64_t* optval) const;  int is_set(int optname, bool* is_set);  int unset(int optname);  void clear();  bool empty() const;private:  friend class RBD;  friend class Image;  rbd_image_options_t opts;&#125;;// å­˜å‚¨æ±  Pool çŠ¶æ€class CEPH_RBD_API PoolStats &#123;public:  PoolStats();  ~PoolStats();  PoolStats(const PoolStats&amp;) = delete;  PoolStats&amp; operator=(const PoolStats&amp;) = delete;  int add(rbd_pool_stat_option_t option, uint64_t* opt_val);private:  friend class RBD;  rbd_pool_stats_t pool_stats;&#125;;class CEPH_RBD_API UpdateWatchCtx &#123;public:  virtual ~UpdateWatchCtx() &#123;&#125;  /**   * Callback activated when we receive a notify event.   */  virtual void handle_notify() = 0;&#125;;class CEPH_RBD_API Image&#123;public:  Image();  ~Image();  // é•œåƒçš„è¯»å†™ï¼Œflattenï¼Œtrimç­‰æ“ä½œprivate:  friend class RBD;  Image(const Image&amp; rhs);  const Image&amp; operator=(const Image&amp; rhs);  image_ctx_t ctx; // viod*, å®é™…æŒ‡å‘å…·ä½“å®ç°çš„ç±»&#125;;&#125;\n\nclass CEPH_RBD_API RBD\nRBD ä¸»è¦è´Ÿè´£ Image çš„åˆ›å»ºã€åˆ é™¤ã€é‡å‘½åã€å…‹éš†æ˜ åƒç­‰æ“ä½œï¼ŒåŒ…æ‹¬å¯¹å­˜å‚¨æ± çš„å…ƒæ•°æ®çš„ç®¡ç†\né’ˆå¯¹éƒ¨åˆ†æ“ä½œæä¾›å¼‚æ­¥æ¥å£\n\nclass CEPH_RBD_API RBD&#123;public:  RBD();  ~RBD();  // This must be dynamically allocated with new, and  // must be released with release().  // Do not use delete.  struct AioCompletion &#123;    void *pc;    AioCompletion(void *cb_arg, callback_t complete_cb);    bool is_complete();    int wait_for_complete();    ssize_t get_return_value();    void *get_arg();    void release();  &#125;;  void version(int *major, int *minor, int *extra);  int open(IoCtx&amp; io_ctx, Image&amp; image, const char *name);  int open(IoCtx&amp; io_ctx, Image&amp; image, const char *name, const char *snapname);  int open_by_id(IoCtx&amp; io_ctx, Image&amp; image, const char *id);  int open_by_id(IoCtx&amp; io_ctx, Image&amp; image, const char *id, const char *snapname);  int aio_open(IoCtx&amp; io_ctx, Image&amp; image, const char *name,\t       const char *snapname, RBD::AioCompletion *c);  int aio_open_by_id(IoCtx&amp; io_ctx, Image&amp; image, const char *id,\t             const char *snapname, RBD::AioCompletion *c);  // see librbd.h  int open_read_only(IoCtx&amp; io_ctx, Image&amp; image, const char *name,\t\t     const char *snapname);  int open_by_id_read_only(IoCtx&amp; io_ctx, Image&amp; image, const char *id,                           const char *snapname);  int aio_open_read_only(IoCtx&amp; io_ctx, Image&amp; image, const char *name,\t\t\t const char *snapname, RBD::AioCompletion *c);  int aio_open_by_id_read_only(IoCtx&amp; io_ctx, Image&amp; image, const char *id,                               const char *snapname, RBD::AioCompletion *c);  int list(IoCtx&amp; io_ctx, std::vector&lt;std::string&gt;&amp; names)    __attribute__((deprecated));  int list2(IoCtx&amp; io_ctx, std::vector&lt;image_spec_t&gt;* images);  int create(IoCtx&amp; io_ctx, const char *name, uint64_t size, int *order);  int create2(IoCtx&amp; io_ctx, const char *name, uint64_t size,\t      uint64_t features, int *order);  int create3(IoCtx&amp; io_ctx, const char *name, uint64_t size,\t      uint64_t features, int *order,\t      uint64_t stripe_unit, uint64_t stripe_count);  int create4(IoCtx&amp; io_ctx, const char *name, uint64_t size,\t      ImageOptions&amp; opts);  int clone(IoCtx&amp; p_ioctx, const char *p_name, const char *p_snapname,\t       IoCtx&amp; c_ioctx, const char *c_name, uint64_t features,\t       int *c_order);  int clone2(IoCtx&amp; p_ioctx, const char *p_name, const char *p_snapname,\t     IoCtx&amp; c_ioctx, const char *c_name, uint64_t features,\t     int *c_order, uint64_t stripe_unit, int stripe_count);  int clone3(IoCtx&amp; p_ioctx, const char *p_name, const char *p_snapname,\t     IoCtx&amp; c_ioctx, const char *c_name, ImageOptions&amp; opts);  int remove(IoCtx&amp; io_ctx, const char *name);  int remove_with_progress(IoCtx&amp; io_ctx, const char *name, ProgressContext&amp; pctx);  int rename(IoCtx&amp; src_io_ctx, const char *srcname, const char *destname);  int trash_move(IoCtx &amp;io_ctx, const char *name, uint64_t delay);  int trash_get(IoCtx &amp;io_ctx, const char *id, trash_image_info_t *info);  int trash_list(IoCtx &amp;io_ctx, std::vector&lt;trash_image_info_t&gt; &amp;entries);  int trash_purge(IoCtx &amp;io_ctx, time_t expire_ts, float threshold);  int trash_purge_with_progress(IoCtx &amp;io_ctx, time_t expire_ts, float threshold,                                ProgressContext &amp;pctx);  int trash_remove(IoCtx &amp;io_ctx, const char *image_id, bool force);  int trash_remove_with_progress(IoCtx &amp;io_ctx, const char *image_id,                                 bool force, ProgressContext &amp;pctx);  int trash_restore(IoCtx &amp;io_ctx, const char *id, const char *name);  // Migration  int migration_prepare(IoCtx&amp; io_ctx, const char *image_name,                        IoCtx&amp; dest_io_ctx, const char *dest_image_name,                        ImageOptions&amp; opts);  int migration_execute(IoCtx&amp; io_ctx, const char *image_name);  int migration_execute_with_progress(IoCtx&amp; io_ctx, const char *image_name,                                      ProgressContext &amp;prog_ctx);  int migration_abort(IoCtx&amp; io_ctx, const char *image_name);  int migration_abort_with_progress(IoCtx&amp; io_ctx, const char *image_name,                                    ProgressContext &amp;prog_ctx);  int migration_commit(IoCtx&amp; io_ctx, const char *image_name);  int migration_commit_with_progress(IoCtx&amp; io_ctx, const char *image_name,                                     ProgressContext &amp;prog_ctx);  int migration_status(IoCtx&amp; io_ctx, const char *image_name,                       image_migration_status_t *status, size_t status_size);  // RBD pool mirroring support functions  int mirror_mode_get(IoCtx&amp; io_ctx, rbd_mirror_mode_t *mirror_mode);  int mirror_mode_set(IoCtx&amp; io_ctx, rbd_mirror_mode_t mirror_mode);  int mirror_peer_add(IoCtx&amp; io_ctx, std::string *uuid,                      const std::string &amp;cluster_name,                      const std::string &amp;client_name);  int mirror_peer_remove(IoCtx&amp; io_ctx, const std::string &amp;uuid);  int mirror_peer_list(IoCtx&amp; io_ctx, std::vector&lt;mirror_peer_t&gt; *peers);  int mirror_peer_set_client(IoCtx&amp; io_ctx, const std::string &amp;uuid,                             const std::string &amp;client_name);  int mirror_peer_set_cluster(IoCtx&amp; io_ctx, const std::string &amp;uuid,                              const std::string &amp;cluster_name);  int mirror_peer_get_attributes(      IoCtx&amp; io_ctx, const std::string &amp;uuid,      std::map&lt;std::string, std::string&gt; *key_vals);  int mirror_peer_set_attributes(      IoCtx&amp; io_ctx, const std::string &amp;uuid,      const std::map&lt;std::string, std::string&gt;&amp; key_vals);  int mirror_image_status_list(IoCtx&amp; io_ctx, const std::string &amp;start_id,      size_t max, std::map&lt;std::string, mirror_image_status_t&gt; *images);  int mirror_image_status_summary(IoCtx&amp; io_ctx,      std::map&lt;mirror_image_status_state_t, int&gt; *states);  int mirror_image_instance_id_list(IoCtx&amp; io_ctx, const std::string &amp;start_id,      size_t max, std::map&lt;std::string, std::string&gt; *sevice_ids);  // RBD groups support functions  int group_create(IoCtx&amp; io_ctx, const char *group_name);  int group_remove(IoCtx&amp; io_ctx, const char *group_name);  int group_list(IoCtx&amp; io_ctx, std::vector&lt;std::string&gt; *names);  int group_rename(IoCtx&amp; io_ctx, const char *src_group_name,                   const char *dest_group_name);  int group_image_add(IoCtx&amp; io_ctx, const char *group_name,\t\t      IoCtx&amp; image_io_ctx, const char *image_name);  int group_image_remove(IoCtx&amp; io_ctx, const char *group_name,\t\t\t IoCtx&amp; image_io_ctx, const char *image_name);  int group_image_remove_by_id(IoCtx&amp; io_ctx, const char *group_name,                               IoCtx&amp; image_io_ctx, const char *image_id);  int group_image_list(IoCtx&amp; io_ctx, const char *group_name,                       std::vector&lt;group_image_info_t&gt; *images,                       size_t group_image_info_size);  int group_snap_create(IoCtx&amp; io_ctx, const char *group_name,\t\t\tconst char *snap_name);  int group_snap_remove(IoCtx&amp; io_ctx, const char *group_name,\t\t\tconst char *snap_name);  int group_snap_rename(IoCtx&amp; group_ioctx, const char *group_name,                        const char *old_snap_name, const char *new_snap_name);  int group_snap_list(IoCtx&amp; group_ioctx, const char *group_name,                      std::vector&lt;group_snap_info_t&gt; *snaps,                      size_t group_snap_info_size);  int group_snap_rollback(IoCtx&amp; io_ctx, const char *group_name,                          const char *snap_name);  int group_snap_rollback_with_progress(IoCtx&amp; io_ctx, const char *group_name,                                        const char *snap_name,                                        ProgressContext&amp; pctx);  int namespace_create(IoCtx&amp; ioctx, const char *namespace_name);  int namespace_remove(IoCtx&amp; ioctx, const char *namespace_name);  int namespace_list(IoCtx&amp; io_ctx, std::vector&lt;std::string&gt;* namespace_names);  int namespace_exists(IoCtx&amp; io_ctx, const char *namespace_name, bool *exists);  int pool_init(IoCtx&amp; io_ctx, bool force);  int pool_stats_get(IoCtx&amp; io_ctx, PoolStats *pool_stats);  int pool_metadata_get(IoCtx &amp;io_ctx, const std::string &amp;key,                        std::string *value);  int pool_metadata_set(IoCtx &amp;io_ctx, const std::string &amp;key,                        const std::string &amp;value);  int pool_metadata_remove(IoCtx &amp;io_ctx, const std::string &amp;key);  int pool_metadata_list(IoCtx &amp;io_ctx, const std::string &amp;start, uint64_t max,                         std::map&lt;std::string, ceph::bufferlist&gt; *pairs);  int config_list(IoCtx&amp; io_ctx, std::vector&lt;config_option_t&gt; *options);private:  /* We don&#x27;t allow assignment or copying */  RBD(const RBD&amp; rhs);  const RBD&amp; operator=(const RBD&amp; rhs);&#125;;\n\nclass CEPH_RBD_API Image\nImage ç±»è´Ÿè´£é•œåƒçš„è¯»å†™(read&#x2F;write)ï¼Œä»¥åŠå¿«ç…§ç›¸å…³çš„æ“ä½œç­‰ç­‰ã€‚\nåŒæ—¶æä¾›äº†ç›¸å…³å¼‚æ­¥æ“ä½œçš„æ¥å£ã€‚\n\nclass CEPH_RBD_API Image&#123;public:  Image();  ~Image();  // é•œåƒçš„è¯»å†™ï¼Œresize, flush, flattenï¼Œtrimç­‰æ“ä½œ  int close();  int aio_close(RBD::AioCompletion *c);  int resize(uint64_t size);  int resize2(uint64_t size, bool allow_shrink, ProgressContext&amp; pctx);  int resize_with_progress(uint64_t size, ProgressContext&amp; pctx);  int stat(image_info_t &amp;info, size_t infosize);  int get_name(std::string *name);  int get_id(std::string *id);  std::string get_block_name_prefix();  int64_t get_data_pool_id();  int parent_info(std::string *parent_poolname, std::string *parent_name,\t\t  std::string *parent_snapname)      __attribute__((deprecated));  int parent_info2(std::string *parent_poolname, std::string *parent_name,                   std::string *parent_id, std::string *parent_snapname)      __attribute__((deprecated));  int get_parent(linked_image_spec_t *parent_image, snap_spec_t *parent_snap);  int old_format(uint8_t *old);  int size(uint64_t *size);  int get_group(group_info_t *group_info, size_t group_info_size);  int features(uint64_t *features);  int update_features(uint64_t features, bool enabled);  int get_op_features(uint64_t *op_features);  int overlap(uint64_t *overlap);  int get_flags(uint64_t *flags);  int set_image_notification(int fd, int type);  /* exclusive lock feature */  int is_exclusive_lock_owner(bool *is_owner);  int lock_acquire(rbd_lock_mode_t lock_mode);  int lock_release();  int lock_get_owners(rbd_lock_mode_t *lock_mode,                      std::list&lt;std::string&gt; *lock_owners);  int lock_break(rbd_lock_mode_t lock_mode, const std::string &amp;lock_owner);  /* object map feature */  int rebuild_object_map(ProgressContext &amp;prog_ctx);  int check_object_map(ProgressContext &amp;prog_ctx);  int copy(IoCtx&amp; dest_io_ctx, const char *destname);  int copy2(Image&amp; dest);  int copy3(IoCtx&amp; dest_io_ctx, const char *destname, ImageOptions&amp; opts);  int copy4(IoCtx&amp; dest_io_ctx, const char *destname, ImageOptions&amp; opts,\t    size_t sparse_size);  int copy_with_progress(IoCtx&amp; dest_io_ctx, const char *destname,\t\t\t ProgressContext &amp;prog_ctx);  int copy_with_progress2(Image&amp; dest, ProgressContext &amp;prog_ctx);  int copy_with_progress3(IoCtx&amp; dest_io_ctx, const char *destname,\t\t\t  ImageOptions&amp; opts, ProgressContext &amp;prog_ctx);  int copy_with_progress4(IoCtx&amp; dest_io_ctx, const char *destname,\t\t\t  ImageOptions&amp; opts, ProgressContext &amp;prog_ctx,\t\t\t  size_t sparse_size);  /* deep copy */  int deep_copy(IoCtx&amp; dest_io_ctx, const char *destname, ImageOptions&amp; opts);  int deep_copy_with_progress(IoCtx&amp; dest_io_ctx, const char *destname,                              ImageOptions&amp; opts, ProgressContext &amp;prog_ctx);  /* striping */  uint64_t get_stripe_unit() const;  uint64_t get_stripe_count() const;  int get_create_timestamp(struct timespec *timestamp);  int get_access_timestamp(struct timespec *timestamp);  int get_modify_timestamp(struct timespec *timestamp);  int flatten();  int flatten_with_progress(ProgressContext &amp;prog_ctx);  int sparsify(size_t sparse_size);  int sparsify_with_progress(size_t sparse_size, ProgressContext &amp;prog_ctx);  /**   * Returns a pair of poolname, imagename for each clone   * of this image at the currently set snapshot.   */  int list_children(std::set&lt;std::pair&lt;std::string, std::string&gt; &gt; *children)      __attribute__((deprecated));  /**  * Returns a structure of poolname, imagename, imageid and trash flag  * for each clone of this image at the currently set snapshot.  */  int list_children2(std::vector&lt;librbd::child_info_t&gt; *children)      __attribute__((deprecated));  int list_children3(std::vector&lt;linked_image_spec_t&gt; *images);  int list_descendants(std::vector&lt;linked_image_spec_t&gt; *images);  /* advisory locking (see librbd.h for details) */  int list_lockers(std::list&lt;locker_t&gt; *lockers,\t\t   bool *exclusive, std::string *tag);  int lock_exclusive(const std::string&amp; cookie);  int lock_shared(const std::string&amp; cookie, const std::string&amp; tag);  int unlock(const std::string&amp; cookie);  int break_lock(const std::string&amp; client, const std::string&amp; cookie);  /* snapshots */  int snap_list(std::vector&lt;snap_info_t&gt;&amp; snaps);  /* DEPRECATED; use snap_exists2 */  bool snap_exists(const char *snapname) __attribute__ ((deprecated));  int snap_exists2(const char *snapname, bool *exists);  int snap_create(const char *snapname);  int snap_remove(const char *snapname);  int snap_remove2(const char *snapname, uint32_t flags, ProgressContext&amp; pctx);  int snap_remove_by_id(uint64_t snap_id);  int snap_rollback(const char *snap_name);  int snap_rollback_with_progress(const char *snap_name, ProgressContext&amp; pctx);  int snap_protect(const char *snap_name);  int snap_unprotect(const char *snap_name);  int snap_is_protected(const char *snap_name, bool *is_protected);  int snap_set(const char *snap_name);  int snap_set_by_id(uint64_t snap_id);  int snap_rename(const char *srcname, const char *dstname);  int snap_get_limit(uint64_t *limit);  int snap_set_limit(uint64_t limit);  int snap_get_timestamp(uint64_t snap_id, struct timespec *timestamp);  int snap_get_namespace_type(uint64_t snap_id,                              snap_namespace_type_t *namespace_type);  int snap_get_group_namespace(uint64_t snap_id,                               snap_group_namespace_t *group_namespace,                               size_t snap_group_namespace_size);  int snap_get_trash_namespace(uint64_t snap_id, std::string* original_name);  /* I/O */  ssize_t read(uint64_t ofs, size_t len, ceph::bufferlist&amp; bl);  /* @param op_flags see librados.h constants beginning with LIBRADOS_OP_FLAG */  ssize_t read2(uint64_t ofs, size_t len, ceph::bufferlist&amp; bl, int op_flags);  int64_t read_iterate(uint64_t ofs, size_t len,\t\t       int (*cb)(uint64_t, size_t, const char *, void *), void *arg);  int read_iterate2(uint64_t ofs, uint64_t len,\t\t    int (*cb)(uint64_t, size_t, const char *, void *), void *arg);  /**   * get difference between two versions of an image   *   * This will return the differences between two versions of an image   * via a callback, which gets the offset and length and a flag   * indicating whether the extent exists (1), or is known/defined to   * be zeros (a hole, 0).  If the source snapshot name is NULL, we   * interpret that as the beginning of time and return all allocated   * regions of the image.  The end version is whatever is currently   * selected for the image handle (either a snapshot or the writeable   * head).   *   * @param fromsnapname start snapshot name, or NULL   * @param ofs start offset   * @param len len in bytes of region to report on   * @param include_parent true if full history diff should include parent   * @param whole_object 1 if diff extents should cover whole object   * @param cb callback to call for each allocated region   * @param arg argument to pass to the callback   * @returns 0 on success, or negative error code on error   */  int diff_iterate(const char *fromsnapname,\t\t   uint64_t ofs, uint64_t len,\t\t   int (*cb)(uint64_t, size_t, int, void *), void *arg);  int diff_iterate2(const char *fromsnapname,\t\t    uint64_t ofs, uint64_t len,                    bool include_parent, bool whole_object,\t\t    int (*cb)(uint64_t, size_t, int, void *), void *arg);  ssize_t write(uint64_t ofs, size_t len, ceph::bufferlist&amp; bl);  /* @param op_flags see librados.h constants beginning with LIBRADOS_OP_FLAG */  ssize_t write2(uint64_t ofs, size_t len, ceph::bufferlist&amp; bl, int op_flags);  int discard(uint64_t ofs, uint64_t len);  ssize_t writesame(uint64_t ofs, size_t len, ceph::bufferlist &amp;bl, int op_flags);  ssize_t compare_and_write(uint64_t ofs, size_t len, ceph::bufferlist &amp;cmp_bl,                            ceph::bufferlist&amp; bl, uint64_t *mismatch_off, int op_flags);  int aio_write(uint64_t off, size_t len, ceph::bufferlist&amp; bl, RBD::AioCompletion *c);  /* @param op_flags see librados.h constants beginning with LIBRADOS_OP_FLAG */  int aio_write2(uint64_t off, size_t len, ceph::bufferlist&amp; bl,\t\t  RBD::AioCompletion *c, int op_flags);  int aio_writesame(uint64_t off, size_t len, ceph::bufferlist&amp; bl,                    RBD::AioCompletion *c, int op_flags);  int aio_compare_and_write(uint64_t off, size_t len, ceph::bufferlist&amp; cmp_bl,                            ceph::bufferlist&amp; bl, RBD::AioCompletion *c,                            uint64_t *mismatch_off, int op_flags);  /**   * read async from image   *   * The target bufferlist is populated with references to buffers   * that contain the data for the given extent of the image.   *   * NOTE: If caching is enabled, the bufferlist will directly   * reference buffers in the cache to avoid an unnecessary data copy.   * As a result, if the user intends to modify the buffer contents   * directly, they should make a copy first (unconditionally, or when   * the reference count on ther underlying buffer is more than 1).   *   * @param off offset in image   * @param len length of read   * @param bl bufferlist to read into   * @param c aio completion to notify when read is complete   */  int aio_read(uint64_t off, size_t len, ceph::bufferlist&amp; bl, RBD::AioCompletion *c);  /* @param op_flags see librados.h constants beginning with LIBRADOS_OP_FLAG */  int aio_read2(uint64_t off, size_t len, ceph::bufferlist&amp; bl,\t\t  RBD::AioCompletion *c, int op_flags);  int aio_discard(uint64_t off, uint64_t len, RBD::AioCompletion *c);  int flush();  /**   * Start a flush if caching is enabled. Get a callback when   * the currently pending writes are on disk.   *   * @param image the image to flush writes to   * @param c what to call when flushing is complete   * @returns 0 on success, negative error code on failure   */  int aio_flush(RBD::AioCompletion *c);  /**   * Drop any cached data for this image   *   * @returns 0 on success, negative error code on failure   */  int invalidate_cache();  int poll_io_events(RBD::AioCompletion **comps, int numcomp);  int metadata_get(const std::string &amp;key, std::string *value);  int metadata_set(const std::string &amp;key, const std::string &amp;value);  int metadata_remove(const std::string &amp;key);  /**   * Returns a pair of key/value for this image   */  int metadata_list(const std::string &amp;start, uint64_t max, std::map&lt;std::string, ceph::bufferlist&gt; *pairs);  // RBD image mirroring support functions  int mirror_image_enable();  int mirror_image_disable(bool force);  int mirror_image_promote(bool force);  int mirror_image_demote();  int mirror_image_resync();  int mirror_image_get_info(mirror_image_info_t *mirror_image_info,                            size_t info_size);  int mirror_image_get_status(mirror_image_status_t *mirror_image_status,\t\t\t      size_t status_size);  int mirror_image_get_instance_id(std::string *instance_id);  int aio_mirror_image_promote(bool force, RBD::AioCompletion *c);  int aio_mirror_image_demote(RBD::AioCompletion *c);  int aio_mirror_image_get_info(mirror_image_info_t *mirror_image_info,                                size_t info_size, RBD::AioCompletion *c);  int aio_mirror_image_get_status(mirror_image_status_t *mirror_image_status,                                  size_t status_size, RBD::AioCompletion *c);  int update_watch(UpdateWatchCtx *ctx, uint64_t *handle);  int update_unwatch(uint64_t handle);  int list_watchers(std::list&lt;image_watcher_t&gt; &amp;watchers);  int config_list(std::vector&lt;config_option_t&gt; *options);private:  friend class RBD;  Image(const Image&amp; rhs);  const Image&amp; operator=(const Image&amp; rhs);  image_ctx_t ctx; // void*, å®é™…æŒ‡å‘å…·ä½“å®ç°çš„ç±»&#125;;\n\nå…·ä½“å®ç°\nlibrbd.cc ä¸»è¦å®ç°äº† I&#x2F;O ç›¸å…³æ¥å£ read&#x2F;writeã€‚\ninternal.cc ä¸»è¦å®ç°äº†å®šä¹‰åœ¨å¤´æ–‡ä»¶ä¸­çš„ç›¸å…³å‡½æ•°æ¥å£\n\nCls\ncls_rbdæ˜¯Clsçš„ä¸€ä¸ªæ‰©å±•æ¨¡å—ï¼ŒClså…è®¸ç”¨æˆ·è‡ªå®šä¹‰å¯¹è±¡çš„æ“ä½œæ¥å£å’Œå®ç°æ–¹æ³•ï¼Œä¸ºç”¨æˆ·æä¾›äº†ä¸€ç§æ¯”è¾ƒç›´æ¥çš„æ¥å£æ‰©å±•æ–¹å¼ã€‚é€šè¿‡åŠ¨æ€é“¾æ¥çš„å½¢å¼åŠ å…¥ osd ä¸­ï¼Œåœ¨ osd ä¸Šç›´æ¥æ‰§è¡Œã€‚\n\nClient\ncls_rbd_client.h&#x2F;cc è¯¥æ–‡ä»¶ä¸­ä¸»è¦å®šä¹‰äº†å®¢æˆ·ç«¯ä¸Šè¿è¡Œçš„æ¥å£ï¼Œå°†å‡½æ•°å‚æ•°å°è£…åå‘é€ç»™æœåŠ¡ç«¯ OSD ï¼Œç„¶ååšåç»­å¤„ç†.\ncls_rbd_client.h/cc å®šä¹‰äº†é€šè¿‡å®¢æˆ·ç«¯è®¿é—®osdæ³¨å†Œçš„clså‡½æ•°çš„æ–¹æ³•ã€‚ä»¥ snapshot_add å‡½æ•°å’Œ create_image å‡½æ•°ä¸ºä¾‹ï¼Œè¿™ä¸ªå‡½æ•°å°†å‚æ•°å°è£…è¿› bufferlist ï¼Œé€šè¿‡ ioctx-&gt;exec æ–¹æ³•ï¼ŒæŠŠæ“ä½œå‘é€ç»™osdå¤„ç†ã€‚\n\nvoid snapshot_add(librados::ObjectWriteOperation *op, snapid_t snap_id,              const std::string &amp;snap_name, const cls::rbd::SnapshotNamespace &amp;snap_namespace)&#123;  bufferlist bl;  ::encode(snap_name, bl);  ::encode(snap_id, bl);  ::encode(cls::rbd::SnapshotNamespaceOnDisk(snap_namespace), bl);  op-&gt;exec(&quot;rbd&quot;, &quot;snapshot_add&quot;, bl);&#125;void create_image(librados::ObjectWriteOperation *op, uint64_t size,                  uint8_t order, uint64_t features,                  const std::string &amp;object_prefix, int64_t data_pool_id)&#123;  bufferlist bl;  ::encode(size, bl);  ::encode(order, bl);  ::encode(features, bl);  ::encode(object_prefix, bl);  ::encode(data_pool_id, bl);  op-&gt;exec(&quot;rbd&quot;, &quot;create&quot;, bl);&#125;int create_image(librados::IoCtx *ioctx, const std::string &amp;oid,                 uint64_t size, uint8_t order, uint64_t features,                 const std::string &amp;object_prefix, int64_t data_pool_id)&#123;  librados::ObjectWriteOperation op;  create_image(&amp;op, size, order, features, object_prefix, data_pool_id);  return ioctx-&gt;operate(oid, &amp;op);&#125;\n\nServer\ncls_rbd.h&#x2F;cc è¯¥ç±»ä¸­ä¸»è¦å®šä¹‰äº†æœåŠ¡ç«¯ä¸Šï¼ˆOSDï¼‰æ‰§è¡Œçš„å‡½æ•°ï¼Œå“åº”å®¢æˆ·ç«¯çš„è¯·æ±‚ã€‚åœ¨ cls_rbd.cc å‡½æ•°ä¸­ï¼Œå¯¹å‡½æ•°è¿›è¡Œå®šä¹‰å’Œæ³¨å†Œã€‚\nä¾‹å¦‚ï¼Œä¸‹é¢çš„ä»£ç æ³¨å†Œäº†rbdæ¨¡å—ï¼Œä»¥åŠ snapshot_add å’Œ create å‡½æ•°ã€‚\n\ncls_register(&quot;rbd&quot;, &amp;h_class);cls_register_cxx_method(h_class, &quot;snapshot_add&quot;,            CLS_METHOD_RD | CLS_METHOD_WR,            snapshot_add, &amp;h_snapshot_add);            cls_register_cxx_method(h_class, &quot;create&quot;,\t  CLS_METHOD_RD | CLS_METHOD_WR,\t  create, &amp;h_create);\n\n\ncls_rbd.ccå®šä¹‰äº†æ–¹æ³•åœ¨æœåŠ¡ç«¯çš„å®ç°ï¼Œå…¶ä¸€èˆ¬æµç¨‹æ˜¯ï¼šä»bufferlistå°†å®¢æˆ·ç«¯ä¼ å…¥çš„å‚æ•°è§£æå‡ºæ¥ï¼Œè°ƒç”¨å¯¹åº”çš„æ–¹æ³•å®ç°ï¼Œç„¶åå°†ç»“æœè¿”å›å®¢æˆ·ç«¯ã€‚\n\n/** * Adds a snapshot to an rbd header. Ensures the id and name are unique. */int snapshot_add(cls_method_context_t hctx, bufferlist *in, bufferlist *out)&#123;  bufferlist snap_namebl, snap_idbl;  cls_rbd_snap snap_meta;  uint64_t snap_limit;  // ä»blä¸­è§£æå‚æ•°  try &#123;    bufferlist::iterator iter = in-&gt;begin();    ::decode(snap_meta.name, iter);    ::decode(snap_meta.id, iter);    if (!iter.end()) &#123;      ::decode(snap_meta.snapshot_namespace, iter);    &#125;  &#125; catch (const buffer::error &amp;err) &#123;    return -EINVAL;  &#125;  // åˆ¤æ–­å‚æ•°åˆæ³•æ€§ï¼Œç•¥  ......  // å®Œæˆæ“ä½œï¼Œåœ¨rbd_headerå¯¹è±¡ä¸­å¢åŠ æ–°çš„snapshotå…ƒæ•°æ®ï¼Œå¹¶æ›´æ–°sanp_seqã€‚  map&lt;string, bufferlist&gt; vals;  vals[&quot;snap_seq&quot;] = snap_seqbl;  vals[snapshot_key] = snap_metabl;  r = cls_cxx_map_set_vals(hctx, &amp;vals);  if (r &lt; 0) &#123;    CLS_ERR(&quot;error writing snapshot metadata: %s&quot;, cpp_strerror(r).c_str());    return r;  &#125;  return 0;&#125;/** * Initialize the header with basic metadata. * Extra features may initialize more fields in the future. * Everything is stored as key/value pairs as omaps in the header object. * * If features the OSD does not understand are requested, -ENOSYS is * returned. * * Input: * @param size number of bytes in the image (uint64_t) * @param order bits to shift to determine the size of data objects (uint8_t) * @param features what optional things this image will use (uint64_t) * @param object_prefix a prefix for all the data objects * @param data_pool_id pool id where data objects is stored (int64_t) * * Output: * @return 0 on success, negative error code on failure */int create(cls_method_context_t hctx, bufferlist *in, bufferlist *out)&#123;  string object_prefix;  uint64_t features, size;  uint8_t order;  int64_t data_pool_id = -1;  // ä» buffer é‡Œè§£æå‚æ•°  try &#123;    auto iter = in-&gt;cbegin();    decode(size, iter);    decode(order, iter);    decode(features, iter);    decode(object_prefix, iter);    if (!iter.end()) &#123;      decode(data_pool_id, iter);    &#125;  &#125; catch (const buffer::error &amp;err) &#123;    return -EINVAL;  &#125;  CLS_LOG(20, &quot;create object_prefix=%s size=%llu order=%u features=%llu&quot;,\t  object_prefix.c_str(), (unsigned long long)size, order,\t  (unsigned long long)features);  if (features &amp; ~RBD_FEATURES_ALL) &#123;    return -ENOSYS;  &#125;  if (!object_prefix.size()) &#123;    return -EINVAL;  &#125;  bufferlist stored_prefixbl;    // ä» cls context é‡Œè·å– object_prefix  int r = cls_cxx_map_get_val(hctx, &quot;object_prefix&quot;, &amp;stored_prefixbl);  if (r != -ENOENT) &#123;    CLS_ERR(&quot;reading object_prefix returned %d&quot;, r);    return -EEXIST;  &#125;  bufferlist sizebl;  bufferlist orderbl;  bufferlist featuresbl;  bufferlist object_prefixbl;  bufferlist snap_seqbl;  bufferlist timestampbl;  uint64_t snap_seq = 0;  utime_t timestamp = ceph_clock_now();  encode(size, sizebl);  encode(order, orderbl);  encode(features, featuresbl);  encode(object_prefix, object_prefixbl);  encode(snap_seq, snap_seqbl);  encode(timestamp, timestampbl);  // æ›´æ–° rbd_header omap   map&lt;string, bufferlist&gt; omap_vals;  omap_vals[&quot;size&quot;] = sizebl;  omap_vals[&quot;order&quot;] = orderbl;  omap_vals[&quot;features&quot;] = featuresbl;  omap_vals[&quot;object_prefix&quot;] = object_prefixbl;  omap_vals[&quot;snap_seq&quot;] = snap_seqbl;  omap_vals[&quot;create_timestamp&quot;] = timestampbl;  omap_vals[&quot;access_timestamp&quot;] = timestampbl;  omap_vals[&quot;modify_timestamp&quot;] = timestampbl;  if ((features &amp; RBD_FEATURE_OPERATIONS) != 0ULL) &#123;    CLS_ERR(&quot;Attempting to set internal feature: operations&quot;);    return -EINVAL;  &#125;  if (features &amp; RBD_FEATURE_DATA_POOL) &#123;    if (data_pool_id == -1) &#123;      CLS_ERR(&quot;data pool not provided with feature enabled&quot;);      return -EINVAL;    &#125;    bufferlist data_pool_id_bl;    encode(data_pool_id, data_pool_id_bl);    omap_vals[&quot;data_pool_id&quot;] = data_pool_id_bl;  &#125; else if (data_pool_id != -1) &#123;    CLS_ERR(&quot;data pool provided with feature disabled&quot;);    return -EINVAL;  &#125;  // æ›´æ–° OMAP  r = cls_cxx_map_set_vals(hctx, &amp;omap_vals);  if (r &lt; 0)    return r;  return 0;&#125;\n\nOthers\nåˆ†ç‰‡ Striper\nCeph RBD é»˜è®¤åˆ†ç‰‡åˆ°äº†è®¸å¤šå¯¹è±¡ä¸Šï¼Œè¿™äº›å¯¹è±¡æœ€ç»ˆä¼šå­˜å‚¨åœ¨ RADOS ä¸­ï¼Œå¯¹ RBD Image çš„è¯»å†™è¯·æ±‚ä¼šåˆ†å¸ƒåœ¨é›†ç¾¤ä¸­çš„å¾ˆå¤šä¸ªèŠ‚ç‚¹ä¸Šï¼Œä»è€Œé¿å…å½“ RBD Image ç‰¹åˆ«å¤§æˆ–è€…ç¹å¿™çš„æ—¶å€™ï¼Œå•ä¸ªèŠ‚ç‚¹ä¸ä¼šæˆä¸ºç“¶é¢ˆã€‚\nCeph RBD çš„åˆ†ç‰‡ç”±ä¸‰ä¸ªå‚æ•°æ§åˆ¶\nobject-sizeï¼Œä»£ç ä¸­å¸¸å¸¸ç®€å†™ä¸º osï¼Œé€šå¸¸ä¸º 2 çš„å¹‚æŒ‡æ•°ï¼Œé»˜è®¤çš„å¯¹è±¡å¤§å°æ˜¯4 MBï¼Œæœ€å°çš„æ˜¯4Kï¼Œæœ€å¤§çš„æ˜¯32M\nstripe_unitï¼Œä»£ç ä¸­å¸¸å¸¸ç®€å†™ä¸º suï¼Œä¸€ä¸ªå¯¹è±¡ä¸­å­˜å‚¨äº†è¿ç»­è¯¥å¤§å°çš„åˆ†ç‰‡ã€‚é»˜è®¤å’Œå¯¹è±¡å¤§å°ç›¸ç­‰ã€‚\nstripe_countï¼Œä»£ç ä¸­å¸¸å¸¸ç®€å†™ä¸º scï¼Œåœ¨å‘ [stripe_count] å¯¹è±¡å†™å…¥ [stripe_unit] å­—èŠ‚åï¼Œå¾ªç¯åˆ°åˆå§‹å¯¹è±¡å¹¶å†™å…¥å¦ä¸€ä¸ªæ¡å¸¦ï¼Œç›´åˆ°å¯¹è±¡è¾¾åˆ°å…¶æœ€å¤§å¤§å°ã€‚æ­¤æ—¶ï¼Œå°†ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ª [stripe_count] å¯¹è±¡ã€‚\n\n\nåˆ†ç‰‡çš„ç»„ç»‡å½¢å¼ç±»ä¼¼äº RAID0ï¼Œçœ‹ä¸€ä¸ªæ¥è‡ªå®˜ç½‘çš„ ä¾‹å­ã€‚æ­¤å¤„åªä¸¾ä¾‹ä¸€ä¸ª Object Setï¼Œå¯¹è±¡å¤§å°åœ¨å¦‚ä¸‹å›¾ç¤ºä¸­å³ä¸ºçºµå‘çš„ä¸€ä¸ªå¯¹è±¡å¤§å°ï¼Œç”±æ•´æ•°ä¸ªåˆ†ç‰‡å•å…ƒç»„æˆï¼Œè€Œä¸€ä¸ªåˆ†ç‰‡æ˜¯æŒ‡æŒ‡å®š stripe_count ä¸ª stripe_unitï¼Œå›¾ç¤ºä¸­çš„ stripe_count å³ä¸º 5ï¼Œå‡è®¾ stripe_unit ä¸º 64KBï¼Œé‚£ä¹ˆå¯¹åº”çš„åˆ†ç‰‡å¤§å°å³ä¸º 320KBï¼Œå¯¹è±¡å¤§å°å¦‚æœè®¾ç½®ä¸º 64GBï¼Œé‚£ä¹ˆä¸€ä¸ªå¯¹è±¡å¯¹åº”çš„å°±ä¼šæœ‰ 64GB&#x2F;64KB &#x3D; 1048576 ä¸ª stripe_unit.\n\n   _________   _________   _________   _________   _________  /object  0\\ /object  1\\ /object  2\\ /object  3\\ /object  4\\  +=========+ +=========+ +=========+ +=========+ +=========+  |  stripe | |  stripe | |  stripe | |  stripe | |  stripe |o |   unit  | |   unit  | |   unit  | |   unit  | |   unit  | stripe 0b |     0   | |     1   | |     2   | |     3   | |     4   |j |---------| |---------| |---------| |---------| |---------|e |  stripe | |  stripe | |  stripe | |  stripe | |  stripe |c |   unit  | |   unit  | |   unit  | |   unit  | |   unit  | stripe 1t |     5   | |     6   | |     7   | |     8   | |     9   |  |---------| |---------| |---------| |---------| |---------|s |     .   | |     .   | |     .   | |     .   | |     .   |e       .           .           .           .           .t |     .   | |     .   | |     .   | |     .   | |     .   |  |---------| |---------| |---------| |---------| |---------|0 |  stripe | |  stripe | |  stripe | |  stripe | |  stripe | stripe  |   unit  | |   unit  | |   unit  | |   unit  | |   unit  | 1048575  | 5242875 | | 5242876 | | 5242877 | | 5242878 | | 5242879 |  \\=========/ \\=========/ \\=========/ \\=========/ \\=========/\n\n\nceph&#x2F;src&#x2F;osdc&#x2F;Striper.h\n\n  class Striper &#123;  public:    static void file_to_extents(        CephContext *cct, const file_layout_t *layout, uint64_t offset,        uint64_t len, uint64_t trunc_size, uint64_t buffer_offset,        striper::LightweightObjectExtents* object_extents);    /*     * std::map (ino, layout, offset, len) to a (list of) ObjectExtents (byte     * ranges in objects on (primary) osds)     */    static void file_to_extents(CephContext *cct, const char *object_format,\t\t\t\tconst file_layout_t *layout,\t\t\t\tuint64_t offset, uint64_t len,\t\t\t\tuint64_t trunc_size,\t\t\t\tstd::map&lt;object_t, std::vector&lt;ObjectExtent&gt; &gt;&amp; extents,\t\t\t\tuint64_t buffer_offset=0);...\n\n\nåˆ†ç‰‡å¤§å°å¯¹åº”çš„æ•°æ®ç»“æ„ï¼š\n\nstruct file_layout_t &#123;  // file -&gt; object mapping  uint32_t stripe_unit;   ///&lt; stripe unit, in bytes,  uint32_t stripe_count;  ///&lt; over this many objects  uint32_t object_size;   ///&lt; until objects are this big  int64_t pool_id;        ///&lt; rados pool id  std::string pool_ns;         ///&lt; rados pool namespace  file_layout_t(uint32_t su=0, uint32_t sc=0, uint32_t os=0)    : stripe_unit(su),      stripe_count(sc),      object_size(os),      pool_id(-1) &#123;  &#125;  // é»˜è®¤åˆ†ç‰‡å¤§å° 4MB  static file_layout_t get_default() &#123;    return file_layout_t(1&lt;&lt;22, 1, 1&lt;&lt;22);  &#125;  uint64_t get_period() const &#123;    return static_cast&lt;uint64_t&gt;(stripe_count) * object_size;  &#125;  void from_legacy(const ceph_file_layout&amp; fl);  void to_legacy(ceph_file_layout *fl) const;  bool is_valid() const;  void encode(ceph::buffer::list&amp; bl, uint64_t features) const;  void decode(ceph::buffer::list::const_iterator&amp; p);  void dump(ceph::Formatter *f) const;  void decode_json(JSONObj *obj);  static void generate_test_instances(std::list&lt;file_layout_t*&gt;&amp; o);&#125;;\n\n\næŸ¥çœ‹åˆ†ç‰‡ç±»å¯¹åº”çš„å®ç°ï¼šceph&#x2F;src&#x2F;osdc&#x2F;Striper.cc\n\nvoid Striper::file_to_extents(CephContext *cct, const char *object_format,\t\t\t      const file_layout_t *layout,\t\t\t      uint64_t offset, uint64_t len,\t\t\t      uint64_t trunc_size,\t\t\t      std::vector&lt;ObjectExtent&gt;&amp; extents,\t\t\t      uint64_t buffer_offset)&#123;  striper::LightweightObjectExtents lightweight_object_extents;  file_to_extents(cct, layout, offset, len, trunc_size, buffer_offset,                  &amp;lightweight_object_extents);  // convert lightweight object extents to heavyweight version  extents.reserve(lightweight_object_extents.size());  for (auto&amp; lightweight_object_extent : lightweight_object_extents) &#123;    auto&amp; object_extent = extents.emplace_back(      object_t(format_oid(object_format, lightweight_object_extent.object_no)),      lightweight_object_extent.object_no,      lightweight_object_extent.offset, lightweight_object_extent.length,      lightweight_object_extent.truncate_size);    object_extent.oloc = OSDMap::file_to_object_locator(*layout);    object_extent.buffer_extents.reserve(      lightweight_object_extent.buffer_extents.size());    object_extent.buffer_extents.insert(      object_extent.buffer_extents.end(),      lightweight_object_extent.buffer_extents.begin(),      lightweight_object_extent.buffer_extents.end());  &#125;&#125;void Striper::file_to_extents(    CephContext *cct, const file_layout_t *layout, uint64_t offset,    uint64_t len, uint64_t trunc_size, uint64_t buffer_offset,    striper::LightweightObjectExtents* object_extents) &#123;  ldout(cct, 10) &lt;&lt; &quot;file_to_extents &quot; &lt;&lt; offset &lt;&lt; &quot;~&quot; &lt;&lt; len &lt;&lt; dendl;  ceph_assert(len &gt; 0);  /*   * we want only one extent per object!  this means that each extent   * we read may map into different bits of the final read   * buffer.. hence buffer_extents   */  __u32 object_size = layout-&gt;object_size;  __u32 su = layout-&gt;stripe_unit;  __u32 stripe_count = layout-&gt;stripe_count;  ceph_assert(object_size &gt;= su);  if (stripe_count == 1) &#123;    ldout(cct, 20) &lt;&lt; &quot; sc is one, reset su to os&quot; &lt;&lt; dendl;    su = object_size;  &#125;  uint64_t stripes_per_object = object_size / su;  ldout(cct, 20) &lt;&lt; &quot; su &quot; &lt;&lt; su &lt;&lt; &quot; sc &quot; &lt;&lt; stripe_count &lt;&lt; &quot; os &quot;\t\t &lt;&lt; object_size &lt;&lt; &quot; stripes_per_object &quot; &lt;&lt; stripes_per_object\t\t &lt;&lt; dendl;  uint64_t cur = offset;  uint64_t left = len;  while (left &gt; 0) &#123;    // layout into objects    uint64_t blockno = cur / su; // which block    // which horizontal stripe (Y)    uint64_t stripeno = blockno / stripe_count;    // which object in the object set (X)    uint64_t stripepos = blockno % stripe_count;    // which object set    uint64_t objectsetno = stripeno / stripes_per_object;    // object id    uint64_t objectno = objectsetno * stripe_count + stripepos;    // map range into object    uint64_t block_start = (stripeno % stripes_per_object) * su;    uint64_t block_off = cur % su;    uint64_t max = su - block_off;    uint64_t x_offset = block_start + block_off;    uint64_t x_len;    if (left &gt; max)      x_len = max;    else      x_len = left;    ldout(cct, 20) &lt;&lt; &quot; off &quot; &lt;&lt; cur &lt;&lt; &quot; blockno &quot; &lt;&lt; blockno &lt;&lt; &quot; stripeno &quot;\t\t   &lt;&lt; stripeno &lt;&lt; &quot; stripepos &quot; &lt;&lt; stripepos &lt;&lt; &quot; objectsetno &quot;\t\t   &lt;&lt; objectsetno &lt;&lt; &quot; objectno &quot; &lt;&lt; objectno\t\t   &lt;&lt; &quot; block_start &quot; &lt;&lt; block_start &lt;&lt; &quot; block_off &quot;\t\t   &lt;&lt; block_off &lt;&lt; &quot; &quot; &lt;&lt; x_offset &lt;&lt; &quot;~&quot; &lt;&lt; x_len\t\t   &lt;&lt; dendl;    striper::LightweightObjectExtent* ex = nullptr;    auto it = std::upper_bound(object_extents-&gt;begin(), object_extents-&gt;end(),                               objectno, OrderByObject());    striper::LightweightObjectExtents::reverse_iterator rev_it(it);    if (rev_it == object_extents-&gt;rend() ||        rev_it-&gt;object_no != objectno ||        rev_it-&gt;offset + rev_it-&gt;length != x_offset) &#123;      // expect up to &quot;stripe-width - 1&quot; vector shifts in the worst-case      ex = &amp;(*object_extents-&gt;emplace(        it, objectno, x_offset, x_len,        object_truncate_size(cct, layout, objectno, trunc_size)));        ldout(cct, 20) &lt;&lt; &quot; added new &quot; &lt;&lt; *ex &lt;&lt; dendl;    &#125; else &#123;      ex = &amp;(*rev_it);      ceph_assert(ex-&gt;offset + ex-&gt;length == x_offset);      ldout(cct, 20) &lt;&lt; &quot; adding in to &quot; &lt;&lt; *ex &lt;&lt; dendl;      ex-&gt;length += x_len;    &#125;    ex-&gt;buffer_extents.emplace_back(cur - offset + buffer_offset, x_len);    ldout(cct, 15) &lt;&lt; &quot;file_to_extents  &quot; &lt;&lt; *ex &lt;&lt; dendl;    // ldout(cct, 0) &lt;&lt; &quot;map: ino &quot; &lt;&lt; ino &lt;&lt; &quot; oid &quot; &lt;&lt; ex.oid &lt;&lt; &quot; osd &quot;    //\t\t  &lt;&lt; ex.osd &lt;&lt; &quot; offset &quot; &lt;&lt; ex.offset &lt;&lt; &quot; len &quot; &lt;&lt; ex.len    //\t\t  &lt;&lt; &quot; ... left &quot; &lt;&lt; left &lt;&lt; dendl;    left -= x_len;    cur += x_len;  &#125;&#125;\n\næ•°æ® IO\nä¸»è¦å¯¹åº”äº ImageCtx::io_work_queue æˆå‘˜å˜é‡ã€‚librbd::io::ImageRequestWQ æ´¾ç”Ÿè‡ª ThreadPool::PointerWQï¼ˆ&lt;= Luminousï¼‰ / ThreadPool::PointerWQï¼ˆ&gt;= Mimicï¼‰ã€‚\nlibrbd æ”¯æŒä¸¤ç§ç±»å‹çš„ aioï¼Œä¸€ç§æ˜¯æ™®é€šçš„ aioï¼Œä¸€ç§æ˜¯éé˜»å¡ aioã€‚å‰è€…çš„è¡Œä¸ºç›¸å¯¹ç®€å•ï¼Œç›´æ¥åœ¨ç”¨æˆ·çº¿ç¨‹çš„ä¸Šä¸‹æ–‡è¿›è¡Œ io å¤„ç†ï¼Œè€Œåè€…å°†ç”¨æˆ·çš„ io ç›´æ¥å…¥ io_work_queue é˜Ÿåˆ—ï¼Œç„¶å io ç”±é˜Ÿåˆ—çš„å·¥ä½œçº¿ç¨‹å‡ºé˜Ÿå¹¶åœ¨å·¥ä½œçº¿ç¨‹ä¸Šä¸‹æ–‡è¿›è¡Œåç»­çš„å¤„ç†ã€‚è¿™ä¸¤ç§ aio çš„è¡Œä¸ºç”±é…ç½®å‚æ•° rbd_non_blocking_aio å†³å®šï¼Œé»˜è®¤ä¸º trueï¼Œå› æ­¤é»˜è®¤ä¸ºéé˜»å¡ aioï¼Œä½†éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå³ä½¿é»˜è®¤ä¸æ˜¯éé˜»å¡ aioï¼Œåœ¨æŸäº›åœºæ™¯ä¸‹ aio ä»ç„¶ä¼šéœ€è¦å…¥ io_work_queue é˜Ÿåˆ—ï¼Œæ€»ç»“å¦‚ä¸‹:\n\nread\nImageRequestWQ::writes_blocked() ä¸º trueï¼Œå³å·²è°ƒç”¨ ImageRequestWQ::block_writesï¼Œå½“å‰å·²ç¦æ­¢ write io ä¸‹å‘è‡³ rados å±‚ï¼›\nImageRequestWQ::writes_empty() ä¸º falseï¼Œå³å‰é¢å·²ç»æœ‰ write io å…¥äº† io_work_queue é˜Ÿåˆ—ï¼›\nImageRequestWQ::require_lock_on_read() ä¸º trueï¼Œè¿™é‡Œçš„ lock æ˜¯æŒ‡ exclusive lockï¼Œè¡¨ç¤ºå½“å‰è¿˜æœªæ‹¿åˆ°ï¼Œåœ¨å¯ç”¨ exclusive lock ç‰¹æ€§çš„å‰æä¸‹ï¼Œä¸€æ—¦å¼€å¯å…‹éš† COR (copy on read) æˆ–è€…å¯ç”¨ journaling ç‰¹æ€§ï¼Œå¤„ç† read io ä¹Ÿè¦æ±‚æ‹¿é”ï¼›\n\nwrite\nImageRequestWQ::writes_blocked() ä¸º trueï¼Œå³å·²è°ƒç”¨ ImageRequestWQ::block_writesï¼Œå½“å‰å·²ç¦æ­¢ write io ä¸‹å‘è‡³ rados å±‚ï¼›\nå¯¹äº write è€Œè¨€ï¼Œå¹¶æ²¡æœ‰ç±»ä¼¼ ImageRequestWQ::require_lock_on_write çš„æ¥å£ï¼Œè¿™æ˜¯å› ä¸ºä¸€æ—¦å¯ç”¨ exclusive lock ç‰¹æ€§ï¼Œåœ¨åˆå§‹åŒ– exclusive lock æ—¶ä¼šè°ƒç”¨ ImageRequestWQ::block_writesï¼ˆå‚è€ƒ ExclusiveLock::initï¼‰ï¼Œç›´è‡³æ‹¿åˆ°é”ï¼ˆå‚è€ƒ ExclusiveLock::handle_post_acquired_lockï¼‰ï¼Œå› æ­¤å¢åŠ  ImageRequestWQ::require_lock_on_write æ¥å£å¹¶æ²¡æœ‰å¿…è¦ã€‚\néœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒImageRequestWQ::block_writes å¹¶ä¸åªæ˜¯ç®€å•çš„è®¾ç½®ç¦æ­¢æ ‡å¿—ï¼Œè¿˜éœ€è¦ flush å·²ä¸‹å‘çš„ rados ioï¼Œå³ç­‰å¾…æ‰€æœ‰å·²ä¸‹å‘çš„ rados io ç»“æŸæ‰è¿”å›ã€‚\nä»ä¸Šé¢å¯¹ readã€write çš„åˆ†æï¼Œä¼¼ä¹ ImageRequestWQ::writes_blocked æ”¹æˆ ImageRequestWQ::io_blocked ä¼¼ä¹æ›´åˆç†ï¼Œä½†å®é™…ä¸Šè¿™é‡Œå¹¶æ²¡æœ‰çœŸçš„ç¦æ­¢ read io ä¸‹å‘è‡³ rados å±‚ï¼Œåªæ˜¯è®© read io å…ˆå…¥ io_work_queue é˜Ÿåˆ—ã€‚\n\nTCMU-RBDstatic void tcmu_rbd_image_close(struct tcmu_device *dev)&#123;\tstruct tcmu_rbd_state *state = tcmur_dev_get_private(dev);\trbd_close(state-&gt;image);\trados_ioctx_destroy(state-&gt;io_ctx);\trados_shutdown(state-&gt;cluster);\tstate-&gt;cluster = NULL;\tstate-&gt;io_ctx = NULL;\tstate-&gt;image = NULL;&#125;static int tcmu_rbd_image_open(struct tcmu_device *dev)&#123;\tstruct tcmu_rbd_state *state = tcmur_dev_get_private(dev);\tint ret;\tret = rados_create(&amp;state-&gt;cluster, state-&gt;id);\tif (ret &lt; 0) &#123;\t\ttcmu_dev_err(dev, &quot;Could not create cluster. (Err %d)\\n&quot;, ret);\t\treturn ret;\t&#125;\t/* Try default location when conf_path=NULL, but ignore failure */\tret = rados_conf_read_file(state-&gt;cluster, state-&gt;conf_path);\tif (state-&gt;conf_path &amp;&amp; ret &lt; 0) &#123;\t\ttcmu_dev_err(dev, &quot;Could not read config %s (Err %d)&quot;,\t\t\t     state-&gt;conf_path, ret);\t\tgoto rados_shutdown;\t&#125;\trados_conf_set(state-&gt;cluster, &quot;rbd_cache&quot;, &quot;false&quot;);\tret = timer_check_and_set_def(dev);\tif (ret)\t\ttcmu_dev_warn(dev,\t\t\t      &quot;Could not set rados osd op timeout to %s (Err %d. Failover may be delayed.)\\n&quot;,\t\t\t      state-&gt;osd_op_timeout, ret);\tret = rados_connect(state-&gt;cluster);\tif (ret &lt; 0) &#123;\t\ttcmu_dev_err(dev, &quot;Could not connect to cluster. (Err %d)\\n&quot;,\t\t\t     ret);\t\tgoto rados_shutdown;\t&#125;\ttcmu_rbd_detect_device_class(dev);\tret = rados_ioctx_create(state-&gt;cluster, state-&gt;pool_name,\t\t\t\t &amp;state-&gt;io_ctx);\tif (ret &lt; 0) &#123;\t\ttcmu_dev_err(dev, &quot;Could not create ioctx for pool %s. (Err %d)\\n&quot;,\t\t\t     state-&gt;pool_name, ret);\t\tgoto rados_shutdown;\t&#125;\tret = rbd_open(state-&gt;io_ctx, state-&gt;image_name, &amp;state-&gt;image, NULL);\tif (ret &lt; 0) &#123;\t\ttcmu_dev_err(dev, &quot;Could not open image %s. (Err %d)\\n&quot;,\t\t\t     state-&gt;image_name, ret);\t\tgoto rados_destroy;\t&#125;\tret = tcmu_rbd_service_register(dev);\tif (ret &lt; 0)\t\tgoto rbd_close;\treturn 0;rbd_close:\trbd_close(state-&gt;image);\tstate-&gt;image = NULL;rados_destroy:\trados_ioctx_destroy(state-&gt;io_ctx);\tstate-&gt;io_ctx = NULL;rados_shutdown:\trados_shutdown(state-&gt;cluster);\tstate-&gt;cluster = NULL;\treturn ret;&#125;static int tcmu_rbd_open(struct tcmu_device *dev, bool reopen)&#123;\trbd_image_info_t image_info;\tchar *pool, *name, *next_opt;\tchar *config, *dev_cfg_dup;\tstruct tcmu_rbd_state *state;\tuint32_t max_blocks;\tint ret;\tstate = calloc(1, sizeof(*state));\tif (!state)\t\treturn -ENOMEM;\ttcmur_dev_set_private(dev, state);\tdev_cfg_dup = strdup(tcmu_dev_get_cfgstring(dev));\tconfig = dev_cfg_dup;\tif (!config) &#123;\t\tret = -ENOMEM;\t\tgoto free_state;\t&#125;\ttcmu_dev_dbg(dev, &quot;tcmu_rbd_open config %s block size %u num lbas %&quot; PRIu64 &quot;.\\n&quot;,\t\t     config, tcmu_dev_get_block_size(dev),\t\t     tcmu_dev_get_num_lbas(dev));\tconfig = strchr(config, &#x27;/&#x27;);\tif (!config) &#123;\t\ttcmu_dev_err(dev, &quot;no configuration found in cfgstring\\n&quot;);\t\tret = -EINVAL;\t\tgoto free_config;\t&#125;\tconfig += 1; /* get past &#x27;/&#x27; */\tpool = strtok(config, &quot;/&quot;);\tif (!pool) &#123;\t\ttcmu_dev_err(dev, &quot;Could not get pool name\\n&quot;);\t\tret = -EINVAL;\t\tgoto free_config;\t&#125;\tstate-&gt;pool_name = strdup(pool);\tif (!state-&gt;pool_name) &#123;\t\tret = -ENOMEM;\t\ttcmu_dev_err(dev, &quot;Could not copy pool name\\n&quot;);\t\tgoto free_config;\t&#125;\tname = strtok(NULL, &quot;;&quot;);\tif (!name) &#123;\t\ttcmu_dev_err(dev, &quot;Could not get image name\\n&quot;);\t\tret = -EINVAL;\t\tgoto free_config;\t&#125;\tstate-&gt;image_name = strdup(name);\tif (!state-&gt;image_name) &#123;\t\tret = -ENOMEM;\t\ttcmu_dev_err(dev, &quot;Could not copy image name\\n&quot;);\t\tgoto free_config;\t&#125;\t/* The next options are optional */\tnext_opt = strtok(NULL, &quot;;&quot;);\twhile (next_opt) &#123;\t\tif (!strncmp(next_opt, &quot;osd_op_timeout=&quot;, 15)) &#123;\t\t\tstate-&gt;osd_op_timeout = strdup(next_opt + 15);\t\t\tif (!state-&gt;osd_op_timeout ||\t\t\t    !strlen(state-&gt;osd_op_timeout)) &#123;\t\t\t\tret = -ENOMEM;\t\t\t\ttcmu_dev_err(dev, &quot;Could not copy osd op timeout.\\n&quot;);\t\t\t\tgoto free_config;\t\t\t&#125;\t\t&#125; else if (!strncmp(next_opt, &quot;conf=&quot;, 5)) &#123;\t\t\tstate-&gt;conf_path = strdup(next_opt + 5);\t\t\tif (!state-&gt;conf_path || !strlen(state-&gt;conf_path)) &#123;\t\t\t\tret = -ENOMEM;\t\t\t\ttcmu_dev_err(dev, &quot;Could not copy conf path.\\n&quot;);\t\t\t\tgoto free_config;\t\t\t&#125;\t\t&#125; else if (!strncmp(next_opt, &quot;id=&quot;, 3)) &#123;\t\t\tstate-&gt;id = strdup(next_opt + 3);\t\t\tif (!state-&gt;id || !strlen(state-&gt;id)) &#123;\t\t\t\tret = -ENOMEM;\t\t\t\ttcmu_dev_err(dev, &quot;Could not copy id.\\n&quot;);\t\t\t\tgoto free_config;\t\t\t&#125;\t\t&#125;\t\tnext_opt = strtok(NULL, &quot;;&quot;);\t&#125;\tret = tcmu_rbd_image_open(dev);\tif (ret &lt; 0) &#123;\t\tgoto free_config;\t&#125;\ttcmu_rbd_check_excl_lock_enabled(dev);\tret = tcmu_rbd_check_image_size(dev, tcmu_dev_get_block_size(dev) *\t\t\t\t\ttcmu_dev_get_num_lbas(dev));\tif (ret) &#123;\t\tgoto stop_image;\t&#125;\tret = rbd_stat(state-&gt;image, &amp;image_info, sizeof(image_info));\tif (ret &lt; 0) &#123;\t\ttcmu_dev_err(dev, &quot;Could not stat image.\\n&quot;);\t\tgoto stop_image;\t&#125;\t/*\t * librbd/ceph can better split and align unmaps and internal RWs, so\t * just have runner pass the entire cmd to us. To try and balance\t * overflowing the OSD/ceph side queues with discards/RWs limit it to\t * up to 4.\t */\tmax_blocks = (image_info.obj_size * 4) / tcmu_dev_get_block_size(dev);\ttcmu_dev_set_opt_xcopy_rw_len(dev, max_blocks);\ttcmu_dev_set_max_unmap_len(dev, max_blocks);\ttcmu_dev_set_opt_unmap_gran(dev, image_info.obj_size /\t\t\t\t    tcmu_dev_get_block_size(dev), false);\ttcmu_dev_set_write_cache_enabled(dev, 0);\tfree(dev_cfg_dup);\treturn 0;stop_image:\ttcmu_rbd_image_close(dev);free_config:\tfree(dev_cfg_dup);free_state:\ttcmu_rbd_state_free(state);\treturn ret;&#125;static void tcmu_rbd_close(struct tcmu_device *dev)&#123;\tstruct tcmu_rbd_state *state = tcmur_dev_get_private(dev);\ttcmu_rbd_image_close(dev);\ttcmu_rbd_state_free(state);&#125;static int tcmu_rbd_aio_read(struct tcmu_device *dev, struct rbd_aio_cb *aio_cb,\t\t\t     rbd_completion_t completion, struct iovec *iov,\t\t\t     size_t iov_cnt, size_t length, off_t offset)&#123;\tstruct tcmu_rbd_state *state = tcmur_dev_get_private(dev);\tint ret;\taio_cb-&gt;bounce_buffer = malloc(length);\tif (!aio_cb-&gt;bounce_buffer) &#123;\t\ttcmu_dev_err(dev, &quot;Could not allocate bounce buffer.\\n&quot;);\t\treturn -ENOMEM;\t&#125;\tret = rbd_aio_read(state-&gt;image, offset, length, aio_cb-&gt;bounce_buffer,\t\t\t   completion);\tif (ret &lt; 0)\t\tfree(aio_cb-&gt;bounce_buffer);\treturn ret;&#125;static int tcmu_rbd_aio_write(struct tcmu_device *dev, struct rbd_aio_cb *aio_cb,\t\t\t      rbd_completion_t completion, struct iovec *iov,\t\t\t      size_t iov_cnt, size_t length, off_t offset)&#123;\tstruct tcmu_rbd_state *state = tcmur_dev_get_private(dev);\tint ret;\taio_cb-&gt;bounce_buffer = malloc(length);\tif (!aio_cb-&gt;bounce_buffer) &#123;\t\ttcmu_dev_err(dev, &quot;Failed to allocate bounce buffer.\\n&quot;);\t\treturn -ENOMEM;;\t&#125;\ttcmu_memcpy_from_iovec(aio_cb-&gt;bounce_buffer, length, iov, iov_cnt);\tret = rbd_aio_write(state-&gt;image, offset, length, aio_cb-&gt;bounce_buffer,\t\t\t    completion);\tif (ret &lt; 0)\t\tfree(aio_cb-&gt;bounce_buffer);\treturn ret;&#125;static int tcmu_rbd_read(struct tcmu_device *dev, struct tcmulib_cmd *cmd,\t\t\t     struct iovec *iov, size_t iov_cnt, size_t length,\t\t\t     off_t offset)&#123;\tstruct rbd_aio_cb *aio_cb;\trbd_completion_t completion;\tssize_t ret;\taio_cb = calloc(1, sizeof(*aio_cb));\tif (!aio_cb) &#123;\t\ttcmu_dev_err(dev, &quot;Could not allocate aio_cb.\\n&quot;);\t\tgoto out;\t&#125;\taio_cb-&gt;dev = dev;\taio_cb-&gt;type = RBD_AIO_TYPE_READ;\taio_cb-&gt;read.length = length;\taio_cb-&gt;tcmulib_cmd = cmd;\taio_cb-&gt;iov = iov;\taio_cb-&gt;iov_cnt = iov_cnt;\tret = rbd_aio_create_completion\t\t(aio_cb, (rbd_callback_t) rbd_finish_aio_generic, &amp;completion);\tif (ret &lt; 0) &#123;\t\tgoto out_free_aio_cb;\t&#125;\tret = tcmu_rbd_aio_read(dev, aio_cb, completion, iov, iov_cnt,\t\t\t\tlength, offset);\tif (ret &lt; 0)\t\tgoto out_release_tracked_aio;\treturn TCMU_STS_OK;out_release_tracked_aio:\trbd_aio_release(completion);out_free_aio_cb:\tfree(aio_cb);out:\treturn TCMU_STS_NO_RESOURCE;&#125;static int tcmu_rbd_write(struct tcmu_device *dev, struct tcmulib_cmd *cmd,\t\t\t  struct iovec *iov, size_t iov_cnt, size_t length,\t\t\t  off_t offset)&#123;\tstruct rbd_aio_cb *aio_cb;\trbd_completion_t completion;\tssize_t ret;\taio_cb = calloc(1, sizeof(*aio_cb));\tif (!aio_cb) &#123;\t\ttcmu_dev_err(dev, &quot;Could not allocate aio_cb.\\n&quot;);\t\tgoto out;\t&#125;\taio_cb-&gt;dev = dev;\taio_cb-&gt;type = RBD_AIO_TYPE_WRITE;\taio_cb-&gt;tcmulib_cmd = cmd;\tret = rbd_aio_create_completion\t\t(aio_cb, (rbd_callback_t) rbd_finish_aio_generic, &amp;completion);\tif (ret &lt; 0) &#123;\t\tgoto out_free_aio_cb;\t&#125;\tret = tcmu_rbd_aio_write(dev, aio_cb, completion, iov, iov_cnt,\t\t\t\t length, offset);\tif (ret &lt; 0) &#123;\t\tgoto out_release_tracked_aio;\t&#125;\treturn TCMU_STS_OK;out_release_tracked_aio:\trbd_aio_release(completion);out_free_aio_cb:\tfree(aio_cb);out:\treturn TCMU_STS_NO_RESOURCE;&#125;\n\nå‚è€ƒé“¾æ¥\n[1] Ceph RDB å®˜æ–¹æ–‡æ¡£ä»‹ç»\n[2] ç®€ä¹¦ - ceph rbdï¼šæ€»è§ˆ\n[3] æ˜é‡‘ - Cephä»‹ç»åŠåŸç†æ¶æ„åˆ†äº«\n[4] CSDNï¼šCephå­¦ä¹ â€”â€”Librbdå—å­˜å‚¨åº“ä¸RBDè¯»å†™æµç¨‹æºç åˆ†æ\n[5] CSDNï¼šCeph RBDç¼–ç¨‹æ¥å£Librbd(C++) â€“ æ˜ åƒåˆ›å»ºä¸æ•°æ®è¯»å†™\n[6] è…¾è®¯äº‘ä¸“æ ï¼šå¤§è¯Cephç³»åˆ—\n[7] runsisi.com - librbd å†…éƒ¨è¿è¡Œæœºåˆ¶\n[8] CSDNï¼šCephå­¦ä¹ â€”â€”Libradosä¸Osdcå®ç°æºç è§£æ\n[9] CSDNï¼šlibrbdä»£ç ç›®å½•è§£è¯»\n[10] Ceph: RBD åˆ›å»ºé•œåƒè¿‡ç¨‹ä»¥åŠæºç åˆ†æ\n[11] librbd æ¶æ„åˆ†æ\n\n","tags":["ceph","å­˜å‚¨","åˆ†å¸ƒå¼"]},{"title":"crmsoné¢„è§ˆç‰ˆ.md","url":"/2025/09/19/crimson%E9%A2%84%E8%A7%88%E7%89%88/","content":"Crimson æ˜¯ Crimson OSD çš„ä»£ç åç§°ï¼Œå®ƒæ˜¯ä¸‹ä¸€ä»£ç”¨äºå¤šæ ¸å¿ƒå¯æ‰©å±•æ€§çš„ OSD ã€‚å®ƒé€šè¿‡å¿«é€Ÿç½‘ç»œå’Œå­˜å‚¨è®¾å¤‡æé«˜æ€§èƒ½ï¼Œé‡‡ç”¨åŒ…æ‹¬ DPDK å’Œ SPDK çš„é¡¶çº§æŠ€æœ¯ã€‚BlueStore ç»§ç»­æ”¯æŒ HDD å’Œ SSDã€‚Crimson æ—¨åœ¨ä¸æ—©æœŸç‰ˆæœ¬çš„ OSD å®ˆæŠ¤è¿›ç¨‹ä¸ç±» Ceph OSD å…¼å®¹ã€‚\nCrimson åŸºäº SeaStar C++ æ¡†æ¶æ„å»ºï¼Œæ˜¯æ ¸å¿ƒ Ceph å¯¹è±¡å­˜å‚¨å®ˆæŠ¤è¿›ç¨‹ OSD ç»„ä»¶çš„æ–°å®ç°ï¼Œå¹¶æ›¿æ¢äº† Ceph OSD ã€‚Crimson OSD æœ€å°åŒ–å»¶è¿Ÿå¹¶å¢åŠ  CPU å¤„ç†å™¨ç”¨é‡ã€‚å®ƒä½¿ç”¨é«˜æ€§èƒ½å¼‚æ­¥ IO å’Œæ–°çš„çº¿ç¨‹æ¶æ„ï¼Œæ—¨åœ¨æœ€å°åŒ–ä¸Šä¸‹æ–‡åˆ‡æ¢å’Œç”¨äºè·¨é€šä¿¡çš„æ“ä½œé—´çš„çº¿ç¨‹é€šä¿¡ã€‚\nä»¥ä¸‹åˆ†æåŸºäº v19.2.1 è¿›è¡Œåˆ†æã€‚\n\n\nä¸€ã€æ¶æ„å¯¹æ¯”Ceph OSD æ˜¯ Ceph é›†ç¾¤çš„ä¸€éƒ¨åˆ†ï¼Œè´Ÿè´£é€šè¿‡ç½‘ç»œæä¾›å¯¹è±¡è®¿é—®ã€ç»´æŠ¤å†—ä½™å’Œé«˜å¯ç”¨æ€§ï¼Œå¹¶å°†å¯¹è±¡æŒä¹…åŒ–åˆ°æœ¬åœ°å­˜å‚¨è®¾å¤‡ã€‚ä½œä¸º Classic OSD çš„é‡å†™ç‰ˆæœ¬ï¼ŒCrimson OSD ä»å®¢æˆ·ç«¯å’Œå…¶ä»– OSD çš„è§’åº¦å…¼å®¹ç°æœ‰çš„ RADOS åè®®ï¼Œæä¾›ç›¸åŒçš„æ¥å£å’ŒåŠŸèƒ½ã€‚Ceph OSD çš„æ¨¡å—ï¼ˆä¾‹å¦‚ Messengerã€OSD æœåŠ¡å’Œ ObjectStoreï¼‰åœ¨å…¶èŒè´£ä¸Šä¿æŒä¸å˜ï¼Œä½†è·¨ç»„ä»¶äº¤äº’çš„å½¢å¼å’Œå†…éƒ¨èµ„æºç®¡ç†ç»è¿‡äº†å¤§å¹…é‡æ„ï¼Œä»¥åº”ç”¨æ— å…±äº«è®¾è®¡å’Œè‡ªä¸‹è€Œä¸Šçš„ç”¨æˆ·ç©ºé—´ä»»åŠ¡è°ƒåº¦ã€‚\nç»å…¸ OSD çš„æ¶æ„å¯¹å¤šæ ¸å¤„ç†å™¨å¹¶ä¸å‹å¥½ï¼Œå› ä¸ºæ¯ä¸ªç»„ä»¶éƒ½åŒ…å«å·¥ä½œçº¿ç¨‹æ± ï¼Œå¹¶ä¸”æ¯ä¸ªç»„ä»¶ä¹‹é—´å…±äº«é˜Ÿåˆ—ã€‚ä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼Œä¸€ä¸ª PG æ“ä½œé¦–å…ˆéœ€è¦ç”±ä¸€ä¸ª Messenger å·¥ä½œçº¿ç¨‹å¤„ç†ï¼Œå°†åŸå§‹æ•°æ®æµç»„è£…æˆ–è§£ç æˆä¸€æ¡æ¶ˆæ¯ï¼Œç„¶åæ”¾å…¥æ¶ˆæ¯é˜Ÿåˆ—è¿›è¡Œè°ƒåº¦ã€‚ä¹‹åï¼Œ PG å·¥ä½œçº¿ç¨‹è·å–è¯¥æ¶ˆæ¯ï¼Œç»è¿‡å¿…è¦çš„å¤„ç†åï¼Œå°†è¯·æ±‚ä»¥äº‹åŠ¡çš„å½¢å¼äº¤ç»™ ObjectStore ã€‚äº‹åŠ¡æäº¤åï¼Œ PG å°†å®Œæˆæ“ä½œï¼Œå¹¶é€šè¿‡å‘é€é˜Ÿåˆ—å’Œ Messenger å·¥ä½œçº¿ç¨‹å†æ¬¡å‘é€å›å¤ã€‚è™½ç„¶å¯ä»¥é€šè¿‡å‘æ± ä¸­æ·»åŠ æ›´å¤šçº¿ç¨‹å°†å·¥ä½œè´Ÿè½½æ‰©å±•åˆ°å¤šä¸ª CPU ï¼Œä½†è¿™äº›çº¿ç¨‹é»˜è®¤å…±äº«èµ„æºï¼Œå› æ­¤éœ€è¦ä½¿ç”¨é”ï¼Œä»è€Œå¼•å…¥äº‰ç”¨ã€‚å®é™…æƒ…å†µä¼šæ›´åŠ å¤æ‚ï¼Œå› ä¸ºæ¯ä¸ªç»„ä»¶å†…éƒ¨éƒ½ä¼šå®ç°æ›´å¤šçš„çº¿ç¨‹æ± ï¼Œå¹¶ä¸”å¦‚æœè·¨ OSD è¿›è¡Œå¤åˆ¶ï¼Œæ•°æ®è·¯å¾„ä¹Ÿä¼šæ›´é•¿ã€‚\n\nç»å…¸æ¶æ„é¢ä¸´çš„ä¸€ä¸ªä¸»è¦æŒ‘æˆ˜æ˜¯ï¼Œé”äº‰ç”¨å¼€é”€ä¼šéšç€ä»»åŠ¡å’Œæ ¸å¿ƒæ•°é‡çš„å¢åŠ è€Œè¿…é€Ÿå¢é•¿ï¼Œå¹¶ä¸”æ¯ä¸ªé”å®šç‚¹åœ¨æŸäº›æƒ…å†µä¸‹éƒ½å¯èƒ½æˆä¸ºæ‰©å±•ç“¶é¢ˆã€‚æ­¤å¤–ï¼Œå³ä½¿åœ¨æ— äº‰ç”¨çš„æƒ…å†µä¸‹ï¼Œè¿™äº›é”å’Œé˜Ÿåˆ—ä¹Ÿä¼šäº§ç”Ÿå»¶è¿Ÿæˆæœ¬ã€‚å¤šå¹´æ¥ï¼Œäººä»¬åœ¨åˆ†æå’Œä¼˜åŒ–æ›´ç»†ç²’åº¦çš„èµ„æºç®¡ç†å’Œå¿«é€Ÿè·¯å¾„å®ç°ä»¥è·³è¿‡æ’é˜Ÿæ–¹é¢ä»˜å‡ºäº†å·¨å¤§çš„åŠªåŠ›ã€‚æœªæ¥å”¾æ‰‹å¯å¾—çš„æˆæœå°†ä¼šå‡å°‘ï¼Œåœ¨ç±»ä¼¼çš„è®¾è®¡ä¸‹ï¼Œå¯æ‰©å±•æ€§ä¼¼ä¹æ­£åœ¨æ”¶æ•›åˆ°æŸä¸ªä¹˜æ•°ã€‚æ­¤å¤–ï¼Œè¿˜å­˜åœ¨å…¶ä»–æŒ‘æˆ˜ã€‚ç”±äºç°¿è®°å·¥ä½œä¼šåœ¨å·¥ä½œçº¿ç¨‹ä¹‹é—´å§”æ´¾ä»»åŠ¡ï¼Œå»¶è¿Ÿé—®é¢˜å°†éšç€çº¿ç¨‹æ± å’Œä»»åŠ¡é˜Ÿåˆ—çš„å‡ºç°è€Œæ¶åŒ–ã€‚é”å¯èƒ½ä¼šå¼ºåˆ¶ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œè¿™ä¼šä½¿æƒ…å†µæ›´åŠ ç³Ÿç³•ã€‚\nCrimson é¡¹ç›®å¸Œæœ›é€šè¿‡æ— å…±äº«è®¾è®¡å’Œè¿è¡Œè‡³å®Œæˆæ¨¡å‹æ¥è§£å†³ CPU çš„å¯æ‰©å±•æ€§é—®é¢˜ã€‚è¯¥è®¾è®¡çš„åŸºæœ¬åŸç†æ˜¯å¼ºåˆ¶æ¯ä¸ªæ ¸å¿ƒï¼ˆæˆ– CPUï¼‰è¿è¡Œä¸€ä¸ªå›ºå®šçº¿ç¨‹ï¼Œå¹¶åœ¨ç”¨æˆ·ç©ºé—´ä¸­è°ƒåº¦éé˜»å¡ä»»åŠ¡ã€‚è¯·æ±‚åŠå…¶èµ„æºæŒ‰æ ¸å¿ƒè¿›è¡Œåˆ†ç‰‡ï¼Œå› æ­¤å®ƒä»¬å¯ä»¥åœ¨åŒä¸€æ ¸å¿ƒä¸­å¤„ç†ç›´è‡³å®Œæˆã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œæ‰€æœ‰é”å’Œä¸Šä¸‹æ–‡åˆ‡æ¢éƒ½ä¸å†éœ€è¦ï¼Œå› ä¸ºæ¯ä¸ªæ­£åœ¨è¿è¡Œçš„éé˜»å¡ä»»åŠ¡éƒ½æ‹¥æœ‰ CPUï¼Œç›´åˆ°å…¶å®Œæˆæˆ–ååŒè®©å‡ºã€‚æ²¡æœ‰å…¶ä»–çº¿ç¨‹å¯ä»¥åŒæ—¶æŠ¢å è¯¥ä»»åŠ¡ã€‚å¦‚æœæ— éœ€ä¸æ•°æ®è·¯å¾„ä¸­çš„å…¶ä»–åˆ†ç‰‡é€šä¿¡ï¼Œåˆ™ç†æƒ³çš„æ€§èƒ½å°†éšç€æ ¸å¿ƒæ•°é‡çº¿æ€§æ‰©å±•ï¼Œç›´åˆ° IO è®¾å¤‡è¾¾åˆ°å…¶æé™ã€‚è¿™ç§è®¾è®¡éå¸¸é€‚åˆ Ceph OSDï¼Œå› ä¸ºåœ¨ OSD çº§åˆ«ï¼Œæ‰€æœ‰ IO éƒ½å·²æŒ‰ PG åˆ†ç‰‡ã€‚\n\näºŒã€é…ç½®è§£ææµç¨‹é…ç½®è§£æçš„ä»£ç ä½äº src/crimson/osd/main.cc æ–‡ä»¶ä¸­çš„ auto early_config_result = crimson::osd::get_early_config(argc, argv); å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¸»è¦é€»è¾‘å¦‚ä¸‹:\n\nåˆ›å»ºä¸€ä¸ªå­è¿›ç¨‹ï¼Œåœ¨å­è¿›ç¨‹ä¸­å°è¯•è§£æå‚æ•°åï¼Œå°†å‚æ•°ç¼–ç åé€šè¿‡ç®¡é“ä¼ é€’ç»™çˆ¶è¿›ç¨‹ï¼›\nçˆ¶è¿›ç¨‹è§£æå¹¶è¿”å›å‚æ•°ç»™ main å‡½æ•°ä¸­ï¼›\n\nå­è¿›ç¨‹åœ¨ _get_early_config å‡½æ•°ä¸­è§£æå‚æ•°ï¼Œå…¶ä¸­ ceph ç›¸å…³çš„å‚æ•°ä½¿ç”¨ ceph_argparse_early_args å‡½æ•°è§£æï¼Œå¹¶ä¸”æ ¹æ® ceph çš„ crimson_seastar_cpu_cores å‚æ•°æ¥è®¾ç½® --cpuset $cpu_cores --thread-affinity 1 ï¼›æˆ–è€…æ ¹æ® ceph çš„ crimson_seastar_num_threads å‚æ•°æ¥è®¾ç½® --smp $smp --thread-affinity 0ã€‚æ³¨æ„ crimson_seastar_cpu_cores å‚æ•°çš„ä¼˜å…ˆçº§é«˜äº crimson_seastar_num_threads å‚æ•°ã€‚\nä¹‹å main å‡½æ•°ä¸­é€šè¿‡ app.run å‡½æ•°è°ƒç”¨ï¼Œå°†è§£æåˆ°çš„å‚æ•°ä¼ é€’ç»™ seastar ï¼Œè¿›è€Œè®¾ç½®äº† seastar è¦å¯åŠ¨çš„ shard çš„æ•°é‡åŠç»‘å®š cpu çš„é…ç½®ã€‚ä½†æ˜¯ç”±äºç›®å‰ main ä¸­çš„ seastar::async å‡½æ•°é€»è¾‘ä¸­æ²¡æœ‰æ˜¾ç¤ºçš„ä½¿ç”¨ seastar::smp::count æ¥å°†ä»»åŠ¡åˆ†å‘ç»™å¤šä¸ª shard æ‰§è¡Œï¼Œå› æ­¤å…³äºæ—¥å¿—çš„é…ç½®ï¼Œprometheus çš„é…ç½®ï¼Œcrimson osd çš„å¯¹è±¡å‡æ˜¯åœ¨ shard 0 ï¼ˆå³ PRIMARY_CORE ï¼‰ä¸Šæ‰§è¡Œçš„ã€‚\nä¸‰ã€ç½‘ç»œé€šä¿¡æµç¨‹åœ¨ crimson osd è¿›ç¨‹å¯åŠ¨çš„æ—¶å€™ï¼Œä¼šè°ƒç”¨ OSD::start() å‡½æ•°ï¼Œå…¶å†…éƒ¨ä¼šå¯¹ public_msgr å’Œ cluster_msgr ä¸¤ä¸ªå¯¹è±¡æ‰§è¡Œ bind å’Œ start æ“ä½œã€‚\n\nbind æ“ä½œ: å¯¹åº”çš„å‡½æ•°ä¸º SocketMessenger::bind ï¼Œ è¯¥å‡½æ•°å†…éƒ¨æœ€ç»ˆé€šè¿‡è°ƒç”¨ seastar çš„ invoke_on_all ä¸‹å‘ seastar::listen(s_addr, lo) æ“ä½œç»™æ‰€æœ‰ shard ï¼Œä½¿æ‰€æœ‰çš„ shard å¼€å§‹ç›‘å¬ç›¸åŒçš„ç«¯å£ï¼›\nstart æ“ä½œ: å¯¹åº”çš„å‡½æ•°ä¸º SocketMessenger::start ï¼Œ è¯¥å‡½æ•°å†…éƒ¨é€šè¿‡è°ƒç”¨ ShardedServerSocket::accept ï¼Œå¹¶åœ¨å…¶å†…éƒ¨è°ƒç”¨ seastar çš„ invoke_on_all æ–¹æ³•ä½¿æ¯ä¸ª shard æ¥æ”¶æ–°è¿æ¥è¯·æ±‚ã€‚æ¯ä¸ª shard æ¥æ”¶åˆ°è¯·æ±‚åï¼Œä¼šé€æ­¥è°ƒç”¨ SocketMessenger::accept &#x3D;&gt; SocketConnection::start_accept &#x3D;&gt; ProtocolV2::start_accept &#x3D;&gt; ProtocolV2::execute_accepting ç­‰å‡½æ•°é€æ­¥å¤„ç†è¯·æ±‚ï¼Œæœ€ç»ˆä¼šè°ƒç”¨åˆ° OSD::do_ms_dispatch å‡½æ•°æ­£å¼å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚ã€‚\n\nåœ¨ OSD::do_ms_dispatch å‡½æ•°å†…éƒ¨ï¼Œé’ˆå¯¹äºè¯·æ±‚æ¶ˆæ¯çš„ç±»å‹ï¼Œæœ‰å¦‚ä¸‹æ“ä½œï¼š\n\nå¿…é¡»åœ¨ PRIMARY_CORE shard ä¸Šæ‰§è¡Œçš„æ“ä½œ: åŒ…æ‹¬ CEPH_MSG_OSD_MAPã€MSG_COMMANDã€MSG_OSD_MARK_ME_DOWN ç­‰ï¼›\nå…¶ä»–å¯ä»¥åœ¨ä»»æ„ shard ä¸Šæ‰§è¡Œçš„æ“ä½œï¼šåŒ…æ‹¬ CEPH_MSG_OSD_MAPã€CEPH_MSG_OSD_OPã€MSG_COMMAND ç­‰ï¼›\n\n\n\nç”±äº OSD ä¸­çš„æ¯ä¸ª Shard éƒ½ä¼šç›‘å¬ç½‘ç»œä¿¡æ¯ï¼Œæ‰€ä»¥æ¯ä¸ª Shard éƒ½å¯ä»¥å¤„ç†ç½‘ç»œè¯·æ±‚ï¼›\nä½†æ˜¯ç”±äºéœ€è¦å¯¹è¯·æ±‚æŒ‰ç…§ PG æ˜ å°„åˆ° Shard ä¸­ï¼Œæ‰€ä»¥å†…éƒ¨å¼•å…¥äº† pg_to_shard_mapping çš„æ˜ å°„ç»“æ„ï¼Œæ¯ä¸ªè¯·æ±‚éƒ½éœ€è¦åœ¨ Shard ä¸­æ£€ç´¢æ˜ å°„è¡¨ï¼›\nå¦‚æœå½“å‰ Shard ä¸­çš„æ˜ å°„è¡¨ä¸­ç¼ºå°‘ PG çš„æ˜ å°„ä¿¡æ¯ï¼Œä¼šå°†è¯·æ±‚å‘é€ç»™ Shard 0 æ¥å°è¯•åˆ›å»ºå¯¹åº”çš„æ˜ å°„è®°å½•ï¼Œå¹¶å°†è¯¥è®°å½•å¹¿æ’­ç»™æ‰€æœ‰çš„ Shard ï¼›\n\nå¯¹äºè¯·æ±‚ç±»å‹ä¸º CEPH_MSG_OSD_OP çš„å…³é”®ä»£ç é“¾è·¯å¦‚ä¸‹:\nc// å¤„ç†å¯¹åº”çš„ op è¯·æ±‚seastar::future&lt;&gt; OSD::handle_osd_op(crimson::net::ConnectionRef conn, Ref&lt;MOSDOp&gt; m)&#123;    return pg_shard_manager.start_pg_operation&lt;ClientRequest&gt;(get_shard_services(), conn, std::move(m)).second;&#125;// å¼€å§‹ pg æ“ä½œtemplate&lt;typename T, typename... Args&gt; auto start_pg_operation(Args&amp;&amp;... args)&#123;......    auto fut =        opref.template enter_stage&lt;&gt;(opref.get_connection_pipeline().await_active)            ......            // ä» pg_to_shard_mapping ä¸­è·å– pg ä¸ shard çš„å¯¹åº”å…³ç³»ï¼Œ            // å¦‚æœå¯¹åº”çš„æ˜ å°„å…³ç³»ä¸å­˜åœ¨ï¼Œåˆ™æ ¹æ®å„ shard çš„è´Ÿè½½æƒ…å†µåˆ›å»ºæ˜ å°„å…³ç³»ã€‚            .then([this, &amp;opref] &#123; return get_pg_to_shard_mapping().get_or_create_pg_mapping(opref.get_pgid()); &#125;)            .then_wrapped([this, &amp;logger, op = std::move(op)](auto fut) mutable &#123;                ......                auto core = fut.get();                logger.debug(&quot;&#123;&#125;: can_create=&#123;&#125;, target-core=&#123;&#125;&quot;, *op, T::can_create(), core);                // å¤„ç†å·²çŸ¥ shard id çš„ op è¯·æ±‚                return this-&gt;template with_remote_shard_state_and_op&lt;T&gt;(                    core, std::move(op), [this](ShardServices&amp; target_shard_services, typename T::IRef op) &#123;                        auto&amp; opref = *op;                        auto&amp; logger = crimson::get_logger(ceph_subsys_osd);                        logger.debug(&quot;&#123;&#125;: entering create_or_wait_pg&quot;, opref);                        return opref                            .template enter_stage&lt;&gt;(                                opref.get_pershard_pipeline(target_shard_services).create_or_wait_pg)                            .then([this, &amp;target_shard_services, op = std::move(op)]() mutable &#123;                                if constexpr (T::can_create()) &#123;                                    return this-&gt;template run_with_pg_maybe_create&lt;T&gt;(std::move(op),                                                                                        target_shard_services);                                &#125;                                else &#123;                                    return this-&gt;template run_with_pg_maybe_wait&lt;T&gt;(std::move(op),                                                                                    target_shard_services);                                &#125;                            &#125;);                    &#125;);            &#125;);    return std::make_pair(id, std::move(fut));&#125;// è·å–æˆ–åˆ›å»º pg å’Œ shard çš„æ˜ å°„å…³ç³»seastar::future&lt;core_id_t&gt; PGShardMapping::get_or_create_pg_mapping(spg_t pgid, core_id_t core_expected)&#123;    LOG_PREFIX(PGShardMapping::get_or_create_pg_mapping);    auto find_iter = pg_to_core.find(pgid);    if (find_iter != pg_to_core.end()) &#123;        auto core_found = find_iter-&gt;second;        // ä¸€äº›æ ¡éªŒé€»è¾‘        assert(core_found != NULL_CORE);        if (core_expected != NULL_CORE &amp;&amp; core_expected != core_found) &#123;            ERROR(&quot;the mapping is inconsistent for pg &#123;&#125;: core &#123;&#125;, expected &#123;&#125;&quot;, pgid, core_found, core_expected);            ceph_abort(&quot;The pg mapping is inconsistent!&quot;);        &#125;        return seastar::make_ready_future&lt;core_id_t&gt;(core_found);    &#125;    else &#123;        DEBUG(&quot;calling primary to add mapping for pg &#123;&#125; to the expected core &#123;&#125;&quot;, pgid, core_expected);        // å¦‚æœæ²¡æœ‰æ‰¾åˆ° pg å’Œ shard çš„æ˜ å°„å…³ç³»ï¼Œåˆ™éœ€è¦åˆ›å»ºæ˜ å°„ï¼Œ        // åˆ›å»ºæ“ä½œå¿…é¡»ç”± shard 0 æ‰§è¡Œã€‚        return container()            .invoke_on(                0,                [pgid, core_expected, FNAME](auto&amp; primary_mapping) &#123;                    auto core_to_update = core_expected;                    // åœ¨ shard 0 ä¸­åˆ¤æ–­å¯¹åº”çš„æ˜ å°„å…³ç³»æ˜¯å¦å­˜åœ¨ï¼Œ                    // å¦‚æœå­˜åœ¨ä¸”æ ¡éªŒæ­£å¸¸åˆ™å¯ä½¿ç”¨è¯¥æ˜ å°„å…³ç³»                    auto find_iter = primary_mapping.pg_to_core.find(pgid);                    if (find_iter != primary_mapping.pg_to_core.end()) &#123;                        ......                    &#125;                    else &#123;                        // å¦‚æœåœ¨ shard 0 ä¸­ä¹Ÿæ²¡æœ‰æ‰¾åˆ°æ˜ å°„å…³ç³»ï¼Œåˆ™åˆ›å»ºæ˜ å°„                        ceph_assert_always(primary_mapping.core_to_num_pgs.size() &gt; 0);                        std::map&lt;core_id_t, unsigned&gt;::iterator count_iter;                        if (core_expected == NULL_CORE) &#123;                            // ä» shard ä¸­é€‰æ‹© pg æ˜ å°„æ•°é‡æœ€å°‘çš„æœ€ä¸ºå½“å‰ pg çš„å…³è” shard                            count_iter = std::min_element(                                primary_mapping.core_to_num_pgs.begin(),                                primary_mapping.core_to_num_pgs.end(),                                [](const auto&amp; left, const auto&amp; right) &#123; return left.second &lt; right.second; &#125;);                            core_to_update = count_iter-&gt;first;                        &#125;                        ......                    &#125;                    assert(core_to_update != NULL_CORE);                    // å¹¿æ’­åŒæ­¥                    // é€šè¿‡ invoke_on_others ç¡®ä¿æ‰€æœ‰ Core çš„æ˜ å°„è¡¨åŒæ­¥æ›´æ–°                    // å°†å˜æ›´çš„æ˜ å°„å…³ç³»å¹¿æ’­ç»™å…¶ä»–æ‰€æœ‰çš„ shard                    return primary_mapping.container().invoke_on_others(                        [pgid, core_to_update, FNAME](auto&amp; other_mapping) &#123;                            ......                        &#125;);                &#125;)                ......    &#125;&#125;// å¤„ç† op è¯·æ±‚template&lt;typename T, typename F&gt; auto with_remote_shard_state_and_op(core_id_t core, typename T::IRef&amp;&amp; op, F&amp;&amp; f)&#123;    ceph_assert(op-&gt;use_count() == 1);    // å¦‚æœ op è¯·æ±‚çš„ç›®æ ‡ shard ä¸ºå½“å‰ shard ï¼Œåˆ™åœ¨å½“å‰ shard ä¸­å¤„ç†    if (seastar::this_shard_id() == core) &#123;        auto f_conn = op-&gt;prepare_remote_submission();        op-&gt;finish_remote_submission(std::move(f_conn));        auto&amp; target_shard_services = shard_services.local();        return std::invoke(std::move(f), target_shard_services, std::move(op));    &#125;    ......    // å¦åˆ™ï¼Œå°†å¯¹åº”çš„ op è¯·æ±‚è½¬å‘ç»™å¯¹åº”çš„ shard å¤„ç†    logger.debug(&quot;&#123;&#125;: send &#123;&#125; to the remote pg core &#123;&#125;&quot;, opref, cc_seq, core);    return opref.get_handle().complete().then([this, core, cc_seq, op = std::move(op), f = std::move(f)]() mutable &#123;        get_local_state().registry.remove_from_registry(*op);        auto f_conn = op-&gt;prepare_remote_submission();        return shard_services.invoke_on(            core,            [this, cc_seq, f = std::move(f), op = std::move(op), f_conn = std::move(f_conn)](                auto&amp; target_shard_services) mutable &#123;                op-&gt;finish_remote_submission(std::move(f_conn));                target_shard_services.local_state.registry.add_to_registry(*op);                return this-&gt;template process_ordered_op_remotely&lt;T&gt;(                    cc_seq, target_shard_services, std::move(op), std::move(f));            &#125;);    &#125;);&#125;\n\nå››ã€çº¿ç¨‹æ¨¡å‹åœ¨æœåŠ¡å¯åŠ¨æ—¶ä¼šé€šè¿‡è§£æ crimson_seastar_cpu_cores æˆ– crimson_seastar_num_threads è¿™ä¸¤ä¸ªé…ç½®æ¥è®¾ç½® seastar æ¡†æ¶çš„å¹¶å‘ shard æ•°é‡ï¼Œä¹‹ååœ¨ PRIMARY_CORE åˆå§‹åŒ–ç¯å¢ƒï¼Œå¹¶é€šè¿‡ seastar çš„ invoke_onã€invoke_on_othersã€invoke_on_allã€seastar::smp::submit_to ç­‰æ–¹æ³•æ¥ç»™ shard ä¸‹å‘ä»»åŠ¡ï¼Œä»è€Œå®ç° osd ä¸­ç›¸äº’ç‹¬ç«‹çš„ shard ä»»åŠ¡æ¨¡å‹ã€‚\n4.1ã€shard ç›¸å…³ä»»åŠ¡seastar æä¾›çš„ä¸åŒçš„ä¸‹å‘ä»»åŠ¡çš„æ–¹æ³•æ¯”è¾ƒ:\n\n\n\næ¥å£\nç›®æ ‡ Shard\næ˜¯å¦ä¾èµ– sharded å®¹å™¨\nå…¸å‹ç”¨é€”\n\n\n\ninvoke_on\næŒ‡å®šå•ä¸ª Shard\næ˜¯\nè®¿é—®ç‰¹å®š Shard ä¸Šçš„å¯¹è±¡\n\n\ninvoke_on_others\né™¤å½“å‰ Shard å¤–çš„æ‰€æœ‰\næ˜¯\nå¹¿æ’­æ“ä½œï¼ˆæ’é™¤å½“å‰ Shardï¼‰\n\n\ninvoke_on_all\næ‰€æœ‰ Shardï¼ˆåŒ…æ‹¬å½“å‰ï¼‰\næ˜¯\nå…¨å±€åˆå§‹åŒ–&#x2F;æ¸…ç†\n\n\nsmp::submit_to\næŒ‡å®šå•ä¸ª Shard\nå¦\nä»»æ„è·¨ Shard ä»»åŠ¡\n\n\ninvoke_on çš„éƒ¨åˆ†æ“ä½œå¦‚ä¸‹:\nc// æ›´æ–°é…ç½®å€¼å¹¶é€šçŸ¥æ‰€æœ‰è§‚å¯Ÿè€…container().invoke_on(...)// åœ¨ 0 å· shard ä¸Šåœæ­¢ shardsthis-&gt;container().invoke_on(0, [](auto&amp; ss) &#123; ... &#125;)// åœ¨ 0 å· shard ä¸Šæ–°å¢ pg å’Œ shard çš„æ˜ å°„å…³ç³»container().invoke_on(0, [pgid, core_expected, FNAME](auto&amp;// åœ¨ 0 å· shard ä¸Šç§»é™¤ pg å’Œ shard çš„æ˜ å°„å…³ç³»container().invoke_on(0, [pgid, FNAME](auto&amp; primary_mapping) &#123; ... &#125;)// è½¬å‘è¯·æ±‚ç»™ç‰¹å®š shardshard_services.invoke_on(core, ... )\n\ninvoke_on_others çš„éƒ¨åˆ†æ“ä½œå¦‚ä¸‹:\nc// æ›´æ–° proxy é…ç½®container().invoke_on_others(...)// å¹¿æ’­ pg shard æ–°å¢æ˜ å°„è®°å½•primary_mapping.container().invoke_on_others(...)// å¹¿æ’­ pg shard ç§»é™¤æ˜ å°„è®°å½•primary_mapping.container().invoke_on_others(...)\n\ninvoke_on_all çš„éƒ¨åˆ†æ“ä½œå¦‚ä¸‹:\ncseastar::listenss.listener-&gt;accept()ss.listener-&gt;abort_accept()ss.listener.reset()local_store.mkfs()local_store.mount()local_store.umount()local_store.mount_managers()local_store.set_secondaries(...)local_store.mkfs_managers()local_device.do_shard_mount()local_device.shard_mount()local_device.shard_mkfs()local_service.local_state.stop_pgs()local_service.local_state.broadcast_map_to_pgs(local_service, epoch)local_service.local_state.osdmap_gate.got_map(epoch)local_service.local_state.set_up_epoch(e)local_service.local_state.update_shard_superblock(superblock)local.local_state.update_map(...)local.local_state.stop_registry()osd_state._set_active()osd_state._set_stopping()\n\nseastar::smp::submit_to çš„éƒ¨åˆ†æ“ä½œå¦‚ä¸‹:\nc// åœ¨ shard 0 ä¸Šå¤„ç† CEPH_MSG_OSD_MAP/MSG_COMMAND/MSG_OSD_MARK_ME_DOWN æ¶ˆæ¯seastar::smp::submit_to(PRIMARY_CORE, ... )\n\n4.2ã€çº¿ç¨‹ç¤ºä¾‹å½“ crimson_seastar_num_threads è®¾ç½®ä¸º 2 çš„æ—¶å€™ï¼Œcrimson osd çš„çº¿ç¨‹æƒ…å†µ:\nbash[root@bugwz.host build]# ps -T -p 270088    PID    SPID TTY          TIME CMD 270088  270088 pts/11   00:30:31 crimson-osd 270088  270130 pts/11   00:22:41 reactor-1 270088  270131 pts/11   00:00:00 syscall-0 270088  270132 pts/11   00:00:00 syscall-1 270088  270133 pts/11   00:00:00 crimson-osd 270088  270134 pts/11   00:00:00 reactor-1\n\nå½“ crimson_seastar_num_threads è®¾ç½®ä¸º 8 çš„æ—¶å€™ï¼Œcrimson osd çš„çº¿ç¨‹æƒ…å†µ:\nbash[root@bugwz.host build]# ps -T -p 345103    PID    SPID TTY          TIME CMD 345103  345103 pts/15   00:00:04 crimson-osd 345103  345145 pts/15   00:00:02 reactor-1 345103  345146 pts/15   00:00:02 reactor-2 345103  345147 pts/15   00:00:02 reactor-3 345103  345148 pts/15   00:00:02 reactor-4 345103  345149 pts/15   00:00:02 reactor-5 345103  345150 pts/15   00:00:02 reactor-6 345103  345151 pts/15   00:00:02 reactor-7 345103  345152 pts/15   00:00:00 syscall-7 345103  345153 pts/15   00:00:00 syscall-0 345103  345154 pts/15   00:00:00 syscall-4 345103  345155 pts/15   00:00:00 syscall-3 345103  345156 pts/15   00:00:00 syscall-2 345103  345157 pts/15   00:00:00 syscall-5 345103  345158 pts/15   00:00:00 syscall-1 345103  345159 pts/15   00:00:00 syscall-6 345103  345160 pts/15   00:00:00 crimson-osd 345103  345161 pts/15   00:00:00 reactor-1 345103  345162 pts/15   00:00:00 reactor-4 345103  345163 pts/15   00:00:00 reactor-5 345103  345164 pts/15   00:00:00 reactor-6 345103  345165 pts/15   00:00:00 reactor-7 345103  345166 pts/15   00:00:00 reactor-2 345103  345167 pts/15   00:00:00 reactor-3\n\näº”ã€å­˜å‚¨æ¨¡å—è®¾è®¡5.1ã€åç«¯å¯¹è±¡å­˜å‚¨ç±»å‹main å‡½æ•°ä¸­ä¼šé€šè¿‡ crimson::os::FuturizedStore::create å‡½æ•°æ¥åˆ›å»º store å¯¹è±¡ã€‚æ ¹æ® osd_objectstore å’Œ osd_data å‚æ•°æ¥é…ç½® store å¯¹è±¡ã€‚å…¶ä¸­ osd_objectstore å‚æ•°æŒ‡å®šäº†åç«¯å¯¹è±¡å­˜å‚¨çš„ç±»å‹ï¼Œæ”¯æŒçš„å‚æ•°æœ‰ alienstore/cyanstore/seastore ï¼Œé»˜è®¤ä¸º alienstore ï¼ˆå³åç«¯å­˜å‚¨ä¸º bluestore ï¼‰ã€‚å…¶ä¸­ osd_data å‚æ•°æŒ‡å®šäº†æ•°æ®å­˜å‚¨ç›®å½•ï¼ˆæ¯”å¦‚å½“ä½¿ç”¨ vstart.sh éƒ¨ç½²é›†ç¾¤æ—¶ï¼Œå¯¹åº”çš„é…ç½®é»˜è®¤ä¸º ./build/dev/osd$id ï¼‰ã€‚\nå¯¹è±¡å­˜å‚¨ç±»å‹:\n\nalienstore: æ˜¯ seastar çº¿ç¨‹ä¸­çš„ä¸€ä¸ªä»£ç†ï¼Œä¸»è¦æ˜¯ä¸ bluestore è¿›è¡Œé€šä¿¡ã€‚ç”±äº io ä»»åŠ¡ä¼šä¸ bluestore è¿›è¡Œé€šä¿¡ï¼Œå› æ­¤æ— éœ€é’ˆå¯¹å¤šä¸ª osd åˆ†ç‰‡è¿›è¡Œç‰¹æ®Šå¤„ç†ã€‚BlueStore ä¸­æ²¡æœ‰é’ˆå¯¹ crimson çš„å®šåˆ¶ï¼Œå› ä¸º bluestore ä¾èµ–äºç¬¬ä¸‰æ–¹ RocksDB é¡¹ç›®ï¼Œè€Œè¯¥é¡¹ç›®ä»ç„¶é‡‡ç”¨çº¿ç¨‹åŒ–è®¾è®¡ï¼Œå› æ­¤æ— æ³•çœŸæ­£å°†å…¶æ‰©å±•ä¸ºæ— å…±äº«è®¾è®¡ã€‚ç„¶è€Œï¼Œåœ¨ crimson èƒ½å¤Ÿæä¾›ç»è¿‡ä¼˜åŒ–ä¸”è¶³å¤Ÿç¨³å®šçš„åŸç”Ÿå­˜å‚¨åç«¯ seastore ä¹‹å‰ï¼Œä½¿ç”¨åˆç†çš„å¼€é”€æ¥æ¢å–å®Œå–„çš„å­˜å‚¨åç«¯è§£å†³æ–¹æ¡ˆæ˜¯å¯ä»¥æ¥å—çš„ã€‚\ncyanstore: crimson osd ä¸­çš„ cyanstore ä¸ classic osd ä¸­çš„ memstore ç›¸å¯¹åº”ã€‚ä¸ºäº†æ”¯æŒå¤šåˆ†ç‰‡ï¼Œå”¯ä¸€çš„å˜åŒ–æ˜¯æ¯ä¸ªåˆ†ç‰‡åˆ›å»ºç‹¬ç«‹çš„ cyanstore å®ä¾‹ã€‚ä¸€ä¸ªç›®æ ‡æ˜¯ç¡®ä¿è™šæ‹Ÿ IO æ“ä½œèƒ½å¤Ÿåœ¨åŒä¸€æ ¸å¿ƒä¸­å®Œæˆï¼Œä»¥å¸®åŠ©è¯†åˆ« osd çº§åˆ«çš„å¯æ‰©å±•æ€§é—®é¢˜ï¼ˆå¦‚æœæœ‰ï¼‰ã€‚å¦ä¸€ä¸ªç›®æ ‡æ˜¯åœ¨ osd çº§åˆ«ä¸ Classic è¿›è¡Œç›´æ¥æ€§èƒ½æ¯”è¾ƒï¼Œè€Œä¸ä¼šå—åˆ° objectstore çš„å¤æ‚å½±å“ã€‚\nseastore: seastore æ˜¯ crimson osd çš„åŸç”Ÿ objectstore è§£å†³æ–¹æ¡ˆï¼Œå®ƒä½¿ç”¨ seastar æ¡†æ¶å¼€å‘å¹¶é‡‡ç”¨ç›¸åŒçš„è®¾è®¡åŸåˆ™ã€‚\n\nåœ¨ seastore åˆå§‹åŒ–çš„æ—¶å€™ï¼Œä¼šæ ¹æ® seastore_main_device_type å‚æ•°æ¥åˆå§‹åŒ– seastore ä¸»è®¾å¤‡ï¼Œè¯¥å‚æ•°å¯é€‰å€¼ä¸º SSD/RANDOM_BLOCK_SSD ï¼ˆä»£ç ä¸­è¿˜å®ç°äº† HDD/ZBD ï¼Œä½†æ˜¯ç›®å‰å¹¶ä¸æ”¯æŒï¼‰ ï¼Œé»˜è®¤ä¸º SSD ã€‚ åœ¨è°ƒç”¨ Device::make_device(root, d_type) å‡½æ•°åˆ›å»º device çš„è¿‡ç¨‹ä¸­ï¼Œä¼šé’ˆå¯¹ä¸åŒçš„è®¾å¤‡ç±»å‹åˆåšäº†ä¸€äº›åŒºåˆ†ã€‚\nseastore è®¾å¤‡ç±»å‹å¯¹æ¯”:\n\n\n\ndevice_type\nbackend_type\ncreate func\n\n\n\nHDD\nbackend_type_t::SEGMENTED\nSegmentManager::get_segment_manager\n\n\nSSD\nbackend_type_t::SEGMENTED\nSegmentManager::get_segment_manager\n\n\nZBD\nbackend_type_t::SEGMENTED\nSegmentManager::get_segment_manager\n\n\nRANDOM_BLOCK_SSD\nbackend_type_t::RANDOM_BLOCK\nget_rb_device\n\n\n5.2ã€æ®µå­˜å‚¨æ ¼å¼ä¿¡æ¯å½“ä½¿ç”¨ vstart.sh è„šæœ¬éƒ¨ç½²æµ‹è¯•é›†ç¾¤åä¼šå‘ç° build/dev/osd*/ ç›®å½•ä¸‹ä¼šå­˜åœ¨ä¸€ä¸ª block æ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶å¯¹åº”çš„å°±æ˜¯ä¸€ä¸ª osd ç»„ä»¶åç«¯çš„å¯¹è±¡å­˜å‚¨ï¼Œç”±äºä¸€ä¸ª osd ä¸­å¯èƒ½ä¼šå¯ç”¨å¤šä¸ª seastar shard ï¼Œå¹¶ä¸”ç”±äº shard é—´æ•°æ®çš„éš”ç¦»ï¼Œå› æ­¤éœ€è¦å¯¹è¿™å¤§å—å­˜å‚¨ç©ºé—´è¿›è¡Œåˆ‡å‰²ï¼Œä½¿æ¯ä¸ª shard å„è´Ÿè´£ä¸€å—ç©ºé—´ï¼Œä»è€Œå®ç°æ“ä½œæ•°æ®çš„éš”ç¦»ã€‚\nåç«¯å­˜å‚¨çš„æ ¼å¼åŒ–è§„åˆ™:\n\nå¼€å§‹éƒ¨åˆ†ä¸º superblock ç©ºé—´ï¼Œå­˜å‚¨è¿™ä¸ªè¯¥å­˜å‚¨ç©ºé—´çš„è§„åˆ’åŠä½¿ç”¨ä¿¡æ¯ï¼›\nå‰©ä½™ç©ºé—´å¹³å‡åˆ†é…ç»™æ¯ä¸ª shard ï¼Œå®ç°ç‹¬ç«‹çš„æ“ä½œç©ºé—´ï¼›\n\nåˆ›å»º superblock åŠ shard ç©ºé—´è§„åˆ’å‡½æ•°å¦‚ä¸‹:\ncusing std::vector;static block_sm_superblock_t make_superblock(device_id_t device_id, device_config_t sm_config, const seastar::stat_data&amp; data)&#123;    LOG_PREFIX(block_make_superblock);    using crimson::common::get_conf;    // seastore_device_size é»˜è®¤ä¸º 50G    auto config_size = get_conf&lt;Option::size_t&gt;(&quot;seastore_device_size&quot;);    size_t size = (data.size == 0) ? config_size : data.size;    // å•ä¸ª segment çš„å¤§å°ï¼Œé»˜è®¤ä¸º 64M    auto config_segment_size = get_conf&lt;Option::size_t&gt;(&quot;seastore_segment_size&quot;);    // è®¡ç®— segment æ•°é‡ï¼š æ€»å¤§å°é™¤ä»¥å•ä¸ª segment çš„å¤§å°    size_t raw_segments = size / config_segment_size;    // è®¡ç®—æ¯ä¸ª shard æ‰€éœ€è¦çš„æ®µçŠ¶æ€è·Ÿè¸ªå™¨å¤§å°    // é»˜è®¤ä¸ºä¸€ä¸ª data.block_size å¤§å°ï¼Œå¦‚æœè®¡ç®—å‡ºçš„æ¯ä¸ª shard æ‰€ç®¡ç†çš„ segments æ•°é‡è¶…è¿‡ data.block_size å¤§å°ï¼Œ    // åˆ™è¿”å›è¶…è¿‡ segments æ•°é‡çš„ data.block_size çš„å€æ•°å€¼ã€‚    //    // seastar::smp::count ä¸º crimson osd å¯åŠ¨æ—¶æŒ‡å®šçš„ shard æ•°é‡    // data.block_size é»˜è®¤ä¸º 4096    size_t shard_tracker_size = SegmentStateTracker::get_raw_size(raw_segments / seastar::smp::count, data.block_size);    // è®¡ç®—å…¨éƒ¨ shard çš„æ®µçŠ¶æ€è·Ÿè¸ªå™¨çš„æ€»å¤§å°    size_t total_tracker_size = shard_tracker_size * seastar::smp::count;    // åˆå§‹çš„åç§»åº”è¯¥ä» superblock ä¹‹åå¼€å§‹    size_t tracker_off = data.block_size;    // è®¡ç®—å‡å» superblock åŠæ‰€æœ‰æ®µçŠ¶æ€è·Ÿè¸ªå™¨æ€»å¤§å°ä¹‹åçš„å‰©ä½™ç©ºé—´å¯åˆ†é…çš„ segments æ•°é‡    size_t segments = (size - tracker_off - total_tracker_size) / config_segment_size;    // è®¡ç®—æ¯ä¸ª shard å¯åˆ†é…çš„ segments æ•°é‡    size_t segments_per_shard = segments / seastar::smp::count;    // åˆå§‹åŒ–æ¯ä¸ª shard ä¿¡æ¯    vector&lt;block_shard_info_t&gt; shard_infos(seastar::smp::count);    for (unsigned int i = 0; i &lt; seastar::smp::count; i++) &#123;        // æ¯ä¸ª shard ç®¡ç†çš„ segments æ€»å¤§å°        shard_infos[i].size = segments_per_shard * config_segment_size;        // æ¯ä¸ª shard ç®¡ç†çš„ segments æ•°é‡        shard_infos[i].segments = segments_per_shard;        // æ ‡è®°æ¯ä¸ª shard çš„æ®µçŠ¶æ€è·Ÿè¸ªå™¨çš„åœ¨å…¨éƒ¨ç©ºé—´ä¸­çš„åç§»        shard_infos[i].tracker_offset = tracker_off + i * shard_tracker_size;        // æ ‡è®°æ¯ä¸ª shard çš„ segment æ•°æ®èµ·å§‹ä½ç½®åœ¨å…¨éƒ¨ç©ºé—´ä¸­çš„åç§»        shard_infos[i].first_segment_offset = tracker_off + total_tracker_size + i * segments_per_shard * config_segment_size;    &#125;    // è¾“å‡ºæ—¥å¿—ä¿¡æ¯    INFO(&quot;&#123;&#125; disk_size=&#123;&#125;, segment_size=&#123;&#125;, block_size=&#123;&#125;&quot;,         device_id_printer_t&#123;device_id&#125;,         size,         uint64_t(config_segment_size),         data.block_size);    for (unsigned int i = 0; i &lt; seastar::smp::count; i++) &#123;        INFO(&quot;shard &#123;&#125; infos:&quot;, i, shard_infos[i]);    &#125;    // è¿”å› superblock å…¨éƒ¨ä¿¡æ¯    return block_sm_superblock_t&#123;seastar::smp::count, config_segment_size, data.block_size, shard_infos, std::move(sm_config)&#125;;&#125;\n\nå…­ã€å®¢æˆ·ç«¯ä½¿ç”¨æ–¹å¼ç”±äº crimson osd åªæ”¯æŒ message v2 åè®®ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨æŒ‚è½½ cephfs&#x2F;cephrbd ç­‰çš„æ—¶å€™éœ€è¦ä½¿ç”¨ message v2 çš„æ–¹å¼ã€‚\nç›¸å…³å‘½ä»¤:\nbash# æŒ‚è½½ cephrbd - kernel æ–¹å¼rbd device map -t krbd rbdpool/rbdimg01 -o mount_timeout=5,ms_mode=crc# æŒ‚è½½ cephrbd - nbd æ–¹å¼rbd device map -t nbd rbdpool/rbdimg01# å–æ¶ˆæŒ‚è½½ cephrbdrbd device unmap rbdpool/rbdimg01 -t krbdrbd device unmap rbdpool/rbdimg01 -t nbd# æŒ‚è½½ cephfs - kernel æ–¹å¼mount -t ceph 10.10.10.1:3300:/ /mnt/kernel-cephfs -o name=admin,secret=AQBVokZoak+LJRAAqgeJr6j77v729bfvBl/Z3g==,ms_mode=crc,mount_timeout=5# æŒ‚è½½ cephfs - fuse æ–¹å¼ceph-fuse -c /etc/ceph/ceph.conf -n client.admin -m 10.10.10.1:3300 /mnt/fuse-cephfs --client_mountpoint /# å–æ¶ˆæŒ‚è½½ cephfsumount /mnt/kernel-cephfsfusermount -u /mnt/fuse-cephfs\n\nç›¸å…³ä»£ç å®ç°:\nc// ç­›é€‰ç›‘å¬åœ°å€entity_addrvec_t pick_addresses(int what)&#123;    LOG_PREFIX(osd.cc : pick_addresses);    entity_addrvec_t addrs;    crimson::common::CephContext cct;    // ä»…ç­›é€‰ message v2 çš„åœ°å€    const auto flags = what | CEPH_PICK_ADDRESS_MSGR2;    if (int r = ::pick_addresses(&amp;cct, flags, &amp;addrs, -1); r &lt; 0) &#123;        throw std::runtime_error(&quot;failed to pick address&quot;);    &#125;    for (auto addr : addrs.v) &#123;        INFO(&quot;picked address &#123;&#125;&quot;, addr);    &#125;    return addrs;&#125;// æ¥æ”¶è¯·æ±‚seastar::future&lt;&gt; SocketMessenger::start(const dispatchers_t&amp; _dispatchers)&#123;    assert(seastar::this_shard_id() == sid);    dispatchers.assign(_dispatchers);    if (listener) &#123;        // ä»…æ”¯æŒ message v2 çš„åœ°å€        ceph_assert(get_myaddr().is_msgr2());        ceph_assert(get_myaddr().get_port() &gt; 0);        // æ¥æ”¶ç«¯å£è¯·æ±‚        return listener-&gt;accept([this](SocketRef _socket, entity_addr_t peer_addr) &#123;            assert(get_myaddr().is_msgr2());            SocketFRef socket = seastar::make_foreign(std::move(_socket));            if (listener-&gt;is_fixed_shard_dispatching()) &#123;                return accept(std::move(socket), peer_addr);            &#125;            else &#123;                return seastar::smp::submit_to(sid, [this, peer_addr, socket = std::move(socket)]() mutable &#123;                    return accept(std::move(socket), peer_addr);                &#125;);            &#125;        &#125;);    &#125;    return seastar::now();&#125;\n\nä¸ƒã€å…¶ä»–ç‰¹æ€§å®ç°7.1ã€å†·çƒ­å­˜å‚¨åˆ†ç¦»å½“ä½¿ç”¨ vstart.sh è„šæœ¬éƒ¨ç½²æµ‹è¯•çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šå‘ç° --seastore-secondary-devs å’Œ --seastore-secondary-devs-type é…ç½®ï¼Œå¦‚æœæŒ‡å®šäº†è¿™ä¸¤ä¸ªå‚æ•°ï¼Œè¯¥è„šæœ¬ä¾¿ä¼šé€šè¿‡ dd æ ¼å¼åŒ–å¯¹åº”ç›˜ï¼Œç„¶ååˆ›å»º ./dev/osd$id/block.$type.1 ç›®å½•ï¼Œä¹‹åæ‰§è¡Œ ln -s $device ./dev/osd$id/block.$type.1/block åˆ›å»ºä¸€ä¸ªè½¯é“¾æ–‡ä»¶ã€‚è¯¦ç»†çš„ä»£ç å¯ä»¥æŸ¥çœ‹: https://github.com/ceph/ceph/blob/v19.2.1/src/vstart.sh#L1194 ã€‚\næŒ‰ç…§å®˜æ–¹è§£é‡Šè¿™ä¸¤ä¸ªå‚æ•°æ˜¯ç”¨æ¥æŒ‡å®šæ¬¡è¦å—è®¾å¤‡çš„åˆ—è¡¨å’Œç±»å‹ï¼Œè¿›ä¸€æ­¥åˆ†æ crimson å®˜æ–¹æ–‡æ¡£ æˆ‘ä»¬å‘ç°è¿™ä¸¤ä¸ªé…ç½®å¯ç”¨äºå®ç° ceph çš„å†·çƒ­å­˜å‚¨åˆ†ç¦»ç‰¹æ€§ï¼Œå³éšç€æ—¶é—´çš„æ¨ç§»é€æ­¥å°†è¾ƒå¿«è®¾å¤‡ï¼ˆä¸»è®¾å¤‡ï¼‰ä¸­çš„å†·æ•°æ®è¿ç§»åˆ°è¾ƒæ…¢çš„è®¾å¤‡ï¼ˆæ¬¡è¦è®¾å¤‡ï¼‰ä¸­ï¼Œé€šå¸¸è¦æ±‚æ¬¡è¦è®¾å¤‡çš„é€Ÿåº¦ä¸åº”è¯¥æ¯”ä¸»è®¾å¤‡æ›´å¿«ã€‚æˆ‘ä»¬èƒ½å‘ç°è¯¥ç‰¹æ€§ä¸ Cache Tiering ç‰¹æ€§æ¯”è¾ƒç›¸ä¼¼ï¼Œä¹‹åä¹Ÿä¼šåšä¸€ä¸‹å¯¹æ¯”åˆ†æã€‚\nå…³äºä¸»è®¾å¤‡å‰”é™¤æ•°æ®åˆ°æ¬¡è¦è®¾å¤‡çš„ç›¸å…³å‚æ•°:\n\nseastore_multiple_tiers_stop_evict_ratio: å½“ä¸»è®¾å¤‡çš„ä½¿ç”¨ç‡ä½äºæ­¤å€¼æ—¶ï¼Œåœæ­¢å°†å†·æ•°æ®é€å‡ºåˆ°å†·å±‚ã€‚é»˜è®¤å€¼ä¸º 0.5 ã€‚\nseastore_multiple_tiers_default_evict_ratio: å½“ä¸»è®¾å¤‡çš„ä½¿ç”¨ç‡è¾¾åˆ°æ­¤å€¼æ—¶ï¼Œå¼€å§‹å°†å†·æ•°æ®è¿ç§»åˆ°æ¬¡è¦è®¾å¤‡ã€‚é»˜è®¤å€¼ä¸º 0.6 ã€‚\nseastore_multiple_tiers_fast_evict_ratio: å½“ä¸»è®¾å¤‡çš„ä½¿ç”¨ç‡è¾¾åˆ°æ­¤å€¼æ—¶ï¼Œå¼€å§‹æ‰§è¡Œå¿«é€Ÿé€å‡ºã€‚é»˜è®¤å€¼ä¸º 0.7 ã€‚\n\nå…«ã€æ¨¡å—è§£æä¹ã€ä»£ç é€»è¾‘æ¢³ç†main å‡½æ•°ä¸­å¯åŠ¨çš„ seastar::async å¼‚æ­¥ä»»åŠ¡çš„å…³é”®é€»è¾‘å¦‚ä¸‹:\n\nè®¾ç½®æ—¥å¿—çº§åˆ«å¹¶æ‰“å¼€æ—¥å¿—æ–‡ä»¶ï¼›\nå¯åŠ¨ prometheus api server ï¼›\nåˆ›å»º client/cluster/hb_front/hb_back æ¶ˆæ¯ç®¡ç†å™¨ SocketMessenger ï¼›\nåˆ›å»º store å¯¹è±¡ï¼›\nåˆ›å»ºã€åˆå§‹åŒ–ã€å¯åŠ¨ crimson osd å¯¹è±¡ï¼›\n\n9.1ã€æ¶ˆæ¯ç®¡ç†å™¨åˆ›å»ºé€»è¾‘é€šè¿‡è°ƒç”¨ crimson::net::Messenger::create å‡½æ•°æ¥ä¾æ¬¡åˆ›å»º client/cluster/hb_front/hb_back æ¶ˆæ¯ç®¡ç†å™¨ï¼Œæœ€ç»ˆåˆ›å»ºçš„å¯¹è±¡ç±»å‹ä¸º SocketMessenger ã€‚\nå…¶ä¸­åˆ›å»º client/cluster æ¶ˆæ¯å¯¹è±¡çš„æ—¶å€™ dispatch_only_on_this_shard å‚æ•°ä¸º false ï¼Œæ„å‘³ç€æ¥æ”¶åˆ°çš„æ¶ˆæ¯å¯èƒ½ä¼šäº¤ç”±å…¶ä»–çš„ shard è¿›è¡Œå¤„ç†ï¼›åˆ›å»º hb_front/hb_back æ¶ˆæ¯å¯¹è±¡çš„æ—¶å€™ dispatch_only_on_this_shard å‚æ•°ä¸º true ï¼Œæ„å‘³ç€æ¥æ”¶åˆ°çš„æ¶ˆæ¯ä»…ä¼šç”±å½“å‰ shard å¤„ç†ã€‚\n9.2ã€store å¯¹è±¡åˆ›å»ºé€»è¾‘é€šè¿‡è°ƒç”¨ crimson::os::FuturizedStore::create å‡½æ•°æ¥åˆ›å»º store å¯¹è±¡ã€‚æ ¹æ® osd_objectstore å’Œ osd_data å‚æ•°æ¥é…ç½® store å¯¹è±¡ã€‚å…¶ä¸­ osd_objectstore å‚æ•°æŒ‡å®šäº†åç«¯å¯¹è±¡å­˜å‚¨çš„ç±»å‹ï¼Œæ”¯æŒçš„å‚æ•°æœ‰ alienstore/cyanstore/seastore ï¼Œé»˜è®¤ä¸º alienstore ï¼ˆå³åç«¯å­˜å‚¨ä¸º bluestore ï¼‰ã€‚å…¶ä¸­ osd_data å‚æ•°æŒ‡å®šäº†æ•°æ®å­˜å‚¨ç›®å½•ï¼ˆæ¯”å¦‚å½“ä½¿ç”¨ vstart.sh éƒ¨ç½²é›†ç¾¤æ—¶ï¼Œå¯¹åº”çš„é…ç½®é»˜è®¤ä¸º ./build/dev/osd$id ï¼‰ã€‚\ncrimson æ”¯æŒä»¥ä¸‹ä¸‰ä¸ª objectstore åç«¯:\n\nalienstore: æä¾›ä¸æ—©æœŸç‰ˆæœ¬çš„å¯¹è±¡å­˜å‚¨ï¼ˆå³ BlueStoreï¼‰çš„å…¼å®¹æ€§ã€‚\ncyanstore: ç”¨äºæµ‹è¯•çš„æ¨¡æ‹Ÿåç«¯ï¼Œç”±æ˜“å¤±æ€§å†…å­˜å®æ–½ã€‚æ­¤å¯¹è±¡å­˜å‚¨åœ¨å…¸å‹çš„ osd ä¸­çš„ memstore åå»ºæ¨¡ã€‚\nseastore: ä¸º crimson osd è®¾è®¡çš„æ–°å¯¹è±¡å­˜å‚¨ã€‚å¯¹å¤šä¸ªåˆ†ç‰‡æ”¯æŒçš„è·¯å¾„å› åç«¯çš„ç‰¹å®šç›®æ ‡è€Œå¼‚ã€‚\n\n9.3ã€crimson osd mkfs é€»è¾‘ç”±äºåœ¨å¯åŠ¨ osd ç»„ä»¶ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦åˆå§‹åŒ– osd çš„æ–‡ä»¶ç³»ç»Ÿç¯å¢ƒï¼Œä¸ºæ­¤éœ€è¦æ‰§è¡Œ OSD::mkfs å‡½æ•°ï¼ˆç›¸å…³æ“ä½œé¡ºåºå¯ä»¥å‚è€ƒ vstart.sh è„šæœ¬ä¸­åœ¨å¯åŠ¨ osd ç»„ä»¶çš„æ­¥éª¤ï¼Œå…¶ä¸­åœ¨å¯åŠ¨ osd ä¹‹å‰éœ€è¦å…ˆå¯¹å…¶å­˜å‚¨è·¯å¾„çš„ç¯å¢ƒæ‰§è¡Œ mkfs æ“ä½œã€‚ï¼‰\nOSD::mkfs å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\nc1. store.start()store.mkfs(osd_uuid) // é‡ç‚¹2. store.mount()3. open_or_create_meta_coll(store)4. _write_superblock(...)5. store.write_meta(...)6. store.umount()7. store.stop()\n\n\n1. store.start()\n\nç”±äº store çš„ç±»å‹å­˜åœ¨ä¸‰ç§ï¼š alienstore/cyanstore/seastore ï¼Œ æ‰€ä»¥å¯¹åº”çš„ start é€»è¾‘ä¹Ÿæœ‰ä¸‰ç§ã€‚ç”±äº alienstore åªæ˜¯ bluestore çš„ä»£ç†ï¼Œä¸”å®ç°æ¯”è¾ƒç®€å•ï¼Œä¸ºæ­¤ä¸åšä»‹ç»ï¼›è€Œ cyanstore æ˜¯ä½œä¸ºä¸€ä¸ªå†…å­˜å­˜å‚¨æ¨¡å—è€Œå­˜åœ¨ï¼Œä»…ä½œä¸ºå¼€å‘æµ‹è¯•ä½¿ç”¨ï¼Œä¸ºæ­¤è¿™é‡Œä¹Ÿä¸åšä»‹ç»ï¼›æ‰€ä»¥ä»¥ä¸‹ä»…ä»‹ç» seastore çš„å®ç°é€»è¾‘ï¼Œå¯¹åº”çš„å‡½æ•°ä¸º SeaStore::start ã€‚\nSeaStore::start å‡½æ•°ä¸­å…³è”é€»è¾‘ä¸º:\nc1. Device::make_device(root, d_type)2. device-&gt;start()3. shard_stores.start(root, device.get(), is_test)\n\n1. Device::make_device(root, d_type) é€»è¾‘è§£æ:åœ¨ seastore ä¸­æœ‰ä¸€ä¸ª seastore_main_device_type å‚æ•°ï¼Œç”¨äºè®¾ç½® seastore ä¸»è®¾å¤‡çš„ç±»å‹ï¼Œå¯é€‰å€¼ä¸º SSD/RANDOM_BLOCK_SSD ï¼ˆä»£ç ä¸­è¿˜å®ç°äº† HDD/ZBD ï¼Œä½†æ˜¯ç›®å‰å¹¶ä¸æ”¯æŒï¼‰ ï¼Œé»˜è®¤ä¸º SSD ã€‚\nDevice::make_device(root, d_type) å‡½æ•°å†…éƒ¨åœ¨åˆ›å»º device çš„è¿‡ç¨‹ä¸­ï¼Œä¼šé’ˆå¯¹ä¸åŒçš„è®¾å¤‡ç±»å‹åˆåšäº†ä¸€äº›åŒºåˆ†ï¼Œè¯¦ç»†çš„ç±»åˆ«åˆ†ç±»å¦‚ä¸‹:\n\n\n\ndevice_type\nbackend_type\ncreate func\n\n\n\nHDD\nbackend_type_t::SEGMENTED\nSegmentManager::get_segment_manager\n\n\nSSD\nbackend_type_t::SEGMENTED\nSegmentManager::get_segment_manager\n\n\nZBD\nbackend_type_t::SEGMENTED\nSegmentManager::get_segment_manager\n\n\nRANDOM_BLOCK_SSD\nbackend_type_t::RANDOM_BLOCK\nget_rb_device\n\n\nç”±äº seastore_main_device_type é»˜è®¤ä¸º SSD ï¼Œæ‰€ä»¥ä¼šé€šè¿‡ SegmentManager::get_segment_manager å‡½æ•°æ¥æ¥åˆ›å»ºä¸€ä¸ª segment_manager::block::BlockSegmentManager å¯¹è±¡ã€‚\n2. device-&gt;start() é€»è¾‘è§£æ:å½“æ‰§è¡Œ device-&gt;start() çš„æ—¶å€™ï¼Œè°ƒç”¨çš„å°±æ˜¯ BlockSegmentManager::start æ–¹æ³•ï¼Œç»§è€Œè°ƒç”¨çš„æ˜¯ shard_devices.start(device_path, superblock.config.spec.dtype) ï¼Œç”±äº shard_devices çš„ç±»å‹ä¸º seastar::sharded , æ‰€ä»¥è¿™é‡Œç›¸å½“äºè°ƒç”¨äº† seastar::sharded::start å‡½æ•°æ¥åˆå§‹åŒ–äº† BlockSegmentManager å¯¹è±¡ã€‚\n3. shard_stores.start(root, device.get(), is_test) é€»è¾‘è§£æ:ä¹‹åçš„ shard_stores.start(root, device.get(), is_test) å‡½æ•°æ‰§è¡Œä¸­ï¼Œç”±äº shard_stores ä¹Ÿæ˜¯ä¸€ä¸ª seastar::sharded å°è£…çš„å¯¹è±¡ï¼Œæ‰€ä»¥å…¶å†…éƒ¨ç›¸å½“äºè°ƒç”¨äº† seastar::sharded::start å‡½æ•°æ¥åˆå§‹åŒ–äº† SeaStore::Shard å¯¹è±¡ã€‚\n\n2. store.mount()\n\nstore.mount() å‡½æ•°å¯¹åº”çš„æ˜¯ SeaStore::mount å‡½æ•°ã€‚\nSeaStore::mount å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncdevice-&gt;mount()device-&gt;get_sharded_device().get_secondary_devices()Device::make_device(path, dtype)sec_dev-&gt;start()sec_dev-&gt;mount()set_secondaries()\n\ndevice-&gt;mount() å‡½æ•°å¯¹åº”çš„æ˜¯ BlockSegmentManager::mount å‡½æ•°ï¼Œè¿™ä¸ªä¹‹å‰è§£é‡Šè¿‡ï¼Œå…¶å†…éƒ¨é€šè¿‡è°ƒç”¨ shard_devices.invoke_on_all æ¥è§¦å‘åœ¨æ¯ä¸ª shard ä¸­æ‰§è¡Œ local_device.shard_mount() å‡½æ•°ï¼Œå› æ­¤æ¯ä¸ª shard ä¸­è°ƒç”¨çš„å‡½æ•°å…¶å®æ˜¯ BlockSegmentManager::shard_mount() ï¼Œè¯¥å‡½æ•°å†…éƒ¨çš„æ‰§è¡Œé€»è¾‘ä¸»è¦åŒ…æ‹¬æ‰“å¼€ device ï¼Œè¯»å– superblock ä¿¡æ¯ï¼Œæ ¡éªŒ superblock ä¿¡æ¯ï¼Œæ›´æ–° tracker ä¿¡æ¯ç­‰ã€‚\n\n3. open_or_create_meta_coll(store)\n\nopen_or_create_meta_coll(store) å¯¹åº”çš„å‡½æ•°æ˜¯ OSD::open_or_create_meta_coll ã€‚\nOSD::open_or_create_meta_coll å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncstore.get_sharded_store().open_collection(coll_t::meta())store.get_sharded_store().create_new_collection(coll_t::meta())OSDMeta(ch, store.get_sharded_store())\n\n\n4. _write_superblock(â€¦)\n\n_write_superblock(...) çš„å®Œæ•´è°ƒç”¨ä¸º _write_superblock(store, std::move(meta_coll), std::move(superblock)) ï¼Œå…¶å¯¹åº”çš„å‡½æ•°æ˜¯ OSD::_write_superblock ã€‚å…¶å†…éƒ¨ä¸»è¦çš„é€»è¾‘ä¸ºå°† superblock ä¿¡æ¯å†™å…¥å­˜å‚¨ä¸­ã€‚\nOSD::_write_superblock å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncmeta_coll.load_superblock()meta_coll.create(t)meta_coll.store_superblock(t, superblock)store.get_sharded_store().do_transaction(meta_coll.collection(), std::move(t))\n\n\n5. store.write_meta(â€¦)\n\nstore.write_meta(â€¦) å¯¹åº”å¾ˆå¤šå†™å…ƒä¿¡æ¯çš„æ“ä½œï¼Œæ“ä½œçš„å…ƒä¿¡æ¯åŒ…æ‹¬ ceph_fsid ï¼Œmagic ï¼Œwhoami ï¼Œosd_key ï¼Œ osdspec_affinity ï¼Œ ready ç­‰å­—æ®µã€‚è¿™äº›ä¿¡æ¯ä½äº osd è¿è¡Œç›®å½•çš„å„ä¸ªé…ç½®å¯¹åº”çš„æ–‡ä»¶ä¸­ã€‚\n\n6. store.umount()\n\nstore.umount() å¯¹åº”çš„å‡½æ•°ä¸º SeaStore::umount ï¼Œ å…¶å†…éƒ¨ä¼šåŒé€šè¿‡è°ƒç”¨ shard_stores.invoke_on_all å‡½æ•°ï¼Œè®©æ¯ä¸ª shard æ‰§è¡Œ local_store.umount() å‡½æ•°ã€‚\n\n7. store.stop()\n\nstore.stop() å¯¹åº”çš„å‡½æ•°ä¸º SeaStore::stop ã€‚\nSeaStore::stop å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncsec_dev-&gt;stop()secondaries.clear()device-&gt;stop()shard_stores.stop()\n\n9.3.1ã€store.mkfs(osd_uuid)SeaStore::mkfs å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\nc1. read_meta(&quot;mkfs_done&quot;)2. seastar::open_directory(root)        root_f-&gt;list_directory(...)            Device::make_device(path, dtype)            secondaries.emplace_back(std::move(sec_dev))            p_sec_dev-&gt;start()            p_sec_dev-&gt;mkfs()            set_secondaries()3. device-&gt;mkfs(...)4. device-&gt;mount()5. local_store.mkfs_managers() // shard_stores.invoke_on_all(...) // é‡ç‚¹6. prepare_meta(new_osd_fsid)7. umount()\n\n\n\nread_meta(â€œmkfs_doneâ€)\n\n\nread_meta(&quot;mkfs_done&quot;) ç”¨äºæ ¡éªŒä¹‹å‰æ˜¯å¦å·²ç»æ‰§è¡Œè¿‡ mkfs æ“ä½œï¼Œç›‘æµ‹æ–¹å¼ä¸ºè¯»å– store ç›®å½•ä¸­çš„ mkfs_done æ–‡ä»¶ä¸­çš„å†…å®¹ã€‚\n\n\nseastar::open_directory(root)\n\n\nseastar::open_directory(root) çš„é€»è¾‘ä¸ºæ£€ç´¢ store ç›®å½•ä¸­çš„æ–‡ä»¶ï¼Œç­›é€‰å‰ç¼€åä¸º block. çš„æ–‡ä»¶&#x2F;ç›®å½•ï¼Œé€šè¿‡è§£æè¯¥æ–‡ä»¶&#x2F;ç›®å½•çš„åç¼€ï¼Œä»è€Œå°è¯•è°ƒç”¨ Device::make_device(path, dtype) å‡½æ•°æ¥åˆ›å»ºå¯¹åº”çš„ device ï¼Œ è¿›è€Œæ“ä½œå¯¹åº”çš„ device æ‰§è¡Œ start å’Œ mkfs å‡½æ•°æ“ä½œã€‚\n\n\ndevice-&gt;mkfs(â€¦)\n\n\ndevice-&gt;mkfs(...) å¯¹åº”çš„å®Œæ•´å‡½æ•°ä¸º device-&gt;mkfs(device_config_t::create_primary(new_osd_fsid, id, d_type, sds)) ï¼Œ ç”±äº seastore_main_device_type é»˜è®¤ä¸º SSD ï¼Œæ‰€ä»¥è¿™é‡Œçš„ device-&gt;mkfs æŒ‡çš„æ˜¯ BlockSegmentManager::mkfs å‡½æ•°ã€‚\nBlockSegmentManager::mkfs å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncshard_devices.local().primary_mkfs(sm_config)    check_create_device(device_path, size)    open_device(device_path)    make_superblock(get_device_id(), sm_config, stat)    write_superblock(get_device_id(), device, sb)    device.close()local_device.shard_mkfs() // shard_devices.invoke_on_all(...)    open_device(device_path)    read_superblock(device, sd)    sb.validate()    tracker.reset(new SegmentStateTracker(shard_info.segments, sb.block_size))    tracker-&gt;write_out(get_device_id(), device, shard_info.tracker_offset)    device.close()\n\nå…¶ä¸­ shard_devices.local().primary_mkfs(sm_config) å¯¹åº”çš„å‡½æ•°ä¸º BlockSegmentManager::primary_mkfs ã€‚å…¶å†…éƒ¨é€»è¾‘å¦‚ä¸‹:\n\ncheck_create_device(device_path, size): é€šè¿‡ seastar::open_file_dma å‡½æ•°æ¥æ‰“å¼€å¯¹åº”çš„ block æ–‡ä»¶ï¼Œå¹¶é€šè¿‡ f.truncate å’Œ f.allocate(0, size) å‡½æ•°æ¥è°ƒæ•´å¯¹åº”æ–‡ä»¶çš„å¤§å°ï¼Œç”¨äºåç»­å­˜å‚¨æ•°æ®ã€‚è¯¥æ­¥éª¤ä¸­çš„ seastore_block_create é…ç½®ç”¨äºæ§åˆ¶æ˜¯å¦åˆ›å»º block ï¼Œ è¯¥å‚æ•°é»˜è®¤ä¸º true ï¼›seastore_device_size é…ç½®ç”¨äºæ§åˆ¶ block çš„æ–‡ä»¶å¤§å°ï¼Œè¯¥å‚æ•°é»˜è®¤ä¸º 50GB ã€‚\nopen_device(device_path): é€šè¿‡ seastar::open_file_dma æ–¹æ³•æ¥æ‰“å¼€å¯¹åº”çš„ block æ–‡ä»¶ï¼Œç”¨äºåç»­çš„æ•°æ®æ“ä½œã€‚\nmake_superblock(get_device_id(), sm_config, stat): åˆå§‹åŒ– superblock ä¿¡æ¯ã€‚å…¶å†…éƒ¨æ ¹æ® seastar::smp::count çš„æ•°é‡ï¼Œseastore_segment_size å‚æ•°ï¼ˆç”¨äºæ§åˆ¶å•ä¸ª segment çš„å¤§å°ï¼Œé»˜è®¤ä¸º 64M ï¼‰ç­‰ä¿¡æ¯æ¥åˆå§‹åŒ– superblock ä¿¡æ¯ã€‚\nwrite_superblock(get_device_id(), device, sb): å°†åºåˆ—åŒ–åçš„ superblock ä¿¡æ¯å†™å…¥ block çš„æ–‡ä»¶å¤´éƒ¨ã€‚\ndevice.close(): å…³é—­æ‰“å¼€çš„ device ã€‚\n\nä¹‹åé€šè¿‡è°ƒç”¨ shard_devices.invoke_on_all(...) å‡½æ•°ï¼Œè¯¥å‡½æ•°æ˜¯ Seastar æ¡†æ¶ä¸­ä½¿ç”¨çš„æ–¹æ³•ï¼Œç”¨äºåœ¨æ‰€æœ‰çš„ seastar shard ä¸Šæ‰§è¡Œç»™å®šçš„å‡½æ•°ã€‚ä¹‹åæ¯ä¸ª shard ä¸Šæ‰§è¡Œ local_device.shard_mkfs() å‡½æ•°ã€‚å…¶å†…éƒ¨å›ä¾æ¬¡æ‰“å¼€ device ï¼Œè¯»å– superblock ä¿¡æ¯ï¼Œæ ¡éªŒ superblock ä¿¡æ¯ï¼Œæ›´æ–° tracker ä¿¡æ¯ç­‰ï¼›ä¹‹åä¾¿å…³é—­ device ã€‚\n\n\ndevice-&gt;mount()\n\n\ndevice-&gt;mount() å¯¹åº”çš„å‡½æ•°ä¸º BlockSegmentManager::mount ã€‚\nBlockSegmentManager::mount å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\nclocal_device.shard_mount() // shard_devices.invoke_on_all(...)\n\nè¿™é‡Œä¹Ÿæ˜¯é€šè¿‡è°ƒç”¨ shard_devices.invoke_on_all æ¥è§¦å‘åœ¨æ¯ä¸ª shard ä¸­æ‰§è¡Œ local_device.shard_mount() å‡½æ•°ï¼Œå› æ­¤æ¯ä¸ª shard ä¸­è°ƒç”¨çš„å‡½æ•°å…¶å®æ˜¯ BlockSegmentManager::shard_mount() ï¼Œè¯¥å‡½æ•°å†…éƒ¨çš„æ‰§è¡Œé€»è¾‘ä¸»è¦åŒ…æ‹¬æ‰“å¼€ device ï¼Œè¯»å– superblock ä¿¡æ¯ï¼Œæ ¡éªŒ superblock ä¿¡æ¯ï¼Œæ›´æ–° tracker ä¿¡æ¯ç­‰ã€‚\n\n\nlocal_store.mkfs_managers()\n\n\næ¥ç€åˆé€šè¿‡è°ƒç”¨ shard_stores.invoke_on_all(...) æ¥è§¦å‘åœ¨æ¯ä¸ª shard ä¸­æ‰§è¡Œ local_store.mkfs_managers() æ“ä½œï¼Œå¯¹åº”çš„å‡½æ•°ä¸º SeaStore::Shard::mkfs_managers ã€‚\nSeaStore::Shard::mkfs_managers å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncinit_managers()transaction_manager-&gt;mkfs()init_managers()transaction_manager-&gt;mount()repeat_eagain(...)    transaction_manager-&gt;with_transaction_intr(...)        onode_manager-&gt;mkfs(t)        collection_manager-&gt;mkfs(t)        transaction_manager-&gt;write_collection_root(t, coll_root)        transaction_manager-&gt;submit_transaction(t)\n\nå…¶ä¸­ init_managers() å‡½æ•°æŒ‡çš„æ˜¯ SeaStore::Shard::init_managers() å‡½æ•°ï¼Œå…¶å†…éƒ¨ä¼šåˆå§‹åŒ– transaction_manager ï¼Œ collection_manager ï¼Œ onode_manager å¯¹è±¡ã€‚\n\ntransaction_manager: åˆå§‹åŒ–å‡½æ•°ä¸º TransactionManagerRef make_transaction_manager ï¼Œè¯¥å¯¹è±¡æ˜¾ç„¶ç”¨äºç®¡ç†å­˜å‚¨è®¾å¤‡ä¸Šçš„äº‹åŠ¡ã€‚\ncollection_manager: åˆå§‹åŒ–å‡½æ•°ä¸º FlatCollectionManager::FlatCollectionManager ï¼›\nonode_manager: åˆå§‹åŒ–å‡½æ•°ä¸º FLTreeOnodeManager::FLTreeOnodeManager ï¼›\n\ntransaction_manager ç›¸å…³æ‰§è¡Œé€»è¾‘:\n\ntransaction_manager-&gt;mkfs(): å¯¹åº” TransactionManager::mkfs å‡½æ•°ï¼›\ntransaction_manager-&gt;mount(): å¯¹åº” TransactionManager::mount å‡½æ•°ï¼›\ntransaction_manager-&gt;with_transaction_intr(...): å¯¹åº” ExtentCallbackInterface::with_transaction_intr å‡½æ•°ï¼›\n\nå…¶ä¸­ TransactionManager::mkfs å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncepm-&gt;mount()journal-&gt;open_for_mkfs()epm-&gt;open_for_write()with_transaction_intr(...)close()\n\nå…¶ä¸­ TransactionManager::mount å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\nccache-&gt;init()epm-&gt;mount()journal-&gt;replay(...)journal-&gt;open_for_mount()journal-&gt;get_trimmer().set_journal_head(start_seq)with_transaction_weak(...)epm-&gt;open_for_write()epm-&gt;start_background()\n\nTODO:\nonode_manager ç›¸å…³æ‰§è¡Œé€»è¾‘:\nç›¸å…³æ“ä½œä¸º onode_manager-&gt;mkfs(t) ï¼Œ å¯¹åº”çš„å‡½æ•°ä¸º FLTreeOnodeManager::mkfs å‡½æ•°ã€‚ ä¹‹åç»§ç»­è°ƒç”¨ Btree::mkfs &#x3D;&gt; Node::mkfs\nTODO:\ncollection_manager ç›¸å…³æ‰§è¡Œé€»è¾‘:\nç›¸å…³æ“ä½œä¸º collection_manager-&gt;mkfs(t)\nTODO:\n\n\nprepare_meta(new_osd_fsid)\n\n\nprepare_meta(new_osd_fsid) å‡½æ•°å¯¹åº”çš„æ˜¯ SeaStore::prepare_meta å‡½æ•°ï¼Œå…¶å†…éƒ¨ä¸»è¦æ˜¯å†™å…¥ä¸€äº›å…ƒä¿¡æ¯åˆ°å¯¹åº”çš„æ•°æ®ç›®å½•çš„æ–‡ä»¶ä¸­ï¼ŒåŒ…æ‹¬å‘ fsid æ–‡ä»¶ä¸­å†™å…¥é›†ç¾¤ id ä¿¡æ¯ï¼›å‘ type æ–‡ä»¶ä¸­å†™å…¥ååç«¯å­˜å‚¨ç±»å‹ï¼ˆæ¯”å¦‚ seastore ï¼‰ ï¼› å¾€ mkfs_done æ–‡ä»¶ä¸­å†™å…¥ yes ã€‚\n\n\numount()\n\n\numount() å‡½æ•°å¯¹åº”çš„æ˜¯ SeaStore::umount å‡½æ•°ï¼Œå…¶å†…éƒ¨ä¼šé€šè¿‡ shard_stores.invoke_on_all å‡½æ•°é€šçŸ¥æ‰€æœ‰çš„ shard æ‰§è¡Œ local_store.umount() æ“ä½œã€‚\n9.4ã€crimson osd start é€»è¾‘å½“ osd é€šè¿‡ mkfs åˆå§‹åŒ–ä¹‹åæ‰ä¼šè¢«æ­£å¼çš„å¯åŠ¨ï¼Œè¿™æ—¶å€™å°±ä¼šè°ƒç”¨ OSD::start å‡½æ•°å¯åŠ¨ã€‚éœ€è¦æ³¨æ„è¯¥å‡½æ•°å†…éƒ¨é™åˆ¶å½“å‰çš„ shard ä¸º PRIMARY_CORE ã€‚å…¶ä¸­ store.start() å’Œ store.mount() çš„æ‰§è¡Œé€»è¾‘ä¹‹å‰åœ¨ osd mkfs çš„é€»è¾‘ä¸­å·²ç»æè¿°è¿‡äº†ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ã€‚éƒ¨åˆ†å®ç°æ¯”è¾ƒè¯¦ç»†æˆ–é€»è¾‘æ¥è¿‘ï¼Œå› æ­¤æ”¾åœ¨ä¸€å—ä¸€èµ·è§£é‡Šã€‚\nOSD::start å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncstore.start()1. pg_to_shard_mappings.start(...)2. osd_singleton_state.start_single(...)3. osd_states.start()4. shard_services.start(...)5. heartbeat.reset(...)store.mount()6. local_service.report_stats() // shard_services.invoke_on_all(...)7. store.report_stats()8. stats_timer.arm_periodic(...)9. open_meta_coll()10. pg_shard_manager.get_meta_coll().load_superblock()11. pg_shard_manager.set_superblock(superblock)12. pg_shard_manager.get_local_map(superblock.current_epoch)13. pg_shard_manager.update_map(std::move(map))14. local_service.local_state.osdmap_gate.got_map(...) // shard_services.invoke_on_all(...)15. pg_shard_manager.load_pgs(store)16. cluster_msgr-&gt;bind(pick_addresses(CEPH_PICK_ADDRESS_CLUSTER))    cluster_msgr-&gt;start(dispatchers)    public_msgr-&gt;bind(pick_addresses(CEPH_PICK_ADDRESS_PUBLIC))    public_msgr-&gt;start(dispatchers)17. monc-&gt;start()    mgrc-&gt;start()18. _add_me_to_crush()19. monc-&gt;renew_subs()20. heartbeat-&gt;start(...)21. start_asok_admin()22. log_client.set_fsid(monc-&gt;get_fsid())23. start_boot()\n\n\n1. pg_to_shard_mappings.start(â€¦)\n\npg_to_shard_mappings.start(...) çš„åŸå§‹è°ƒç”¨ä¿¡æ¯ä¸º pg_to_shard_mappings.start(0, seastar::smp::count) ã€‚ç”±äº pg_to_shard_mappings çš„å®šä¹‰ä¸º seastar::sharded pg_to_shard_mappings ï¼Œå› æ­¤è¿™é‡Œçš„ start å‡½æ•°å…¶å®æ˜¯è°ƒç”¨ seastar::sharded::start å‡½æ•°æ¥åˆå§‹åŒ–äº† PGShardMapping å¯¹è±¡ã€‚åœ¨ PGShardMapping å¯¹è±¡åˆå§‹åŒ–çš„è¿‡ç¨‹ä¸­ä¼šå‘å…¶å†…éƒ¨çš„æˆå‘˜å˜é‡ std::map core_to_num_pgs ä¸­æ·»åŠ  seastar::smp::count ä¸ªå…ƒç´ ã€‚\n\n2. osd_singleton_state.start_single(â€¦)\n\nosd_singleton_state.start_single(...) çš„åŸå§‹è°ƒç”¨ä¿¡æ¯ä¸º osd_singleton_state.start_single(whoami, std::ref(*cluster_msgr), std::ref(*public_msgr), std::ref(*monc), std::ref(*mgrc)) ã€‚ç”±äº osd_singleton_state çš„å®šä¹‰ä¸º seastar::sharded osd_singleton_state ï¼Œå› æ­¤è¿™é‡Œçš„ start_single å‡½æ•°å…¶å®æ˜¯è°ƒç”¨äº† seastar::sharded::start_single å‡½æ•°æ¥åˆ›å»ºäº†ä¸€ä¸ª OSDSingletonState å¯¹è±¡ã€‚åœ¨ OSDSingletonState å¯¹è±¡åˆå§‹åŒ–çš„è¿‡ç¨‹ä¸­ä¼šåˆ›å»ºä¸€äº› perf å’Œ recoverystate_perf å¯¹è±¡æŒ‡é’ˆã€‚\n\n3. osd_states.start()\n\nç”±äº osd_states çš„å®šä¹‰ä¸º seastar::sharded osd_states ï¼Œå› æ­¤è¿™é‡Œçš„ start å‡½æ•°å…¶å®æ˜¯è°ƒç”¨ seastar::sharded::start å‡½æ•°æ¥åˆå§‹åŒ–äº† OSDState å¯¹è±¡ã€‚\n\n4. shard_services.start(â€¦)\n\nshard_services.start(...) çš„åŸå§‹è°ƒç”¨ä¿¡æ¯ä¸º shard_services.start(std::ref(osd_singleton_state), std::ref(pg_to_shard_mappings), whoami, startup_time, osd_singleton_state.local().perf, osd_singleton_state.local().recoverystate_perf, std::ref(store), std::ref(osd_states)) ã€‚ç”±äº shard_services çš„å®šä¹‰ä¸º seastar::sharded shard_services ï¼Œå› æ­¤è¿™é‡Œçš„ start å‡½æ•°å…¶å®æ˜¯è°ƒç”¨ seastar::sharded::start å‡½æ•°æ¥åˆå§‹åŒ–äº† ShardServices å¯¹è±¡ã€‚\n\n5. heartbeat.reset(â€¦)\n\né‡ç½® heartbeat å¯¹è±¡ã€‚\n\n6. local_service.report_stats()\n\nè¯¥å‡½æ•°çš„è°ƒç”¨è¢«å°è£…åœ¨ shard_services.invoke_on_all å†…éƒ¨ï¼Œæ„å‘³ç€è¿™ä¼šè®©æ¯ä¸ª shard æ‰§è¡Œ local_service.report_stats() å‡½æ•°ã€‚ä½†æ˜¯åªæœ‰åœ¨ crimson_osd_stat_interval é…ç½®äº†éé›¶çš„æƒ…å†µä¸‹æ‰ä¼šæ‰§è¡Œè¯¥é€»è¾‘ã€‚ crimson_osd_stat_interval å‚æ•°é»˜è®¤ä¸º 0 ã€‚\n\n7. store.report_stats()\n\nstore.report_stats() å¯¹åº”çš„å‡½æ•°ä¸º SeaStore::report_stats ã€‚\nSeaStore::report_stats å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\nclocal_store.get_device_stats(report_detail) // shard_stores.invoke_on_alllocal_store.get_io_stats(report_detail) // shard_stores.invoke_on_allINFO(...);\n\n\n8. stats_timer.arm_periodic(â€¦)\n\nstats_timer.arm_periodic(...) å¯¹åº”çš„åŸå§‹è°ƒç”¨ä¸º stats_timer.arm_periodic(std::chrono::seconds(stats_seconds)) ã€‚ç”¨äºè®¾ç½®ä¸€ä¸ªå‘¨æœŸæ€§çš„å®šæ—¶å™¨ï¼Œè¯¥å®šæ—¶å™¨çš„è¿è¡Œæ˜¯ç”± Seastar æ¡†æ¶çš„äº‹ä»¶å¾ªç¯ç®¡ç†çš„ï¼Œä¸å‡½æ•°è°ƒç”¨çš„ç”Ÿå‘½å‘¨æœŸæ— å…³ã€‚\n\n9. open_meta_coll\n\nopen_meta_coll å¯¹åº”çš„å‡½æ•°ä¸º OSD::open_meta_coll ã€‚éœ€è¦æ³¨æ„è¯¥é€»è¾‘ä»…é™ PRIMARY_CORE å¯¹åº”çš„ shard æ‰§è¡Œã€‚\nSeaStore::report_stats å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncstore.get_sharded_store().open_collection(coll_t::meta())pg_shard_manager.init_meta_coll(ch, store.get_sharded_store())\n\n\n10. pg_shard_manager.get_meta_coll().load_superblock()\n\nå¯¹åº”çš„å‡½æ•°ä¸º OSDMeta::load_superblock ã€‚ç”¨äºä» store å­˜å‚¨ä¸­è¯»å– superblock ä¿¡æ¯ã€‚\n\n11. pg_shard_manager.set_superblock(superblock)\n\nå¯¹åº”çš„å‡½æ•°ä¸º PGShardManager::set_superblock ã€‚\nPGShardManager::set_superblock å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncget_osd_singleton_state().set_singleton_superblock(superblock)local_service.local_state.update_shard_superblock(superblock) // shard_services.invoke_on_all\n\n\n12. pg_shard_manager.get_local_map(superblock.current_epoch)\n\nå¯¹åº”çš„å‡½æ•°ä¸º OSDSingletonState::get_local_map ã€‚\n\n13. pg_shard_manager.update_map(std::move(map))\n\nå¯¹åº”çš„å‡½æ•°ä¸º PGShardManager::update_map ã€‚\nPGShardManager::update_map å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncget_osd_singleton_state().update_map(...)local.local_state.update_map(...) // shard_services.invoke_on_all\n\n\n14. local_service.local_state.osdmap_gate.got_map(â€¦)\n\nåŸå§‹çš„è°ƒç”¨ä¸º local_service.local_state.osdmap_gate.got_map(osdmap-&gt;get_epoch()) ï¼Œ è¯¥å‡½æ•°çš„è°ƒç”¨è¢«å°è£…åœ¨ shard_services.invoke_on_all å†…éƒ¨ï¼Œæ„å‘³ç€è¿™ä¼šè®©æ¯ä¸ª shard æ‰§è¡Œ local_service.local_state.osdmap_gate.got_map(osdmap-&gt;get_epoch()) å‡½æ•°ã€‚\n\n15. pg_shard_manager.load_pgs(store)\n\nå¯¹åº”çš„å‡½æ•°ä¸º PGShardManager::load_pgs ã€‚\nPGShardManager::load_pgs å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncstore.list_collections()// seastar::parallel_for_eachget_pg_to_shard_mapping().get_or_create_pg_mapping(pgid, shard_core)shard_services.load_pg(pgid)per_shard_state.pg_map.pg_loaded(pgid, std::move(pg))\n\n\n16. cluster_msgr å’Œ public_msgr\n\nå¯¹åº”çš„æ‰¹é‡çš„åŸå§‹è°ƒç”¨ä¸º:\nccluster_msgr-&gt;bind(pick_addresses(CEPH_PICK_ADDRESS_CLUSTER))cluster_msgr-&gt;start(dispatchers)public_msgr-&gt;bind(pick_addresses(CEPH_PICK_ADDRESS_PUBLIC))public_msgr-&gt;start(dispatchers)\n\npick_addresses å‡½æ•°æ‰§è¡Œçš„æ—¶å€™ï¼Œå…¶å†…éƒ¨ä»…ä¼šé€‰æ‹© message v2 çš„åœ°å€ï¼Œå› æ­¤ä»è¿™é‡Œå¯ä»¥çœ‹å‡ºåœ¨ crimson osd ä¸­ä¸æ”¯æŒ message v1 ã€‚\nbind å‡½æ•°å¯¹åº”çš„æ˜¯ SocketMessenger::bind ã€‚ start å‡½æ•°å¯¹åº”çš„æ˜¯ SocketMessenger::start ã€‚\nSocketMessenger::bind å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\nctry_bind(addrs, local_conf()-&gt;ms_bind_port_min, local_conf()-&gt;ms_bind_port_max)do_listen(entity_addrvec_t&#123;to_bind&#125;)ShardedServerSocket::create(dispatch_only_on_sid)listener-&gt;listen(listen_addr)    seastar::listen(s_addr, lo) // this-&gt;container().invoke_on_all\n\nä»ä¸Šé¢ä¸­å¯ä»¥çœ‹å‡ºä¼šè®©æ¯ä¸ª shard éƒ½ç›‘å¬ç›¸åŒçš„ç«¯å£ã€‚\nSocketMessenger::start å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\nclistener-&gt;accept([this](SocketRef _socket, entity_addr_t peer_addr) &#123;    assert(get_myaddr().is_msgr2());    SocketFRef socket = seastar::make_foreign(std::move(_socket));    // å¯¹äº client å’Œ cluster çš„æ¶ˆæ¯ï¼Œè¿™é‡Œçš„ fix æ˜¯ false     // å¯¹äº heart beat çš„æ¶ˆæ¯ï¼Œè¿™é‡Œçš„ fix æ˜¯ true    if (listener-&gt;is_fixed_shard_dispatching()) &#123;        return accept(std::move(socket), peer_addr);    &#125;    else &#123;        // è½¬å‘è¯·æ±‚åˆ°å¯¹åº”çš„ shard ä¸­        return seastar::smp::submit_to(sid, [this, peer_addr, socket = std::move(socket)]() mutable &#123;            return accept(std::move(socket), peer_addr);        &#125;);    &#125;&#125;);\n\n\n17. monc å’Œ mgrc çš„ start\n\nå¯¹åº”çš„æ‰¹é‡çš„åŸå§‹è°ƒç”¨ä¸º:\ncmonc-&gt;start()mgrc-&gt;start()\n\nå…¶ä¸­ monc-&gt;start() å¯¹åº”çš„å‡½æ•°ä¸º crimson::mon::Client::start ã€‚ mgrc-&gt;start() å¯¹åº”çš„å‡½æ•°ä¸º crimson::mgr::Client::start ã€‚\ncrimson::mon::Client::start å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncauth_registry.refresh_config()load_keyring()monmap.build_initial(crimson::common::local_conf(), false)authenticate()timer.arm_periodic(interval)\n\ncrimson::mgr::Client::start å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncseastar::now()\n\n\n18. _add_me_to_crush()\n\nè¯¥å‡½æ•°å¯¹åº”çš„æ˜¯ OSD::_add_me_to_crush ã€‚åœ¨è¯¥å‡½æ•°ä¸­ï¼Œå¦‚æœ osd_crush_update_on_start é…ç½®ä¸º true ï¼Œåˆ™ä¼šåœ¨ osd å¯åŠ¨æ—¶å°è¯•å°†è‡ªå·±çš„ä¿¡æ¯æ·»åŠ åˆ° crush map ä¸­ã€‚\nOSD::_add_me_to_crush å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\nclocal_conf().get_val&lt;bool&gt;(&quot;osd_crush_update_on_start&quot;)local_conf().get_val&lt;double&gt;(&quot;osd_crush_initial_weight&quot;)store.stat()get_weight()loc.init_on_startup()monc-&gt;run_command(std::move(cmd), &#123;&#125;)\n\n\n19. monc-&gt;renew_subs()\n\nå¯¹åº”çš„å‡½æ•°ä¸º crimson::mon::Client::renew_subs ã€‚ å†…éƒ¨é€»è¾‘ä¸ºå‘ monitor å‘é€ CEPH_MSG_MON_SUBSCRIBE æ¶ˆæ¯ï¼Œç”¨äºè®¢é˜… osd_pg_creates ï¼Œ mgrmap ï¼Œ osdmap çš„å˜æ›´æ¶ˆæ¯ã€‚\n\n20. heartbeat-&gt;start(â€¦)\n\nåŸå§‹çš„è°ƒç”¨ä¸º heartbeat-&gt;start(pick_addresses(CEPH_PICK_ADDRESS_PUBLIC), pick_addresses(CEPH_PICK_ADDRESS_CLUSTER)) , å¯¹åº”çš„å‡½æ•°ä¸º Heartbeat::start ã€‚\n\n21. start_asok_admin()\n\nå¯¹åº”çš„å‡½æ•°ä¸º OSD::start_asok_admin ã€‚ ç”¨äºåˆ›å»ºæœ¬åœ°çš„ socket æ–‡ä»¶ï¼Œå¹¶æ³¨å†Œå¯æ‰§è¡Œçš„å‘½ä»¤ã€‚\n\n22. log_client.set_fsid(monc-&gt;get_fsid())\n\nè®¾ç½®æ—¥å¿—è®°å½•ä¸­çš„ fsid ä¿¡æ¯ã€‚\n\n23. start_boot()\n\nå¯¹åº”çš„å‡½æ•°ä¸º OSD::start_boot ã€‚\nOSD::start_boot å‡½æ•°ä¸­å…³é”®é€»è¾‘ä¸º:\ncpg_shard_manager.set_preboot()monc-&gt;get_version(&quot;osdmap&quot;)_preboot(oldest, newest)\n\nåã€ç›¸å…³èµ„æ–™\nhttps://ceph.io/en/news/crimson/\nhttps://ceph.io/en/news/blog/2023/crimson-multi-core-scalability/\nhttps://ceph.io/en/news/blog/2025/crimson-T-release/\nhttps://docs.ceph.com/en/latest/dev/crimson/crimson/\nhttps://docs.ceph.com/en/latest/cephadm/install/#bootstrap-a-new-cluster\nhttps://www.51cto.com/article/749735.html\nhttps://zhuanlan.zhihu.com/p/667949613\nhttps://docs.redhat.com/zh-cn/documentation/red_hat_ceph_storage/7/html/administration_guide/crimson\nhttps://ceph.io/en/news/blog/2023/crimson-multi-core-scalability/\nhttps://www.icviews.cn/semiCommunity/postDetail/6586\n\n","tags":["Crimson","Seastore","å¼‚æ­¥ç¼–ç¨‹"]},{"title":"Mymap Myset","url":"/2025/09/19/mymap_myset/","content":"çº¢é»‘æ ‘æ¨¡æ‹Ÿå®ç°mapå’Œset\n\n\nä¸€ã€mapå’Œsetæ¨¡æ¿setç”¨valueæ ‡è¯†å…ƒç´ (valueå°±æ˜¯keyï¼Œç±»å‹ä¸ºT)ï¼Œå¹¶ä¸”æ¯ä¸ªvalueå¿…é¡»å”¯ä¸€ ã€‚\ntemplate &lt; class Key&gt;//set\n\n\n\nåœ¨mapä¸­ï¼Œé”®å€¼keyé€šå¸¸ç”¨äºæ’åºå’ŒæƒŸä¸€åœ°æ ‡è¯†å…ƒç´ ï¼Œè€Œå€¼valueä¸­å­˜å‚¨ä¸æ­¤é”®å€¼keyå…³è”çš„å†…å®¹ã€‚é”®å€¼keyå’Œå€¼valueçš„ç±»å‹å¯èƒ½ä¸åŒï¼Œå¹¶ä¸”åœ¨mapçš„å†…éƒ¨ï¼Œkeyä¸valueé€šè¿‡æˆå‘˜ç±»å‹value_typeç»‘å®šåœ¨ä¸€èµ·ï¼Œä¸ºå…¶å–åˆ«åç§°ä¸ºpairï¼š\ntypedef pair&lt;const Key, T&gt; value_type;template &lt; class Key, class T&gt;//map\n\n ç”¨çº¢é»‘æ ‘åŒæ—¶å°è£…å‡ºsetå’Œmapæ—¶ï¼Œsetä¼ ç»™valueçš„æ˜¯ä¸€ä¸ªvalueï¼Œmapä¼ ç»™valueçš„æ˜¯ä¸€ä¸ªpairï¼Œsetå’Œmapä¼ ç»™çº¢é»‘æ ‘çš„valueå†³å®šäº†è¿™æ£µæ ‘é‡Œé¢å­˜çš„èŠ‚ç‚¹å€¼ç±»å‹ã€‚ä¸Šå±‚å®¹å™¨ä¸åŒï¼Œåº•å±‚çº¢é»‘æ ‘çš„Keyå’ŒTä¹Ÿä¸åŒã€‚\n\nåœ¨ä¸Šå±‚å®¹å™¨setä¸­ï¼ŒKå’ŒTéƒ½ä»£è¡¨Keyï¼Œåº•å±‚çº¢é»‘æ ‘èŠ‚ç‚¹å½“ä¸­å­˜å‚¨Kå’ŒTéƒ½æ˜¯ä¸€æ ·çš„ï¼›mapä¸­ï¼ŒKä»£è¡¨é”®å€¼Keyï¼ŒTä»£è¡¨ç”±Keyå’ŒValueæ„æˆçš„é”®å€¼å¯¹ï¼Œåº•å±‚çº¢é»‘æ ‘ä¸­åªèƒ½å­˜å‚¨Tã€‚æ‰€ä»¥çº¢é»‘æ ‘ä¸ºäº†æ»¡è¶³åŒæ—¶æ”¯æŒsetå’Œmapï¼ŒèŠ‚ç‚¹å½“ä¸­å­˜å‚¨T\nè¿™å°±è¦å¯¹çº¢é»‘æ ‘è¿›è¡Œæ”¹åŠ¨ã€‚\näºŒã€çº¢é»‘æ ‘èŠ‚ç‚¹å®šä¹‰1.çº¢é»‘æ ‘èŠ‚ç‚¹å®šä¹‰ç”±ç±»æ¨¡æ¿template&lt;class K,class V&gt;\n\nä¿®æ”¹ä¸º\ntemplate&lt;class T&gt;\n\né‚£ä¹ˆèŠ‚ç‚¹å®šä¹‰ä¿®æ”¹ä¸º:\n//çº¢é»‘æ ‘èŠ‚ç‚¹å®šä¹‰template&lt;class T&gt;struct RBTreeNode&#123;\tRBTreeNode&lt;T&gt;* _left;//èŠ‚ç‚¹çš„å·¦å­©å­\tRBTreeNode&lt;T&gt;* _right;//èŠ‚ç‚¹çš„å³å­©å­\tRBTreeNode&lt;T&gt;* _parent;//èŠ‚ç‚¹çš„çˆ¶äº² \tT _data;//èŠ‚ç‚¹çš„å€¼ï¼Œ_dataé‡Œé¢å­˜çš„æ˜¯Kå°±ä¼ Kï¼Œå­˜çš„æ˜¯pairå°±ä¼ pair\tColour _col;//èŠ‚ç‚¹é¢œè‰² \tRBTreeNode(const T&amp; x)\t\t:_left(nullptr)\t\t, _right(nullptr)\t\t, _parent(nullptr)\t\t, _data(x)\t\t, _col(RED)\t&#123;&#125;&#125;;\n\nç”±äºçº¢é»‘æ ‘ä¸çŸ¥é“ä¸Šå±‚ä¼ çš„æ˜¯Kè¿˜æ˜¯pairï¼Œè¿™æ˜¯ç”±ä¸Šå±‚ä¼ é€’çš„æ¨¡æ¿å‚æ•°Tå†³å®šçš„ï¼Œä¸Šå±‚æ˜¯å°è£…æˆ‘çš„mapå’Œset\n2.ä»¿å‡½æ•°ï¼ˆ1ï¼‰èŠ‚ç‚¹æ¯”è¾ƒå¤§å°æ—¶å­˜åœ¨çš„é—®é¢˜çº¢é»‘æ ‘æ’å…¥èŠ‚ç‚¹æ—¶ï¼Œéœ€è¦æ¯”è¾ƒèŠ‚ç‚¹çš„å¤§å°ï¼Œkvéœ€è¦æ”¹æˆ_data:\n//æ’å…¥pair&lt;Node*, bool&gt; Insert(const T&amp; data)&#123;\tif (_root == nullptr)\t&#123;\t\t_root = new Node(data);\t\t_root-&gt;_col = BLACK;\t\treturn make_pair(_root, true);\t&#125;\t//1.å…ˆçœ‹æ ‘ä¸­ï¼Œkvæ˜¯å¦å­˜åœ¨\tNode* parent = nullptr;\tNode* cur = _root;\twhile (cur)\t&#123;\t\tif (cur-&gt;_data &lt; data)\t\t&#123;\t\t\t//kvæ¯”å½“å‰èŠ‚ç‚¹å€¼å¤§ï¼Œå‘å³èµ°\t\t\tparent = cur;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (cur-&gt;_data &gt; data)\t\t&#123;\t\t\t//kvæ¯”å½“å‰èŠ‚ç‚¹å€¼å°ï¼Œå‘å·¦èµ°\t\t\tparent = cur;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse\t\t&#123;\t\t\t//kvå’Œå½“å‰èŠ‚ç‚¹å€¼ç›¸ç­‰ï¼Œå·²å­˜åœ¨ï¼Œæ’å…¥å¤±è´¥\t\t\treturn make_pair(cur, false);\t\t&#125;\t&#125;\t//2.èµ°åˆ°è¿™é‡Œï¼Œè¯´æ˜kvåœ¨æ ‘ä¸­ä¸å­˜åœ¨ï¼Œéœ€è¦æ’å…¥kvï¼Œå¹¶ä¸”curå·²ç»ä¸ºç©ºï¼Œparentå·²ç»æ˜¯å¶å­èŠ‚ç‚¹äº†\tNode* newNode = new Node(kv);\tnewNode-&gt;_col = RED;\tif (parent-&gt;_data &lt; data)\t&#123;\t\t//kvæ¯”parentå€¼å¤§ï¼Œæ’å…¥åˆ°parentçš„å³è¾¹\t\tparent-&gt;_right = newNode;\t\tnewNode-&gt;_parent = parent;\t&#125;\telse\t&#123;\t\t//kvæ¯”parentå€¼å°ï¼Œæ’å…¥åˆ°parentçš„å·¦è¾¹\t\tparent-&gt;_left = newNode;\t\tnewNode-&gt;_parent = parent;\t&#125;\tcur = newNode;\t       //å¦‚æœçˆ¶äº²å­˜åœ¨ï¼Œä¸”çˆ¶äº²é¢œè‰²ä¸ºçº¢å°±è¦å¤„ç†\twhile (parent &amp;&amp; parent-&gt;_col == RED)\t&#123;\t\t//æƒ…å†µä¸€å’Œæƒ…å†µäºŒã€ä¸‰çš„åŒºåˆ«å…³é”®çœ‹å”å”\t\tNode* grandfather = parent-&gt;_parent;//å½“çˆ¶äº²æ˜¯çº¢è‰²æ—¶ï¼Œæ ¹æ®è§„åˆ™ï¼ˆ2ï¼‰æ ¹èŠ‚ç‚¹ä¸€å®šæ˜¯é»‘è‰²ï¼Œç¥–çˆ¶ä¸€å®šå­˜åœ¨\t\tif (parent == grandfather-&gt;_left)//çˆ¶äº²æ˜¯ç¥–çˆ¶çš„å·¦å­æ ‘\t\t&#123;\t\t\tNode* uncle = grandfather-&gt;_right;\t\t\t//æƒ…å†µä¸€ï¼šå”å”å­˜åœ¨ä¸”ä¸ºçº¢\t\t\tif (uncle-&gt;_col == RED)\t\t\t&#123;\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t//ç»§ç»­å‘ä¸Šè°ƒæ•´\t\t\t\tcur = grandfather;\t\t\t\tparent = cur-&gt;_parent;\t\t\t&#125;\t\t\telse//æƒ…å†µäºŒ+æƒ…å†µä¸‰ï¼šå”å”ä¸å­˜åœ¨æˆ–å”å”å­˜åœ¨ä¸”ä¸ºé»‘\t\t\t&#123;\t\t\t\t//æƒ…å†µäºŒï¼šå•æ—‹\t\t\t\tif (cur == parent-&gt;_left)\t\t\t\t&#123;\t\t\t\t\tRotateR(grandfather);\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\telse//æƒ…å†µä¸‰ï¼šåŒæ—‹\t\t\t\t&#123;\t\t\t\t\tRotateL(parent);\t\t\t\t\tRotateR(grandfather);\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\tbreak;//æ’å…¥ç»“æŸ\t\t\t&#125;\t\t&#125;\t\telse//çˆ¶äº²æ˜¯ç¥–çˆ¶çš„å³å­æ ‘\t\t&#123;\t\t\tNode* uncle = grandfather-&gt;_left;\t\t\t//æƒ…å†µä¸€ï¼šå”å”å­˜åœ¨ä¸”ä¸ºçº¢\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == RED)\t\t\t&#123;\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t//ç»§ç»­å¾€ä¸Šè°ƒæ•´\t\t\t\tcur = grandfather;\t\t\t\tparent = grandfather-&gt;_parent;\t\t\t&#125;\t\t\telse//æƒ…å†µäºŒ+æƒ…å†µä¸‰ï¼šå”å”ä¸å­˜åœ¨æˆ–å”å”å­˜åœ¨ä¸”ä¸ºé»‘\t\t\t&#123;\t\t\t\t//æƒ…å†µäºŒï¼šå•æ—‹\t\t\t\tif (cur == parent-&gt;_right)\t\t\t\t&#123;\t\t\t\t\tRotateL(grandfather);\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\telse//æƒ…å†µä¸‰ï¼šåŒæ—‹\t\t\t\t&#123;\t\t\t\t\tRotateR(parent);\t\t\t\t\tRotateL(grandfather);\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\tbreak;//æ’å…¥ç»“æŸ\t\t\t&#125;\t\t&#125;\t&#125;\t_root-&gt;_col = BLACK;\treturn make_pair(newNode, true);&#125;\n\nä½†æ˜¯ä»¥ä¸Šä»£ç åœ¨æ’å…¥æ–°èŠ‚å’ŒæŸ¥æ‰¾èŠ‚ç‚¹æ—¶ï¼Œå½“å’Œå½“å‰èŠ‚ç‚¹æ¯”è¾ƒå¤§å°æ—¶ï¼ŒKeyå¯ä»¥æ¯”è¾ƒï¼Œä½†æ˜¯pairæ¯”è¾ƒä¸äº†ï¼Œä¹Ÿå°±æ˜¯setå¯ä»¥æ¯”è¾ƒï¼Œä½†æ˜¯mapæ¯”è¾ƒä¸äº†ã€‚è¿™å°±éœ€è¦å†™ä¸€ä¸ªä»¿å‡½æ•°ï¼Œå¦‚æœæ˜¯mapå°±å–_dataé‡Œé¢çš„firstä¹Ÿå°±æ˜¯Keyè¿›è¡Œæ¯”è¾ƒï¼Œé€šè¿‡æ³›å‹è§£å†³çº¢é»‘æ ‘é‡Œé¢å­˜çš„æ˜¯ä»€ä¹ˆã€‚æ‰€ä»¥ä¸Šå±‚å®¹å™¨mapéœ€è¦å‘åº•å±‚çš„çº¢é»‘æ ‘æä¾›ä»¿å‡½æ•°æ¥è·å–Té‡Œé¢çš„Keyï¼Œè¿™æ ·æ— è®ºä¸Šå±‚å®¹å™¨æ˜¯setè¿˜æ˜¯mapï¼Œéƒ½å¯ä»¥ç”¨ç»Ÿä¸€çš„æ–¹å¼è¿›è¡Œæ¯”è¾ƒäº†ã€‚\n(2) ä»¿å‡½æ•°ä»¿å‡½æ•°è®©ä¸€ä¸ªç±»çš„ä½¿ç”¨çœ‹ä¸Šå»åƒä¸ªå‡½æ•°ã€‚ä»¿å‡½æ•°æ˜¯åœ¨ç±»ä¸­å®ç°äº†ä¸€ä¸ªoperator( )ï¼Œæ˜¯ä¸€ä¸ªç±»çš„å¯¹è±¡ï¼Œè¿™ä¸ªç±»å°±æœ‰äº†ç±»ä¼¼å‡½æ•°çš„è¡Œä¸ºï¼Œæ‰€ä»¥è¿™ä¸ªç±»å°±æ˜¯ä¸€ä¸ªä»¿å‡½æ•°ç±»ï¼Œç›®çš„æ˜¯ä¸ºäº†è®©å‡½æ•°æ‹¥æœ‰ç±»çš„æ€§è´¨ã€‚\nè¿™ä¸ªç±»çš„å¯¹è±¡å³ä»¿å‡½æ•°ï¼Œå¯ä»¥å½“ä½œä¸€èˆ¬å‡½æ•°å»ç”¨ï¼Œåªä¸è¿‡ä»¿å‡½æ•°çš„åŠŸèƒ½æ˜¯åœ¨ä¸€ä¸ªç±»ä¸­çš„è¿ç®—ç¬¦operator()ä¸­å®ç°çš„ï¼Œä½¿ç”¨çš„æ—¶å€™æŠŠå‡½æ•°ä½œä¸ºå‚è¿›è¡Œä¼ é€’å³å¯ã€‚\nsetæœ‰setçš„ä»¿å‡½æ•°ï¼Œmapæœ‰mapçš„ä»¿å‡½æ•°ï¼Œå°½ç®¡setçš„ä»¿å‡½æ•°çœ‹èµ·æ¥æ²¡æœ‰ä»€ä¹ˆä½œç”¨ï¼Œä½†æ˜¯ï¼Œå¿…é¡»è¦æŠŠå®ƒä¼ ç»™åº•å±‚çº¢é»‘æ ‘ï¼Œè¿™æ ·çº¢é»‘æ ‘å°±èƒ½æ ¹æ®ä»¿å‡½æ•°åˆ†åˆ«è·å–setçš„keyå’Œmapçš„firstã€‚\nâ‘ ï¼šsetçš„ä»¿å‡½æ•°\nnamespace delia&#123;\ttemplate&lt;class K&gt;\tclass set\t&#123;\t\t//ä»¿å‡½æ•°ï¼Œè·å–setçš„key\t\tstruct SetKeyOfT\t\t&#123;\t\t\tconst K&amp; operator()(const K&amp; key)\t\t\t&#123;\t\t\t\treturn key;\t\t\t&#125;\t\t&#125;;        public:\t\tbool insert(const K&amp; k)\t\t&#123;\t\t\t_t.Insert(k);\t\t\treturn true;\t\t&#125; \tprivate:\t\tRBTree&lt;K, K,SetKeyOfT&gt; _t;\t&#125;;&#125;\n\nâ‘¡mapçš„ä»¿å‡½æ•°\nnamespace delia&#123;\ttemplate&lt;class K,class V&gt;\tclass map\t&#123;\t\t//ä»¿å‡½æ•°ï¼Œè·å–mapçš„first\t\tstruct MapKeyOfT\t\t&#123;\t\t\tconst K&amp; operator()(const pair&lt;const K, V&gt;&amp; kv)\t\t\t&#123;\t\t\t\treturn kv.first;\t\t\t&#125;\t\t&#125;;     public:        //æ’å…¥\t\tbool insert(const pair&lt;const K, V&gt;&amp; kv)\t\t&#123;\t\t\t_t.Insert(kv);\t\t\treturn true;\t\t&#125;\tprivate:\t\tRBTree&lt;K, pair&lt;const K, V&gt;, MapKeyOfT&gt; _t;\t&#125;;&#125;\n\næœ‰äº†ä»¿å‡½æ•°çº¢é»‘æ ‘çš„ç±»åœ¨å®ç°æ—¶ï¼Œå°±è¦åœ¨æ¨¡æ¿å‚æ•°ä¸­å¢åŠ KeyOfTä»¿å‡½æ•°ã€‚\nï¼ˆ3ï¼‰ä¿®æ”¹çº¢é»‘æ ‘å®šä¹‰template&lt;class K, class T, class KeyOfT&gt;class RBTree&#123;\ttypedef RBTreeNode&lt;T&gt; Node;\tprivate:\tNode* _root;&#125;;\n\nï¼ˆ4ï¼‰ä¿®æ”¹çº¢é»‘æ ‘æ’å…¥//æ’å…¥pair&lt;Node*, bool&gt; Insert(const pair&lt;K, V&gt;&amp; kv)&#123;\tif (_root == nullptr)\t&#123;\t\t_root = new Node(kv);\t\t_root-&gt;_col = BLACK;\t\treturn make_pair(_root, true);\t&#125;\tKeyOfT kot;\t//1.å…ˆçœ‹æ ‘ä¸­ï¼Œkvæ˜¯å¦å­˜åœ¨\tNode* parent = nullptr;\tNode* cur = _root;\twhile (cur)\t&#123;\t\tif (kot(cur-&gt;_data) &lt; kot(data))\t\t&#123;\t\t\t//kvæ¯”å½“å‰èŠ‚ç‚¹å€¼å¤§ï¼Œå‘å³èµ°\t\t\tparent = cur;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (kot(cur-&gt;_data) &gt; kot(data))\t\t&#123;\t\t\t//kvæ¯”å½“å‰èŠ‚ç‚¹å€¼å°ï¼Œå‘å·¦èµ°\t\t\tparent = cur;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse\t\t&#123;\t\t\t//kvå’Œå½“å‰èŠ‚ç‚¹å€¼ç›¸ç­‰ï¼Œå·²å­˜åœ¨ï¼Œæ’å…¥å¤±è´¥\t\t\treturn make_pair(cur, false);\t\t&#125;\t&#125;\t//2.èµ°åˆ°è¿™é‡Œï¼Œè¯´æ˜kvåœ¨æ ‘ä¸­ä¸å­˜åœ¨ï¼Œéœ€è¦æ’å…¥kvï¼Œå¹¶ä¸”curå·²ç»ä¸ºç©ºï¼Œparentå·²ç»æ˜¯å¶å­èŠ‚ç‚¹äº†\tNode* newNode = new Node(kv);\tnewNode-&gt;_col = RED;\tif (kot(parent-&gt;_data) &lt; kot(data))\t&#123;\t\t//kvæ¯”parentå€¼å¤§ï¼Œæ’å…¥åˆ°parentçš„å³è¾¹\t\tparent-&gt;_right = newNode;\t\tnewNode-&gt;_parent = parent;\t&#125;\telse\t&#123;\t\t//kvæ¯”parentå€¼å°ï¼Œæ’å…¥åˆ°parentçš„å·¦è¾¹\t\tparent-&gt;_left = newNode;\t\tnewNode-&gt;_parent = parent;\t&#125;\tcur = newNode;\t//å¦‚æœçˆ¶äº²å­˜åœ¨ï¼Œä¸”çˆ¶äº²é¢œè‰²ä¸ºçº¢å°±è¦å¤„ç†\twhile (parent &amp;&amp; parent-&gt;_col == RED)\t&#123;\t\t//æƒ…å†µä¸€å’Œæƒ…å†µäºŒã€ä¸‰çš„åŒºåˆ«å…³é”®çœ‹å”å”\t\tNode* grandfather = parent-&gt;_parent;//å½“çˆ¶äº²æ˜¯çº¢è‰²æ—¶ï¼Œæ ¹æ®è§„åˆ™ï¼ˆ2ï¼‰æ ¹èŠ‚ç‚¹ä¸€å®šæ˜¯é»‘è‰²ï¼Œç¥–çˆ¶ä¸€å®šå­˜åœ¨\t\tif (parent == grandfather-&gt;_left)//çˆ¶äº²æ˜¯ç¥–çˆ¶çš„å·¦å­æ ‘\t\t&#123;\t\t\tNode* uncle = grandfather-&gt;_right;\t\t\t//æƒ…å†µä¸€ï¼šå”å”å­˜åœ¨ä¸”ä¸ºçº¢\t\t\tif (uncle-&gt;_col == RED)\t\t\t&#123;\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t//ç»§ç»­å‘ä¸Šè°ƒæ•´\t\t\t\tcur = grandfather;\t\t\t\tparent = cur-&gt;_parent;\t\t\t&#125;\t\t\telse//æƒ…å†µäºŒ+æƒ…å†µä¸‰ï¼šå”å”ä¸å­˜åœ¨æˆ–å”å”å­˜åœ¨ä¸”ä¸ºé»‘\t\t\t&#123;\t\t\t\t//æƒ…å†µäºŒï¼šå•æ—‹\t\t\t\tif (cur == parent-&gt;_left)\t\t\t\t&#123;\t\t\t\t\tRotateR(grandfather);\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\telse//æƒ…å†µä¸‰ï¼šåŒæ—‹\t\t\t\t&#123;\t\t\t\t\tRotateL(parent);\t\t\t\t\tRotateR(grandfather);\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\tbreak;//æ’å…¥ç»“æŸ\t\t\t&#125;\t\t&#125;\t\telse//çˆ¶äº²æ˜¯ç¥–çˆ¶çš„å³å­æ ‘\t\t&#123;\t\t\tNode* uncle = grandfather-&gt;_left;\t\t\t//æƒ…å†µä¸€ï¼šå”å”å­˜åœ¨ä¸”ä¸ºçº¢\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == RED)\t\t\t&#123;\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t//ç»§ç»­å¾€ä¸Šè°ƒæ•´\t\t\t\tcur = grandfather;\t\t\t\tparent = grandfather-&gt;_parent;\t\t\t&#125;\t\t\telse//æƒ…å†µäºŒ+æƒ…å†µä¸‰ï¼šå”å”ä¸å­˜åœ¨æˆ–å”å”å­˜åœ¨ä¸”ä¸ºé»‘\t\t\t&#123;\t\t\t\t//æƒ…å†µäºŒï¼šå•æ—‹\t\t\t\tif (cur == parent-&gt;_right)\t\t\t\t&#123;\t\t\t\t\tRotateL(grandfather);\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\telse//æƒ…å†µä¸‰ï¼šåŒæ—‹\t\t\t\t&#123;\t\t\t\t\tRotateR(parent);\t\t\t\t\tRotateL(grandfather);\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\tbreak;//æ’å…¥ç»“æŸ\t\t\t&#125;\t\t&#125;\t&#125;\t_root-&gt;_col = BLACK;\treturn make_pair(newNode, true);&#125;void RotateR(Node* parent)&#123;\tNode* subL = parent-&gt;_left;\tNode* subLR = nullptr;\tif (subL)\t&#123;\t\tsubLR = subL-&gt;_right;\t&#125;\t//1.å·¦å­æ ‘çš„å³å­æ ‘å˜æˆ‘çš„å·¦å­æ ‘\tparent-&gt;_left = subLR;\tif (subLR)\t&#123;\t\tsubLR-&gt;_parent = parent;\t&#125;\t//å·¦å­æ ‘å˜çˆ¶äº²\tsubL-&gt;_right = parent;\tNode* parentParent = parent-&gt;_parent;\tparent-&gt;_parent = subL;\tif (parent == _root)//parentæ˜¯æ ¹\t&#123;\t\t_root = subL;\t\t_root-&gt;_parent = nullptr;\t&#125;\telse//parentä¸æ˜¯æ ¹ï¼Œæ˜¯å­æ ‘\t&#123;\t\tif (parentParent-&gt;_left == parent)\t\t&#123;\t\t\t//parentæ˜¯è‡ªå·±çˆ¶äº²çš„å·¦å­æ ‘,å°†subLä½œä¸ºparentçˆ¶äº²çš„å·¦å­©å­\t\t\tparentParent-&gt;_left = subL;\t\t&#125;\t\telse\t\t&#123;\t\t\t//parentæ˜¯è‡ªå·±çˆ¶äº²çš„å³å­æ ‘,å°†subLä½œä¸ºparentçˆ¶äº²çš„å³å­©å­\t\t\tparentParent-&gt;_right = subL;\t\t&#125;\t\t//subLçš„çˆ¶äº²å°±æ˜¯parentçš„çˆ¶äº²\t\tsubL-&gt;_parent = parentParent;\t&#125;&#125;void RotateL(Node* parent)&#123;\tNode* subR = parent-&gt;_right;\tNode* subRL = nullptr;\tif (subR)\t&#123;\t\tsubRL = subR-&gt;_left;\t&#125;\t//1.å³å­æ ‘çš„å·¦å­æ ‘å˜æˆ‘çš„å³å­æ ‘\tparent-&gt;_right = subRL;\tif (subRL)\t&#123;\t\tsubRL-&gt;_parent = parent;\t&#125;\t//2.å³å­æ ‘å˜çˆ¶äº²\tsubR-&gt;_left = parent;\tNode* parentParent = parent-&gt;_parent;\tparent-&gt;_parent = subR;\tif (parent == _root)//parentæ˜¯æ ¹\t&#123;\t\t_root = parent;\t\t_root-&gt;_parent = nullptr;\t&#125;\telse//parentä¸æ˜¯æ ¹ï¼Œæ˜¯å­æ ‘\t&#123;\t\tif (parentParent-&gt;_left == parent)\t\t&#123;\t\t\t//parentæ˜¯è‡ªå·±çˆ¶äº²çš„å·¦å­æ ‘,å°†subRä½œä¸ºparentçˆ¶äº²çš„å·¦å­©å­\t\t\tparentParent-&gt;_left = subR;\t\t&#125;\t\telse\t\t&#123;\t\t\t//parentæ˜¯è‡ªå·±çˆ¶äº²çš„å³å­æ ‘,å°†subRä½œä¸ºparentçˆ¶äº²çš„å³å­©å­\t\t\tparentParent-&gt;_right = subR;\t\t&#125;\t\t//subRçš„çˆ¶äº²å°±æ˜¯parentçš„çˆ¶äº²\t\tsubR-&gt;_parent = parentParent;\t&#125;&#125;\n\nï¼ˆ5ï¼‰ä¿®æ”¹çº¢é»‘æ ‘æŸ¥æ‰¾//æŸ¥æ‰¾Node* Find(const K&amp; key)&#123;\tKeyOfT kot;\tNode* cur = _root;\twhile (cur)\t&#123;\t\tif (kot(cur-&gt;_data) &lt; key)\t\t&#123;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (kot(cur-&gt;_data) &gt; key)\t\t&#123;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse\t\t&#123;\t\t\treturn cur;\t\t&#125;\t&#125;\treturn nullptr;//ç©ºæ ‘ï¼Œç›´æ¥è¿”å›&#125;\n\nä¸‰ã€çº¢é»‘æ ‘è¿­ä»£å™¨mapå’Œsetçš„è¿­ä»£å™¨çš„å®ç°å…¶å®æœ¬è´¨ä¸Šæ˜¯çº¢é»‘æ ‘è¿­ä»£å™¨çš„å®ç°ï¼Œè¿­ä»£å™¨çš„å®ç°éœ€è¦å®šä¹‰æ¨¡æ¿ç±»å‹ã€æ¨¡æ¿ç±»å‹å¼•ç”¨ã€æ¨¡æ¿ç±»å‹æŒ‡é’ˆã€‚ \n1.çº¢é»‘æ ‘ä¸­è¿­ä»£å™¨é‡å‘½å åœ¨çº¢é»‘æ ‘ä¸­é‡å‘½åæ¨¡æ¿ç±»å‹ã€æ¨¡æ¿ç±»å‹å¼•ç”¨ã€æ¨¡æ¿ç±»å‹æŒ‡é’ˆï¼Œå®šä¹‰ä¸ºpublicï¼Œå¤–éƒ¨å°±èƒ½ä½¿ç”¨iteratoräº†ï¼š\ntemplate&lt;class K, class T, class KeyOfT&gt;class RBTree&#123;\ttypedef RBTreeNode&lt;T&gt; Node; public:\ttypedef __TreeIterator&lt;T, T&amp;, T*&gt; iterator;//æ¨¡æ¿ç±»å‹ã€æ¨¡æ¿ç±»å‹å¼•ç”¨ã€æ¨¡æ¿ç±»å‹æŒ‡é’ˆ        //çº¢é»‘æ ‘å‡½æ•°...    private:\tNode* _root;&#125;;\n\n2.æ­£å‘è¿­ä»£å™¨å®šä¹‰çº¢é»‘æ ‘çš„è¿­ä»£å™¨çš„æœ¬è´¨æ˜¯å¯¹èŠ‚ç‚¹æŒ‡é’ˆè¿›è¡Œå°è£…ï¼Œæ‰€ä»¥è¿­ä»£å™¨ä¸­åªæœ‰å°è£…çº¢é»‘æ ‘èŠ‚ç‚¹æŒ‡é’ˆè¿™ä¸€ä¸ªæˆå‘˜å˜é‡ ã€‚æ­£å‘è¿­ä»£å™¨ï¼š\ntemplate&lt;class T,class Ref,class ptr&gt;struct __TreeIterator&#123;\ttypedef RBTreeNode&lt;T&gt; Node;\ttypedef __TreeIterator&lt;T, Ref, ptr&gt; Self;      \tNode* _node;//æˆå‘˜å˜é‡\t&#125;;\n\n3.è¿­ä»£å™¨æ„é€ ç”¨èŠ‚ç‚¹æŒ‡é’ˆæ„é€ æ­£å‘è¿­ä»£å™¨ï¼š\n//æ„é€ å‡½æ•°__TreeIterator(Node* node)\t:_node(node)&#123;&#125;\n\n4.æ­£å‘è¿­ä»£å™¨é‡è½½*Refå¯¹æ­£å‘è¿­ä»£å™¨è§£å¼•ç”¨ï¼Œè¿”å›èŠ‚ç‚¹æ•°æ®å¼•ç”¨\n//* è§£å¼•ç”¨ï¼Œè¿”å›èŠ‚ç‚¹æ•°æ®Ref Operator*()&#123;\treturn _node-&gt;_data;&#125;\n\n5.æ­£å‘è¿­ä»£å™¨é‡è½½-&gt;Ptrå¯¹æ­£å‘è¿­ä»£å™¨ä½¿ç”¨-&gt;ï¼Œè¿”å›èŠ‚ç‚¹æ•°æ®æŒ‡é’ˆï¼š\n//-&gt; è¿”å›èŠ‚ç‚¹æ•°æ®åœ°å€Ptr Operator-&gt;()&#123;\treturn &amp;_node-&gt;_data;&#125;\n\n6.æ­£å‘è¿­ä»£å™¨é‡è½½&#x3D;&#x3D;åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ\n//åˆ¤æ–­ä¸¤ä¸ªè¿­ä»£å™¨æ˜¯å¦ç›¸åŒbool operator==(const Self&amp; s)&#123;\treturn _node == s._node;//åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦ç›¸åŒ&#125;\n\n7.æ­£å‘è¿­ä»£å™¨é‡è½½ï¼&#x3D;åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦ä¸åŒ\n//åˆ¤æ–­ä¸¤ä¸ªè¿­ä»£å™¨æ˜¯å¦ä¸åŒbool operator!=(const Self&amp; s)&#123;\treturn _node != s._node;//åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦ä¸åŒ&#125;\n\n8.æ­£å‘è¿­ä»£å™¨++â‘ å½“èŠ‚ç‚¹çš„å³å­æ ‘ä¸ä¸ºç©ºæ—¶ï¼Œ++å°±è¦èµ°åˆ°å³å­æ ‘çš„æœ€å·¦èŠ‚ç‚¹\n â‘¡å½“èŠ‚ç‚¹çš„å³å­æ ‘ä¸ºç©ºæ—¶ï¼Œ++å°±è¦èµ°åˆ°èŠ‚ç‚¹çš„çˆ¶äº²\n\t//çº¢é»‘æ ‘è¿­ä»£å™¨çš„++ä¹Ÿå°±æ˜¯çº¢é»‘æ ‘çš„++\tSelf operator++()\t&#123;\t\t//1.å³å­æ ‘ä¸ä¸ºç©º\t\tif (_node-&gt;_right)\t\t&#123;\t\t\t//ä¸‹ä¸€ä¸ªè®¿é—®çš„æ˜¯å³æ ‘çš„ä¸­åºç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå³å³å­æ ‘æœ€å·¦èŠ‚ç‚¹ï¼‰ã€‚\t\t\tNode* left = _node-&gt;_right; \t\t\t//æ‰¾æœ€å·¦èŠ‚ç‚¹\t\t\twhile (left-&gt;_left)\t\t\t&#123;\t\t\t\tleft = left-&gt;_left;\t\t\t&#125;\t\t\t_node = left;\t\t&#125;\t\telse//2.å³å­æ ‘ä¸ºç©ºï¼Œä¸‹ä¸€ä¸ªè®¿é—®çš„å°±æ˜¯å½“å‰èŠ‚ç‚¹çš„çˆ¶äº²\t\t&#123;\t\t\tNode* cur = _node;\t\t\tNode* parent = cur-&gt;_parent;\t\t\twhile (parent &amp;&amp; cur == parent-&gt;_right)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_parent;\t\t\t\tparent = parent-&gt;_parent;\t\t\t&#125;\t\t\t_node = parent;\t\t&#125; \t\treturn *this;\t&#125;&#125;;\n\n9.æ­£å‘è¿­ä»£å™¨â€“ â‘ å½“èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸ä¸ºç©ºæ—¶ï¼Œ++å°±è¦èµ°åˆ°å·¦å­æ ‘çš„æœ€å³èŠ‚ç‚¹\n â‘¡å½“èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸ºç©ºæ—¶ï¼Œ++å°±è¦èµ°åˆ°èŠ‚ç‚¹çš„çˆ¶äº²\n//çº¢é»‘æ ‘è¿­ä»£å™¨çš„--ä¹Ÿå°±æ˜¯çº¢é»‘æ ‘çš„--Self operator--()&#123;\t//1.å·¦å­æ ‘ä¸ä¸ºç©º\tif (_node-&gt;_left)\t&#123;\t\t//ä¸‹ä¸€ä¸ªè®¿é—®çš„æ˜¯å·¦æ ‘çš„ä¸­åºå·¦åèŠ‚ç‚¹ï¼ˆå³åšå­æ ‘æœ€å³èŠ‚ç‚¹ï¼‰ã€‚\t\tNode* right = _node-&gt;_left;\t\t//æ‰¾æœ€å³èŠ‚ç‚¹\t\twhile (right-&gt;_right)\t\t&#123;\t\t\tright = right-&gt;_right;\t\t&#125;\t\t_node = right;\t&#125;\telse//2.å·¦å­æ ‘ä¸ºç©ºï¼Œä¸‹ä¸€ä¸ªè®¿é—®çš„å°±æ˜¯å½“å‰èŠ‚ç‚¹çš„çˆ¶äº²\t&#123;\t\tNode* cur = _node;\t\tNode* parent = cur-&gt;_parent;\t\twhile (parent &amp;&amp; cur == parent-&gt;_left)\t\t&#123;\t\t\tcur = cur-&gt;_parent;\t\t\tparent = parent-&gt;_parent;\t\t&#125;\t\t_node = parent;\t&#125;\treturn *this;&#125;\n\n10.çº¢é»‘æ ‘ä¸­å®ç°è¿­ä»£å™¨å®ç°begin( )æ‰¾æœ€å·¦èŠ‚ç‚¹ï¼Œend( )æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªä½ç½®\ntemplate&lt;class K, class T, class KeyOfT&gt;class RBTree&#123;\ttypedef RBTreeNode&lt;T&gt; Node; public:\ttypedef __TreeIterator&lt;T, T&amp;, T*&gt; iterator;//æ¨¡æ¿ç±»å‹ã€æ¨¡æ¿ç±»å‹å¼•ç”¨ã€æ¨¡æ¿ç±»å‹æŒ‡é’ˆ        //æ‰¾æœ€å·¦èŠ‚ç‚¹\titerator begin()\t&#123;\t\tNode* left = _root;\t\twhile (left &amp;&amp; left-&gt;_left)\t\t&#123;\t\t\tleft = left-&gt;_left;\t\t&#125; \t\treturn iterator(left)//è¿”å›æœ€å·¦èŠ‚ç‚¹çš„æ­£å‘è¿­ä»£å™¨\t&#125; \t//ç»“æŸ\titerator end()\t&#123;\t\treturn iterator(nullptr);\t&#125;    private:\tNode* _root;&#125;;\n\nå››ã€setæ¨¡æ‹Ÿå®ç°è°ƒç”¨çº¢é»‘æ ‘å¯¹åº”æ¥å£å®ç°setï¼Œæ’å…¥å’ŒæŸ¥æ‰¾å‡½æ•°è¿”å›å€¼å½“ä¸­çš„èŠ‚ç‚¹æŒ‡é’ˆæ”¹ä¸ºè¿­ä»£å™¨:\n#pragma once#include &quot;RBTree.h&quot;namespace delia&#123;\ttemplate&lt;class K&gt;\tclass set\t&#123;\t\t//ä»¿å‡½æ•°ï¼Œè·å–setçš„key\t\tstruct SetKeyOfT\t\t&#123;\t\t\tconst K&amp; operator()(const K&amp; key)\t\t\t&#123;\t\t\t\treturn key;\t\t\t&#125;\t\t&#125;;\tpublic:\t\ttypedef typename RBTree&lt;K, K, SetKeyOfT&gt;::iterator iterator;\t\t\t\t//è¿­ä»£å™¨å¼€å§‹\t\titerator begin()\t\t&#123;\t\t\treturn _t.begin();\t\t&#125; \t\t//è¿­ä»£å™¨ç»“æŸ\t\titerator end()\t\t&#123;\t\t\treturn _t.end();\t\t&#125; \t\t//æ’å…¥å‡½æ•°\t\tpair&lt;iterator,bool&gt; insert(const K&amp; key)\t\t&#123;\t\t\t\t\t\treturn _t.Insert(key);\t\t&#125; \t\t//æŸ¥æ‰¾\t\titerator find(const K&amp; key)\t\t&#123;\t\t\treturn _t.find(key);\t\t&#125;\tprivate:\t\tRBTree&lt;K, K, SetKeyOfT&gt; _t;\t&#125;;&#125;\n\näº”ã€mapæ¨¡æ‹Ÿå®ç°è°ƒç”¨çº¢é»‘æ ‘å¯¹åº”æ¥å£å®ç°mapï¼Œæ’å…¥å’ŒæŸ¥æ‰¾å‡½æ•°è¿”å›å€¼å½“ä¸­çš„èŠ‚ç‚¹æŒ‡é’ˆæ”¹ä¸ºè¿­ä»£å™¨ï¼Œå¢åŠ operator[ ]çš„é‡è½½:\n#pragma once#include &quot;RBTree.h&quot;namespace delia&#123;\ttemplate&lt;class K, class V&gt;\tclass map\t&#123;\t\t//ä»¿å‡½æ•°ï¼Œè·å–mapçš„first\t\tstruct MapKeyOfT\t\t&#123;\t\t\tconst K&amp; operator()(const pair&lt;const K, V&gt;&amp; kv)\t\t\t&#123;\t\t\t\treturn kv.first;\t\t\t&#125;\t\t&#125;;\tpublic:\t\ttypedef typename RBTree&lt;K, K, MapKeyOfT&gt;::iterator iterator; \t\t//è¿­ä»£å™¨å¼€å§‹\t\titerator begin()\t\t&#123;\t\t\treturn _t.begin();\t\t&#125; \t\t//è¿­ä»£å™¨ç»“æŸ\t\titerator end()\t\t&#123;\t\t\treturn _t.end();\t\t&#125; \t\t//æ’å…¥\t\tpair&lt;iterator, bool&gt; insert(const pair&lt;const K, V&gt;&amp; kv)\t\t&#123;\t\t\treturn _t.Insert(kv);\t\t&#125; \t\t//é‡è½½operator[]\t\tV&amp; operator[](const K&amp; key)\t\t&#123;\t\t\tpair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));\t\t\titerator it = ret.first;\t\t\treturn it-&gt;second;\t\t&#125; \t\t//æŸ¥æ‰¾\t\titerator find(const K&amp; key)\t\t&#123;\t\t\treturn _t.find(key);\t\t&#125; \tprivate:\t\tRBTree&lt;K, pair&lt;const K, V&gt;, MapKeyOfT&gt; _t;\t&#125;;&#125;\n\nå…­ã€çº¢é»‘æ ‘å®Œæ•´ä»£ç æ®µ#pragma once#include&lt;iostream&gt;using namespace std;  //èŠ‚ç‚¹é¢œè‰²enum Colour&#123;\tRED,\tBLACK,&#125;; //çº¢é»‘æ ‘èŠ‚ç‚¹å®šä¹‰template&lt;class T&gt;struct RBTreeNode&#123;\tRBTreeNode&lt;T&gt;* _left;//èŠ‚ç‚¹çš„å·¦å­©å­\tRBTreeNode&lt;T&gt;* _right;//èŠ‚ç‚¹çš„å³å­©å­\tRBTreeNode&lt;T&gt;* _parent;//èŠ‚ç‚¹çš„çˆ¶äº² \tT _data;//èŠ‚ç‚¹çš„å€¼\tColour _col;//èŠ‚ç‚¹é¢œè‰² \tRBTreeNode(const T&amp; x)\t\t:_left(nullptr)\t\t, _right(nullptr)\t\t, _parent(nullptr)\t\t, _data(x)\t\t, _col(RED)\t&#123;&#125;&#125;;  template&lt;class T,class Ref,class ptr&gt;struct __TreeIterator&#123;\ttypedef RBTreeNode&lt;T&gt; Node;\ttypedef __TreeIterator&lt;T, Ref, ptr&gt; Self; \tNode* _node; \t//æ„é€ å‡½æ•°\t__TreeIterator(Node* node)\t\t:_node(node)\t&#123;&#125;\t\t//* è§£å¼•ç”¨ï¼Œè¿”å›èŠ‚ç‚¹æ•°æ®\tRef operator*()\t&#123;\t\treturn _node-&gt;_data;\t&#125; \t//-&gt; è¿”å›èŠ‚ç‚¹æ•°æ®åœ°å€\t//Ptr operator-&gt;()\t//&#123;\t//\treturn &amp;_node-&gt;_data;\t//&#125; \t//åˆ¤æ–­ä¸¤ä¸ªè¿­ä»£å™¨æ˜¯å¦ç›¸åŒ\tbool operator==(const Self&amp; s)\t&#123;\t\treturn _node == s._node;\t&#125; \t//åˆ¤æ–­ä¸¤ä¸ªè¿­ä»£å™¨æ˜¯å¦ä¸åŒ\tbool operator!=(const Self&amp; s)\t&#123;\t\treturn _node != s._node;\t&#125; \t//çº¢é»‘æ ‘è¿­ä»£å™¨çš„++ä¹Ÿå°±æ˜¯çº¢é»‘æ ‘çš„++\tSelf operator++()\t&#123;\t\t//1.å³å­æ ‘ä¸ä¸ºç©º\t\tif (_node-&gt;_right)\t\t&#123;\t\t\t//ä¸‹ä¸€ä¸ªè®¿é—®çš„æ˜¯å³æ ‘çš„ä¸­åºç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå³å³å­æ ‘æœ€å·¦èŠ‚ç‚¹ï¼‰ã€‚\t\t\tNode* left = _node-&gt;_right; \t\t\t//æ‰¾æœ€å·¦èŠ‚ç‚¹\t\t\twhile (left-&gt;_left)\t\t\t&#123;\t\t\t\tleft = left-&gt;_left;\t\t\t&#125;\t\t\t_node = left;\t\t&#125;\t\telse//2.å³å­æ ‘ä¸ºç©ºï¼Œä¸‹ä¸€ä¸ªè®¿é—®çš„å°±æ˜¯å½“å‰èŠ‚ç‚¹çš„çˆ¶äº²\t\t&#123;\t\t\tNode* cur = _node;\t\t\tNode* parent = cur-&gt;_parent;\t\t\twhile (parent &amp;&amp; cur == parent-&gt;_right)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_parent;\t\t\t\tparent = parent-&gt;_parent;\t\t\t&#125;\t\t\t_node = parent;\t\t&#125; \t\treturn *this;\t&#125; \t//çº¢é»‘æ ‘è¿­ä»£å™¨çš„--ä¹Ÿå°±æ˜¯çº¢é»‘æ ‘çš„--\tSelf operator--()\t&#123;\t\t//1.å·¦å­æ ‘ä¸ä¸ºç©º\t\tif (_node-&gt;_left)\t\t&#123;\t\t\t//ä¸‹ä¸€ä¸ªè®¿é—®çš„æ˜¯å·¦æ ‘çš„ä¸­åºå·¦åèŠ‚ç‚¹ï¼ˆå³åšå­æ ‘æœ€å³èŠ‚ç‚¹ï¼‰ã€‚\t\t\tNode* right = _node-&gt;_left; \t\t\t//æ‰¾æœ€å³èŠ‚ç‚¹\t\t\twhile (right-&gt;_right)\t\t\t&#123;\t\t\t\tright = right-&gt;_right;\t\t\t&#125;\t\t\t_node = right;\t\t&#125;\t\telse//2.å·¦å­æ ‘ä¸ºç©ºï¼Œä¸‹ä¸€ä¸ªè®¿é—®çš„å°±æ˜¯å½“å‰èŠ‚ç‚¹çš„çˆ¶äº²\t\t&#123;\t\t\tNode* cur = _node;\t\t\tNode* parent = cur-&gt;_parent;\t\t\twhile (parent &amp;&amp; cur == parent-&gt;_left)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_parent;\t\t\t\tparent = parent-&gt;_parent;\t\t\t&#125;\t\t\t_node = parent;\t\t&#125; \t\treturn *this;\t&#125;  &#125;; //æ’å…¥èŠ‚ç‚¹é¢œè‰²æ˜¯çº¢è‰²å¥½ï¼Œè¿˜æ˜¯é»‘è‰²å¥½ï¼Œçº¢è‰²//å› ä¸ºæ’å…¥çº¢è‰²èŠ‚ç‚¹ï¼Œå¯èƒ½ç ´åè§„åˆ™3ï¼Œå½±å“ä¸å¤§//æ’å…¥é»‘è‰²èŠ‚ç‚¹ï¼Œä¸€å®šç ´åè§„åˆ™4 ï¼Œå¹¶ä¸”å½±å“å…¶ä»–è·¯å¾„ï¼Œå½±å“å¾ˆå¤§ template&lt;class K, class T, class KeyOfT&gt;class RBTree&#123;\ttypedef RBTreeNode&lt;T&gt; Node;public:\ttypedef __TreeIterator&lt;T, T&amp;, T*&gt; iterator;//æ¨¡æ¿ç±»å‹ã€æ¨¡æ¿ç±»å‹å¼•ç”¨ã€æ¨¡æ¿ç±»å‹æŒ‡é’ˆ \t//æ„é€ å‡½æ•°\tRBTree()\t\t:_root(nullpte)\t&#123;&#125; \t//ææ„\t~RBTree()\t&#123;\t\t_Destroy(_root);\t\t_root = nullptr;\t&#125; \tvoid _Destroy(Node* root)\t&#123;\t\tif (root == nullptr)\t\t&#123;\t\t\treturn;\t\t&#125;\t\t_Destroy(root-&gt;_left);\t\t_Destroy(root-&gt;_right);\t\tdelete root;\t&#125; \t//æ‰¾æœ€å·¦èŠ‚ç‚¹\titerator begin()\t&#123;\t\tNode* left = _root;\t\twhile (left &amp;&amp; left-&gt;_left)\t\t&#123;\t\t\tleft = left-&gt;_left;\t\t&#125; \t\treturn iterator(left);//è¿”å›æœ€å·¦èŠ‚ç‚¹çš„æ­£å‘è¿­ä»£å™¨\t&#125; \t//ç»“æŸ\titerator end()\t&#123;\t\treturn iterator(nullptr);\t&#125; \t//æ„é€ å‡½æ•°\tRBTree()\t\t:_root(nullptr)\t&#123;&#125; \tvoid Destroy(Node* root)\t&#123;\t\tif (root == nullptr)\t\t&#123;\t\t\treturn;\t\t&#125; \t\tDestroy(root-&gt;_left);\t\tDestroy(root-&gt;_right);\t&#125;\t~RBTree()\t&#123;\t\tDestroy(_root);\t\t_root = nullptr;\t&#125; \t//æ’å…¥\tpair&lt;Node*, bool&gt; Insert(const T&amp; data)\t&#123;\t\tif (_root == nullptr)\t\t&#123;\t\t\t_root = new Node(data);\t\t\t_root-&gt;_col = BLACK;\t\t\treturn make_pair(_root, true);\t\t&#125; \t\tKeyOfT kot; \t\t//1.å…ˆçœ‹æ ‘ä¸­ï¼Œkvæ˜¯å¦å­˜åœ¨\t\tNode* parent = nullptr;\t\tNode* cur = _root;\t\twhile (cur)\t\t&#123;\t\t\tif (kot(cur-&gt;_data) &lt; kot(data))\t\t\t&#123;\t\t\t\t//kvæ¯”å½“å‰èŠ‚ç‚¹å€¼å¤§ï¼Œå‘å³èµ°\t\t\t\tparent = cur;\t\t\t\tcur = cur-&gt;_right;\t\t\t&#125;\t\t\telse if (kot(cur-&gt;_data) &gt; kot(data))\t\t\t&#123;\t\t\t\t//kvæ¯”å½“å‰èŠ‚ç‚¹å€¼å°ï¼Œå‘å·¦èµ°\t\t\t\tparent = cur;\t\t\t\tcur = cur-&gt;_left;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//kvå’Œå½“å‰èŠ‚ç‚¹å€¼ç›¸ç­‰ï¼Œå·²å­˜åœ¨ï¼Œæ’å…¥å¤±è´¥\t\t\t\treturn make_pair(cur, false);\t\t\t&#125;\t\t&#125; \t\t//2.èµ°åˆ°è¿™é‡Œï¼Œè¯´æ˜kvåœ¨æ ‘ä¸­ä¸å­˜åœ¨ï¼Œéœ€è¦æ’å…¥kvï¼Œå¹¶ä¸”curå·²ç»ä¸ºç©ºï¼Œparentå·²ç»æ˜¯å¶å­èŠ‚ç‚¹äº†\t\tNode* newNode = new Node(data);\t\tnewNode-&gt;_col = RED;\t\tif (kot(parent-&gt;_data) &lt; kot(data))\t\t&#123;\t\t\t//kvæ¯”parentå€¼å¤§ï¼Œæ’å…¥åˆ°parentçš„å³è¾¹\t\t\tparent-&gt;_right = newNode;\t\t\tnewNode-&gt;_parent = parent;\t\t&#125;\t\telse\t\t&#123;\t\t\t//kvæ¯”parentå€¼å°ï¼Œæ’å…¥åˆ°parentçš„å·¦è¾¹\t\t\tparent-&gt;_left = newNode;\t\t\tnewNode-&gt;_parent = parent;\t\t&#125;\t\tcur = newNode; \t\t//å¦‚æœçˆ¶äº²å­˜åœ¨ï¼Œä¸”çˆ¶äº²é¢œè‰²ä¸ºçº¢å°±è¦å¤„ç†\t\twhile (parent &amp;&amp; parent-&gt;_col == RED)\t\t&#123;\t\t\t//æƒ…å†µä¸€å’Œæƒ…å†µäºŒã€ä¸‰çš„åŒºåˆ«å…³é”®çœ‹å”å”\t\t\tNode* grandfather = parent-&gt;_parent;//å½“çˆ¶äº²æ˜¯çº¢è‰²æ—¶ï¼Œæ ¹æ®è§„åˆ™ï¼ˆ2ï¼‰æ ¹èŠ‚ç‚¹ä¸€å®šæ˜¯é»‘è‰²ï¼Œç¥–çˆ¶ä¸€å®šå­˜åœ¨\t\t\tif (parent == grandfather-&gt;_left)//çˆ¶äº²æ˜¯ç¥–çˆ¶çš„å·¦å­æ ‘\t\t\t&#123;\t\t\t\tNode* uncle = grandfather-&gt;_right;\t\t\t\t//æƒ…å†µä¸€ï¼šå”å”å­˜åœ¨ä¸”ä¸ºçº¢\t\t\t\tif (uncle-&gt;_col == RED)\t\t\t\t&#123;\t\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED; \t\t\t\t\t//ç»§ç»­å‘ä¸Šè°ƒæ•´\t\t\t\t\tcur = grandfather;\t\t\t\t\tparent = cur-&gt;_parent;\t\t\t\t&#125;\t\t\t\telse//æƒ…å†µäºŒ+æƒ…å†µä¸‰ï¼šå”å”ä¸å­˜åœ¨æˆ–å”å”å­˜åœ¨ä¸”ä¸ºé»‘\t\t\t\t&#123;\t\t\t\t\t//æƒ…å†µäºŒï¼šå•æ—‹\t\t\t\t\tif (cur == parent-&gt;_left)\t\t\t\t\t&#123;\t\t\t\t\t\tRotateR(grandfather);\t\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t\t&#125;\t\t\t\t\telse//æƒ…å†µä¸‰ï¼šåŒæ—‹\t\t\t\t\t&#123;\t\t\t\t\t\tRotateL(parent);\t\t\t\t\t\tRotateR(grandfather);\t\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t\t&#125;\t\t\t\t\tbreak;//æ’å…¥ç»“æŸ\t\t\t\t&#125;\t\t\t&#125;\t\t\telse//çˆ¶äº²æ˜¯ç¥–çˆ¶çš„å³å­æ ‘\t\t\t&#123;\t\t\t\tNode* uncle = grandfather-&gt;_left;\t\t\t\t//æƒ…å†µä¸€ï¼šå”å”å­˜åœ¨ä¸”ä¸ºçº¢\t\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == RED)\t\t\t\t&#123;\t\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED; \t\t\t\t\t//ç»§ç»­å¾€ä¸Šè°ƒæ•´\t\t\t\t\tcur = grandfather;\t\t\t\t\tparent = grandfather-&gt;_parent;\t\t\t\t&#125;\t\t\t\telse//æƒ…å†µäºŒ+æƒ…å†µä¸‰ï¼šå”å”ä¸å­˜åœ¨æˆ–å”å”å­˜åœ¨ä¸”ä¸ºé»‘\t\t\t\t&#123;\t\t\t\t\t//æƒ…å†µäºŒï¼šå•æ—‹\t\t\t\t\tif (cur == parent-&gt;_right)\t\t\t\t\t&#123;\t\t\t\t\t\tRotateL(grandfather);\t\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t\t&#125;\t\t\t\t\telse//æƒ…å†µä¸‰ï¼šåŒæ—‹\t\t\t\t\t&#123;\t\t\t\t\t\tRotateR(parent);\t\t\t\t\t\tRotateL(grandfather);\t\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t\t&#125;\t\t\t\t\tbreak;//æ’å…¥ç»“æŸ\t\t\t\t&#125;\t\t\t&#125; \t\t&#125;\t\t_root-&gt;_col = BLACK; \t\treturn make_pair(newNode, true);\t&#125; \tvoid RotateR(Node* parent)\t&#123;\t\tNode* subL = parent-&gt;_left;\t\tNode* subLR = nullptr; \t\tif (subL)\t\t&#123;\t\t\tsubLR = subL-&gt;_right;\t\t&#125;\t\t//1.å·¦å­æ ‘çš„å³å­æ ‘å˜æˆ‘çš„å·¦å­æ ‘\t\tparent-&gt;_left = subLR; \t\tif (subLR)\t\t&#123;\t\t\tsubLR-&gt;_parent = parent;\t\t&#125; \t\t//å·¦å­æ ‘å˜çˆ¶äº²\t\tsubL-&gt;_right = parent;\t\tNode* parentParent = parent-&gt;_parent;\t\tparent-&gt;_parent = subL;  \t\tif (parent == _root)//parentæ˜¯æ ¹\t\t&#123;\t\t\t_root = subL;\t\t\t_root-&gt;_parent = nullptr;\t\t&#125;\t\telse//parentä¸æ˜¯æ ¹ï¼Œæ˜¯å­æ ‘\t\t&#123;\t\t\tif (parentParent-&gt;_left == parent)\t\t\t&#123;\t\t\t\t//parentæ˜¯è‡ªå·±çˆ¶äº²çš„å·¦å­æ ‘,å°†subLä½œä¸ºparentçˆ¶äº²çš„å·¦å­©å­\t\t\t\tparentParent-&gt;_left = subL;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//parentæ˜¯è‡ªå·±çˆ¶äº²çš„å³å­æ ‘,å°†subLä½œä¸ºparentçˆ¶äº²çš„å³å­©å­\t\t\t\tparentParent-&gt;_right = subL;\t\t\t&#125; \t\t\t//subLçš„çˆ¶äº²å°±æ˜¯parentçš„çˆ¶äº²\t\t\tsubL-&gt;_parent = parentParent;\t\t&#125;\t&#125; \tvoid RotateL(Node* parent)\t&#123;\t\tNode* subR = parent-&gt;_right;\t\tNode* subRL = nullptr; \t\tif (subR)\t\t&#123;\t\t\tsubRL = subR-&gt;_left;\t\t&#125; \t\t//1.å³å­æ ‘çš„å·¦å­æ ‘å˜æˆ‘çš„å³å­æ ‘\t\tparent-&gt;_right = subRL; \t\tif (subRL)\t\t&#123;\t\t\tsubRL-&gt;_parent = parent;\t\t&#125; \t\t//2.å³å­æ ‘å˜çˆ¶äº²\t\tsubR-&gt;_left = parent;\t\tNode* parentParent = parent-&gt;_parent;\t\tparent-&gt;_parent = subR; \t\tif (parent == _root)//parentæ˜¯æ ¹\t\t&#123;\t\t\t_root = parent;\t\t\t_root-&gt;_parent = nullptr;\t\t&#125;\t\telse//parentä¸æ˜¯æ ¹ï¼Œæ˜¯å­æ ‘\t\t&#123;\t\t\tif (parentParent-&gt;_left == parent)\t\t\t&#123;\t\t\t\t//parentæ˜¯è‡ªå·±çˆ¶äº²çš„å·¦å­æ ‘,å°†subRä½œä¸ºparentçˆ¶äº²çš„å·¦å­©å­\t\t\t\tparentParent-&gt;_left = subR;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//parentæ˜¯è‡ªå·±çˆ¶äº²çš„å³å­æ ‘,å°†subRä½œä¸ºparentçˆ¶äº²çš„å³å­©å­\t\t\t\tparentParent-&gt;_right = subR;\t\t\t&#125; \t\t\t//subRçš„çˆ¶äº²å°±æ˜¯parentçš„çˆ¶äº²\t\t\tsubR-&gt;_parent = parentParent;\t\t&#125;\t&#125; \t//æŸ¥æ‰¾\tNode* Find(const K&amp; key)\t&#123;\t\tKeyOfT kot;\t\tNode* cur = _root;\t\twhile (cur)\t\t&#123;\t\t\tif (kot(cur-&gt;_data) &lt; key)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_right;\t\t\t&#125;\t\t\telse if (kot(cur-&gt;_data) &gt; key)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_left;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\treturn cur;\t\t\t&#125;\t\t&#125;\t\treturn nullptr;//ç©ºæ ‘ï¼Œç›´æ¥è¿”å›\t&#125; \tbool _CheckBalance(Node* root, int blackNum, int count)\t&#123;\t\tif (root == nullptr)\t\t&#123;\t\t\tif (count != blackNum)\t\t\t&#123;\t\t\t\tcout &lt;&lt; &quot;é»‘è‰²èŠ‚ç‚¹æ•°é‡ä¸ç›¸ç­‰&quot; &lt;&lt; endl;\t\t\t\treturn false;\t\t\t&#125;\t\t\treturn true;\t\t&#125; \t\tif (root-&gt;_col == RED &amp;&amp; root-&gt;_parent-&gt;_col == RED)\t\t&#123;\t\t\tcout &lt;&lt; &quot;å­˜åœ¨è¿ç»­çº¢è‰²èŠ‚ç‚¹&quot; &lt;&lt; endl;\t\t\treturn false;\t\t&#125; \t\tif (root-&gt;_col == BLACK)\t\t&#123;\t\t\tcount++;\t\t&#125; \t\treturn _CheckBalance(root-&gt;_left, blackNum, count)\t\t\t&amp;&amp; _CheckBalance(root-&gt;_right, blackNum, count);\t&#125; \t//æ£€æŸ¥æ˜¯å¦å¹³è¡¡\tbool CheckBalance()\t&#123;\t\tif (_root == nullptr)\t\t&#123;\t\t\treturn true;\t\t&#125; \t\tif (_root-&gt;_col == RED)\t\t&#123;\t\t\tcout &lt;&lt; &quot;æ ¹èŠ‚ç‚¹ä¸ºçº¢è‰²&quot; &lt;&lt; endl;\t\t\treturn false;\t\t&#125; \t\t//æ‰¾æœ€å·¦è·¯å¾„åšé»‘è‰²èŠ‚ç‚¹æ•°é‡å‚è€ƒå€¼\t\tint blackNum = 0;\t\tNode* left = _root;\t\twhile (left)\t\t&#123;\t\t\tif (left-&gt;_col == BLACK)\t\t\t&#123;\t\t\t\tblackNum++;\t\t\t&#125;\t\t\tleft = left-&gt;_left;\t\t&#125; \t\tint count = 0;\t\treturn _CheckBalance(_root, blackNum, count);\t&#125;  \t//éå†\tvoid _InOrder(Node* root)\t&#123;\t\tif (root == nullptr)\t\t&#123;\t\t\treturn;\t\t&#125; \t\t_InOrder(root-&gt;_left);\t\tcout &lt;&lt; root-&gt;_kv.first &lt;&lt; &quot;:&quot; &lt;&lt; root-&gt;_kv.second &lt;&lt; endl;\t\t_InOrder(root-&gt;_right);\t&#125; \tvoid InOrder()\t&#123;\t\t_InOrder(_root);\t\tcout &lt;&lt; endl;\t&#125;private:\tNode* _root;&#125;;\n\nä¸ƒã€éªŒè¯ä»£ç #pragma once#include &quot;RBTree.h&quot;#include &lt;vector&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &quot;Map.h&quot;#include &quot;Set.h&quot; int main()&#123;\tdelia::map&lt;int, int&gt; m;\tm.insert(make_pair(1, 1));\tm.insert(make_pair(3, 3));\tm.insert(make_pair(0, 0));\tm.insert(make_pair(9, 9));  \tdelia::set&lt;int&gt; s;\ts.insert(1);\ts.insert(5);\ts.insert(2);\ts.insert(1);\ts.insert(13);\ts.insert(0);\ts.insert(15);\ts.insert(18);  \tdelia::set&lt;int&gt;::iterator sit = s.begin();\twhile (sit != s.end())\t&#123;\t\tcout &lt;&lt; *sit &lt;&lt; &quot; &quot;;\t\t++sit;\t&#125;\tcout &lt;&lt; endl;  \treturn 0;&#125;\n\n"},{"title":"crimsonä¸­çš„è®¾å¤‡ç®¡ç†ä»Nvme åˆ°Seastore","url":"/2025/09/27/nvme-device/","content":"NVMe çš„é—®ä¸–ï¼ŒæŠŠå­˜å‚¨ç¡¬ä»¶çš„æ€§èƒ½æ‹‰åˆ°äº† â€œå¾®ç§’ + ç™¾ä¸‡ IOPSâ€ çš„æ—¶ä»£ã€‚ä¼ ç»Ÿçš„å†…æ ¸ IO æ ˆå’ŒåŒæ­¥ç¼–ç¨‹æ¨¡å¼ï¼Œåè€Œæˆäº†æ–°çš„ç“¶é¢ˆï¼Œæ— æ³•å……åˆ†é‡Šæ”¾ç¡¬ä»¶æ½œåŠ›ã€‚è¿™è¿«ä½¿è½¯ä»¶å¿…é¡»è¿›è¡Œä¸€æ¬¡æ·±åˆ»çš„å˜é©ï¼šä» åŒæ­¥ â†’ å¼‚æ­¥ï¼Œä» å†…æ ¸ â†’ ç”¨æˆ·æ€ï¼Œä» ç²—ç²’åº¦é” â†’ ç²¾ç»†åŒ–æ— é”å¹¶å‘ï¼Œæ‰èƒ½çœŸæ­£å‘æŒ¥å‡º NVMe çš„æé™æ€§èƒ½ã€‚\nåœ¨ Ceph çš„è®¾æƒ³ä¸­ï¼Œæœªæ¥çš„å­˜å‚¨å¼•æ“ SeaStore æ­£æ˜¯ä¸ºäº†æ‰¿æ‹…è¿™ä¸€ä½¿å‘½ï¼š\n\nåŒæ­¥åˆ°å¼‚æ­¥ï¼šå®Œå…¨åŸºäº Seastar æ¡†æ¶ï¼Œé‡‡ç”¨ Future&#x2F;Promise å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹ï¼Œæœç»é˜»å¡ã€‚\nå†…æ ¸åˆ°ç”¨æˆ·æ€ï¼šå€ŸåŠ© Seastar çš„ç”¨æˆ·æ€ç½‘ç»œdpdkä¸ io_uring ç”¨æˆ·æ€ IO æ¥å£ï¼Œæœ€å¤§ç¨‹åº¦å‡å°‘å†…æ ¸åˆ‡æ¢å¼€é”€ã€‚\nç»‘æ ¸ä¸åˆ†ç‰‡ï¼šæ¯ä¸ª CPU shard ç‹¬ç«‹è¿è¡Œï¼Œçº¿ç¨‹ä¸æ•°æ®å¼ºç»‘å®šï¼Œç«¯åˆ°ç«¯çš„æ•°æ®è·¯å¾„å¤©ç„¶æ— é”ã€‚\næ— é”åŒ–ï¼šé€šè¿‡åˆ†ç‰‡éš”ç¦»ä¸æ¶ˆæ¯ä¼ é€’æœºåˆ¶ï¼Œé¿å…ä¼ ç»Ÿé”ç«äº‰ï¼Œè®©å¹¶å‘æ›´ç»†ç²’åº¦ã€æ›´é«˜æ•ˆã€‚\n\nè¿™æ ·ä¸€æ¥ï¼ŒSeaStore ä¸ä»…æ˜¯ Ceph çš„â€œä¸‹ä¸€ä»£å¼•æ“â€ï¼Œæ›´æ˜¯é¢å‘ NVMe æ—¶ä»£çš„è½¯ä»¶èŒƒå¼è½¬å‹çš„å…·ä½“è½åœ°ã€‚\n\n\nä»€ä¹ˆæ˜¯NVMeNVMeæ˜¯åè®®ï¼Œä¸æ˜¯è®¾å¤‡ä¹Ÿä¸æ˜¯é©±åŠ¨ï¼Œå°±åƒHTTPæ˜¯åè®®ï¼Œæµè§ˆå™¨å’ŒæœåŠ¡å™¨æ˜¯å®ç°ï¼ŒNVMe å®šä¹‰äº†SSDå’Œä¸»æœºæ§åˆ¶å™¨ä¹‹é—´å¦‚ä½•äº¤æµã€‚å¯å‡å°‘é—ªå­˜å­˜å‚¨å’Œ[å›ºæ€ç¡¬ç›˜ (SSD) ]ä¸­ä½¿ç”¨çš„æ¯ä¸ªè¾“å…¥&#x2F;è¾“å‡º (I&#x2F;O) çš„ç³»ç»Ÿå¼€é”€ã€‚\nä¸å†å…¼å®¹HDDæ—¶ä»£çš„AHCIè®¾è®¡é™åˆ¶ï¼ˆå•é˜Ÿåˆ—ã€æ·±åº¦32ï¼‰\nå…³é”®ç‰¹å¾ï¼š\n\né˜Ÿåˆ—æ¨¡å‹\n\næ”¯æŒ64Kä¸ªæäº¤é˜Ÿåˆ—&#x2F;å®Œæˆé˜Ÿåˆ—ï¼Œæ¯ä¸ªé˜Ÿåˆ—æ·±åº¦64k.\næ¯ä¸ªcpuæ ¸å¯ä»¥æœ‰ç‹¬ç«‹é˜Ÿåˆ—ï¼Œå‡å°‘å»¶è¿Ÿï¼Œå……åˆ†é‡Šæ”¾é—ªå­˜çš„å¹¶è¡Œæ€§ã€‚\n\n\nå¯„å­˜å™¨æ¨¡å‹ä¼˜åŒ–\n\nä¸€æ¡IOå‘½ä»¤åªéœ€è¦å†™ä¸€ä¸ªdoorbellå¯„å­˜å™¨ï¼Œè€ŒAHCIéœ€è¦å››æ¬¡å¯„å­˜å™¨è¯»å†™\nAHCIæ¨¡å‹ï¼ˆSATA SSD&#x2F;HDD ç”¨çš„ä¼ ç»Ÿåè®®ï¼‰ï¼ŒAHCIå®šä¹‰äº†ä¸€ä¸ªå‘½ä»¤åˆ—è¡¨ï¼Œåœ¨å†…å­˜é‡Œã€‚\nå½“ä½ è¦ä¸‹å‘ä¸€æ¡I&#x2F;Oå‘½ä»¤ï¼ˆæ¯”å¦‚è¯»4KBæ•°æ®ï¼‰ï¼š\n\nCPU æŠŠå‘½ä»¤æè¿°ç¬¦å†™å…¥å†…å­˜é‡Œçš„ Command Listã€‚\nCPU å¿…é¡»æ›´æ–°å¤šä¸ªå¯„å­˜å™¨ï¼šå†™ å‘½ä»¤å¤´å¯„å­˜å™¨ å†™ å‘½ä»¤è¡¨åŸºå€å¯„å­˜å™¨å†™ PRDTï¼ˆç‰©ç†åŒºåŸŸæè¿°è¡¨ï¼‰å¯„å­˜å™¨æ›´æ–° æ§åˆ¶å¯„å­˜å™¨ å‘Šè¯‰æ§åˆ¶å™¨æœ‰æ–°å‘½ä»¤,æ§åˆ¶å™¨æ‰èƒ½å»å–å‘½ä»¤ï¼Œå¼€å§‹æ‰§è¡Œ\næ¯ä¸ª I&#x2F;O è‡³å°‘ 4 æ¬¡ MMIOï¼ˆå¯„å­˜å™¨è¯»å†™ï¼‰å¼€é”€ï¼Œæ¶ˆè€—å¤§é‡ CPU cycleï¼ˆå¤§æ¦‚ 2000~8000 ä¸ª cycleï¼‰ï¼Œå»¶è¿Ÿåœ¨å¾®ç§’çº§ã€‚\n\nNVMeæ¨¡å‹ï¼Œå®šä¹‰äº†æäº¤é˜Ÿåˆ—ï¼ˆSQï¼‰&#x2F; å®Œæˆé˜Ÿåˆ—ï¼ˆCQï¼‰,æ”¾åœ¨ä¸»æœºå†…å­˜ä¸­ã€‚\nä¸‹å‘ä¸€æ¡I&#x2F;Oå‘½ä»¤çš„æ­¥éª¤ï¼š\n\nCPU æŠŠå‘½ä»¤å†™åˆ°å†…å­˜é‡Œçš„ SQ é˜Ÿåˆ—æ§½ä½ã€‚\nCPU åªéœ€è¦ å†™ä¸€æ¬¡ doorbell å¯„å­˜å™¨ï¼Œå‘Šè¯‰æ§åˆ¶å™¨â€œSQ head å·²ç»å¢åŠ â€ã€‚\næ§åˆ¶å™¨ä¼šç›´æ¥ DMA å»å–å‘½ä»¤ï¼Œä¸éœ€è¦ CPU åšé¢å¤–å¯„å­˜å™¨äº¤äº’ã€‚\næ¯ä¸ª I&#x2F;O åªæœ‰ 1 æ¬¡ MMIOï¼ˆdoorbell writeï¼‰ï¼Œæå¤§å‡å°‘ CPU å¼€é”€å’Œå»¶è¿Ÿã€‚\n\n\n\n\nå»¶è¿Ÿæä½\n\nå•æ¬¡ I&#x2F;O å»¶è¿Ÿ ~10Âµs çº§åˆ«ï¼Œæ¯” AHCI å°‘ä¸€åŠä»¥ä¸Šã€‚\n\n\nåè®®åˆ†å±‚æ¸…æ™°ï¼š\n\nPCIe æä¾›ç‰©ç†é“¾è·¯\nNVMeåè®®å†PCIeä¹‹ä¸Šå®šä¹‰é€»è¾‘æŒ‡ä»¤é›†\n\n\n\nä¸ºä»€ä¹ˆä¼ ç»Ÿè½¯ä»¶æ ˆä¸å¤Ÿç”¨ï¼Ÿè™½ç„¶ Bluestore å·²ç»ç»•è¿‡äº†æ–‡ä»¶ç³»ç»Ÿï¼ˆç›´æ¥ç®¡ç†è£¸ç›˜ï¼‰ï¼Œä½†å®ƒä»ç„¶å­˜åœ¨ä¸¤ä¸ªå…³é”®ç“¶é¢ˆï¼š\n\nä¾èµ–å†…æ ¸ IO æ ˆ  \n\nBluestore ä½¿ç”¨ libaio æäº¤è¯·æ±‚ï¼Œæœ€ç»ˆè¿˜æ˜¯è¦èµ° Linux å†…æ ¸çš„ I&#x2F;O è·¯å¾„ã€‚  \nNVMe çš„å¤šé˜Ÿåˆ—å¹¶è¡Œæ€§è¢«å†…æ ¸é”ä¸è°ƒåº¦éƒ¨åˆ†æŠµæ¶ˆã€‚\n\n\nå¤šæ ¸æ‰©å±•å·®  \n\nä¼ ç»Ÿcephçš„OSD å†…éƒ¨æœ‰å¤§é‡çº¿ç¨‹ï¼Œå¤šä¸ªçº¿ç¨‹å…±äº«ä¸€ä¸ªè®¾å¤‡é˜Ÿåˆ—ï¼Œéœ€è¦åŠ é”ã€‚  \nNVMe ç»™äº†â€œæ¯ä¸ª core ä¸€ä¸ªé˜Ÿåˆ—â€çš„èƒ½åŠ›ï¼Œä½†ä¼ ç»Ÿ OSD æ¶æ„æ— æ³•åšåˆ°çœŸæ­£çš„æ— é”æ‰©å±•ã€‚\n\n\n\nç»“æœå°±æ˜¯ï¼š  \n\nNVMe å•ç›˜æ˜æ˜èƒ½è·‘ 100 ä¸‡ IOPSï¼ŒBluestore OSD åªèƒ½åƒä¸‹ 20~30 ä¸‡ã€‚  \nå»¶è¿Ÿä¹Ÿæ¯”ç¡¬ä»¶æŒ‡æ ‡å¤šå‡ºå‡ å€ã€‚\n\nè¿™å°±æ˜¯ Ceph éœ€è¦ Crimson&#x2F;Seastore çš„æ ¹æœ¬åŸå› ã€‚\n\nSeastar ä¸ NVMe çš„å¤©ç„¶å¥‘åˆNVMe çš„è®¾è®¡ç†å¿µï¼Œå’Œ Seastar çš„ shard æ¨¡å‹å‡ ä¹æ˜¯å¤©ç„¶åŒ¹é…çš„ï¼š  \n\nå¤šé˜Ÿåˆ—å¯¹å¤š shard  \n\nNVMeï¼šæœ€å¤š 64K ä¸ªæäº¤&#x2F;å®Œæˆé˜Ÿåˆ—ï¼Œæ¯ä¸ª core å¯ç‹¬äº«ä¸€ä¸ªé˜Ÿåˆ—ã€‚  \nSeastarï¼šåº”ç”¨æ‹†åˆ†æˆå¤šä¸ª shardï¼Œæ¯ä¸ª core ç‹¬ç«‹æ‰§è¡Œã€‚  \næ˜ å°„å…³ç³»ï¼šä¸€ä¸ª shard â†” ä¸€ä¸ª NVMe é˜Ÿåˆ—ï¼Œæ— éœ€é”ã€‚\n\n\næ— é”å¹¶è¡Œ  \n\næ¯ä¸ª core åª poll è‡ªå·±çš„å®Œæˆé˜Ÿåˆ—ï¼Œä¸ä¼šå’Œå…¶ä»– core äº‰æŠ¢ã€‚  \nI&#x2F;O æäº¤å’Œå®Œæˆå®Œå…¨ core-localï¼Œé¿å…äº†ä¼ ç»Ÿ OSD çš„â€œé˜Ÿåˆ—å…±äº« + è‡ªæ—‹é”â€ã€‚\n\n\næ€§èƒ½æ”¶ç›Šç›´è§‚  \n\nä¼ ç»Ÿ aio + å†…æ ¸é˜Ÿåˆ—ï¼šå•ç›˜ 4KB éšæœºè¯» ~40 ä¸‡ IOPS  \nio_uring + shard ç»‘å®šé˜Ÿåˆ—ï¼šå•ç›˜å¯è·‘ 150 ä¸‡ IOPS+  \nåœ¨ Crimson&#x2F;Seastore çš„å®éªŒç»“æœä¸­ï¼Œç›¸æ¯” Bluestore å»¶è¿Ÿä¸‹é™ 35 å€ï¼ŒIOPS æå‡ 23 å€ã€‚\n\n\n\nå¯ä»¥è¯´ï¼ŒSeastore ä¸æ˜¯â€œé€‚é… NVMeâ€ï¼Œè€Œæ˜¯â€œä¸º NVMe è€Œç”Ÿâ€ã€‚\n\nè®¾å¤‡ç‰¹æ€§\nå¯¹é½è¦æ±‚\n\næœ€å° I&#x2F;O å•ä½ï¼šNVMe SSD é€šå¸¸è¦æ±‚ 4KB å¯¹é½ï¼Œå³æäº¤çš„ I&#x2F;O åœ°å€å’Œé•¿åº¦æœ€å¥½æ˜¯ 4KB çš„æ•´æ•°å€ã€‚\n**æ“¦é™¤å•å…ƒ (Erase Block &#x2F; LBA Block)**ï¼š\nNAND é—ªå­˜ä»¥ Block ä¸ºå•ä½æ“¦å†™ã€‚\néšæœºå†™å°äº Block ä¼šè§¦å‘ è¯»-æ”¹-å†™æ“ä½œï¼Œé€ æˆ å†™æ”¾å¤§ï¼ˆWrite Amplificationï¼‰ï¼Œé™ä½å¯¿å‘½å’Œæ€§èƒ½\n\n\n\n\nå†™æ”¾å¤§\n\nä¸ºäº†æ›´æ–°å°‘é‡æ•°æ®ï¼ŒSSD éœ€è¦æ“¦é™¤å’Œé‡å†™æ•´ä¸ª Blockï¼Œå¯¼è‡´å®é™…å†™å…¥æ•°æ®é‡ &gt; åº”ç”¨å†™å…¥æ•°æ®é‡\n\nå½±å“ï¼šå°éšæœºå†™ IOPS ä¸‹é™ã€‚è®¾å¤‡å¯¿å‘½å‡å°‘ã€‚\nä¼˜åŒ–æ–¹å¼ï¼šä½¿ç”¨ é¡ºåºå†™ æˆ– æ‰¹é‡å†™ ã€åˆç†è§„åˆ’ æ–‡ä»¶ç³»ç»Ÿå—å¤§å° ä¸ NVMe å¯¹é½ã€‚\n\nå»¶è¿ŸæŒ‡æ ‡\n\nå•æ¬¡ I&#x2F;O å»¶è¿Ÿé€šå¸¸ï¼šæ¶ˆè´¹çº§ NVMeï¼šè¯» 10â€“30 Âµsï¼Œå†™ 20â€“50 Âµsã€‚ä¼ä¸šçº§ NVMeï¼šè¯»&#x2F;å†™å¯ &lt; 10 Âµsã€‚\nå¯¹æ¯”SATA SSDï¼šè¯»&#x2F;å†™50â€“100 Âµs  HDD :è¯»&#x2F;å†™ 5â€“10 ms\n\n\niopsä¸ååä¸Šé™\n\nå•ç›˜ IOPSï¼šéšæœºè¯»(4KB) 500k-3000k .éšæœºå†™ï¼ˆ4kBï¼‰300k-700k\nNVMe åŸç”Ÿæ”¯æŒå¤šé˜Ÿåˆ—ï¼Œæ¯ä¸ª CPU æ ¸å¿ƒå¯ç»‘å®šä¸€ä¸ªæˆ–å¤šä¸ªæäº¤é˜Ÿåˆ—ï¼ˆè¿™é‡Œå°±ä½“ç°å‡ºcrimsn ä¸­ä½¿ç”¨seastaræ¡†æ¶çš„é‡è¦æ€§äº†ï¼‰\nåœ¨å¤šæ ¸ CPU å’Œå¤šé˜Ÿåˆ—çš„åœºæ™¯ä¸‹ï¼ŒIOPS å¯ä»¥çº¿æ€§æ‰©å±•åˆ°æ•°ç™¾ä¸‡ï¼Œå……åˆ†åˆ©ç”¨ç¡¬ä»¶å¹¶è¡Œèƒ½åŠ›ã€‚\n\n\nI&#x2F;Oè°ƒç”¨æ–¹å¼\n\nlibaio(ä¼ ç»Ÿlinuxå¼‚æ­¥io,é€‚åˆå•çº¿ç¨‹æˆ–è€…å°‘é‡é˜Ÿåˆ—å¼‚æ­¥æäº¤)\nio_uringï¼ˆlinux5.1 çœŸæ­£é›¶æ‹·è´å’Œé«˜æ€§èƒ½å¤šé˜Ÿåˆ—å¼‚æ­¥I&#x2F;Oï¼‰\n\n\né«˜çº§ç‰¹æ€§ï¼š\n\nNVMe2.0 :åœ¨çº¿å‡çº§ã€å¤šå‘½åç©ºé—´ï¼ˆ128ä¸ªï¼‰ã€å¤šæµã€åŸå­å†™ã€ sanitizeã€copyã€verifyã€compareç­‰é«˜çº§ç‰¹æ€§ã€‚\néµå¾ªOCP 2.5è§„èŒƒåè®®ï¼ŒTelemetryã€Latency Monitorã€Thermal Throttleç­‰é«˜çº§ç‰¹æ€§\næ”¯æŒSR-IOV â€¢ æœ€å¤š64ä¸ªV\nçµæ´»æ•°æ®æ”¾ç½®(FDP) â€¢ æå‡ç¨³æ€éšæœºå†™æ€§èƒ½ï¼Œå¤§å¹…é™ä½å†™æ”¾å¤§ï¼Œç‰¹æ®Šåœºæ™¯ä¸‹ å¯å®ç°WAF&#x3D;1\nTCG OPAL2.0å®‰å…¨è§„èŒƒ â€¢ æ”¯æŒOPAL 2.0åè®®æ ˆ â€¢ æ”¯æŒSM2&#x2F;SM3&#x2F;SM4&#x2F;AES256æ•°æ®åŠ å¯†\nç«¯åˆ°ç«¯ä¿æŠ¤\næŒSecure Bootã€Firmwareå®‰å…¨æ ¡éªŒã€Formatã€ Sanitizeç­‰å¤šç§ä¼ä¸šçº§å®‰å…¨ç‰¹æ€§\n\n\n\n\n","tags":["Crimson","nvme"]},{"title":"çº¦ç‘Ÿå¤«ç¯é—®é¢˜","url":"/2025/09/19/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/","content":"çº¦ç‘Ÿå¤«ç¯é—®é¢˜çš„ä¸‰ç§è§£å†³æ–¹æ³•\n\nä»€ä¹ˆæ˜¯çº¦ç‘Ÿå¤«ç¯é—®é¢˜ï¼šçº¦ç‘Ÿå¤«ç¯é—®é¢˜åœ¨ä¸åŒå¹³å°è¢«â€ä¼˜åŒ–â€æè¿°çš„ä¸ä¸€æ ·ï¼Œä¾‹å¦‚åœ¨ç‰›å®¢å‰‘æŒ‡offerå«å­©å­ä»¬çš„æ¸¸æˆï¼Œè¿˜æœ‰å«æ€äººæ¸¸æˆï¼Œç‚¹åâ€¦â€¦æœ€ç›´æ¥çš„æ„Ÿè§‰è¿˜æ˜¯åŠ›æ‰£ä¸Šå‰‘æŒ‡offer62çš„æè¿°ï¼šåœ†åœˆä¸­æœ€åå‰©ä¸‹çš„æ•°å­—é—®é¢˜æè¿°ï¼š0,1,Â·Â·Â·,n-1è¿™nä¸ªæ•°å­—æ’æˆä¸€ä¸ªåœ†åœˆï¼Œä»æ•°å­—0å¼€å§‹ï¼Œæ¯æ¬¡ä»è¿™ä¸ªåœ†åœˆé‡Œåˆ é™¤ç¬¬mä¸ªæ•°å­—ï¼ˆåˆ é™¤åä»ä¸‹ä¸€ä¸ªæ•°å­—å¼€å§‹è®¡æ•°ï¼‰ã€‚æ±‚å‡ºè¿™ä¸ªåœ†åœˆé‡Œå‰©ä¸‹çš„æœ€åä¸€ä¸ªæ•°å­—ã€‚ä¾‹å¦‚ï¼Œ0ã€1ã€2ã€3ã€4è¿™5ä¸ªæ•°å­—ç»„æˆä¸€ä¸ªåœ†åœˆï¼Œä»æ•°å­—0å¼€å§‹æ¯æ¬¡åˆ é™¤ç¬¬3ä¸ªæ•°å­—ï¼Œåˆ™åˆ é™¤çš„å‰4ä¸ªæ•°å­—ä¾æ¬¡æ˜¯2ã€0ã€4ã€1ï¼Œå› æ­¤æœ€åå‰©ä¸‹çš„æ•°å­—æ˜¯3ã€‚\nåˆ—è¡¨å¾ªç¯æ¨¡æ‹Ÿï¼šè¿™ä¸ªé—®é¢˜æœ€æœ¬è´¨å…¶å®å°±æ˜¯å¾ªç¯é“¾è¡¨çš„é—®é¢˜ï¼Œå›´æˆä¸€ä¸ªåœˆä¹‹åï¼Œå°±æ²¡æœ‰ç»“å°¾è¿™å°±æ˜¯ä¸€ä¸ªå…¸å‹çš„å¾ªç¯é“¾è¡¨å˜›ï¼ä¸€ä¸ªä¸€ä¸ªé¡ºåºæŠ¥æ•°ï¼Œé‚£ä¸å°±æ˜¯é“¾è¡¨çš„éå†æšä¸¾å˜›ï¼æ•°åˆ°å¯¹åº”æ•°å­—çš„å‡ºåˆ—ï¼Œè¿™ä¸å°±æ˜¯å¾ªç¯é“¾è¡¨çš„åˆ é™¤å˜›ï¼\nå¹¶ä¸”è¿™é‡Œè¿˜æœ‰éå¸¸æ–¹ä¾¿çš„åœ°æ–¹ï¼š\nå¾ªç¯é“¾è¡¨çš„å‘ä¸‹æšä¸¾ä¸éœ€è¦è€ƒè™‘å¤´å°¾é—®é¢˜ï¼Œç›´æ¥node&#x3D;node.nextå‘ä¸‹å¾ªç¯èŠè¡¨çš„åˆ é™¤ä¹Ÿä¸éœ€è¦è€ƒè™‘å¤´å°¾é—®é¢˜ï¼Œç›´æ¥node.next&#x3D;node.next.nextåˆ é™¤å½“ç„¶ä¹Ÿæœ‰ä¸€äº›éœ€è¦æ³¨æ„çš„åœ°æ–¹\nå½¢æˆç¯å½¢é“¾è¡¨å¾ˆç®€å•ï¼Œåªéœ€è¦å°†æ™®é€šé“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„nextæŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å³å¯\nå¾ªç¯é“¾è¡¨ä¸­åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™åœæ­¢è¿”å›ï¼Œå³node.next&#x3D;nodeçš„æ—¶å€™\nåˆ é™¤ï¼Œéœ€è¦æ‰¾åˆ°å¾…åˆ é™¤çš„å‰é¢èŠ‚ç‚¹ï¼Œæ‰€ä»¥æˆ‘ä»¬åˆ é™¤è®¡æ•°çš„æ—¶å€™è¦å°‘å³ä¸€ä½ï¼Œåˆ©ç”¨å‰é¢çš„é‚£ä¸ªèŠ‚ç‚¹ç›´æ¥åˆ é™¤åé¢èŠ‚ç‚¹å³å¯\nè¿™æ ·ï¼Œæ€è·¯æ˜ç¡®ï¼Œç›´æ¥å¼€æ’¸ä»£ç ï¼š\nclass Solution &#123;    class node//é“¾è¡¨èŠ‚ç‚¹    &#123;        int val;        public node(int value) &#123;            this.val=value;        &#125;        node next;    &#125;    public int lastRemaining(int n, int m) &#123;        if(m==1)return n-1;//ä¸€æ¬¡ä¸€ä¸ªç›´æ¥è¿”å›æœ€åä¸€ä¸ªå³å¯        node head=new node(0);        node team=head;//åˆ›å»ºä¸€ä¸ªé“¾è¡¨        for(int i=1;i&lt;n;i++)        &#123;            team.next=new node(i);            team=team.next;        &#125;        team.next=head;//ä½¿å½¢æˆç¯        int index=0;//ä»0å¼€å§‹è®¡æ•°        while (head.next!=head) &#123;//å½“å‰©ä½™èŠ‚ç‚¹ä¸æ­¢ä¸€ä¸ªçš„æ—¶å€™            //å¦‚æœindex=m-2 é‚£å°±è¯´æ˜ä¸‹ä¸ªèŠ‚ç‚¹(m-1)è¯¥åˆ é™¤äº†            if(index==m-2)            &#123;                head.next=head.next.next;                index=0;            &#125;            else &#123;                index++;            &#125;            head=head.next;        &#125;        return head.val;    &#125;&#125;\nå½“ç„¶ï¼Œè¿™ç§ç®—æ³•å¤ªå¤æ‚äº†ï¼Œå¤§éƒ¨åˆ†çš„OJä½ æäº¤ä¸Šå»æ˜¯æ— æ³•ACçš„ï¼Œå› ä¸ºè¶…æ—¶å¤ªä¸¥é‡äº†ï¼Œå…·ä½“çš„æˆ‘ä»¬å¯ä»¥ä¸‹é¢åˆ†æã€‚\næœ‰åºé›†åˆæ¨¡æ‹Ÿä¸Šé¢ä½¿ç”¨é“¾è¡¨ç›´æ¥æ¨¡æ‹Ÿæ¸¸æˆè¿‡ç¨‹ä¼šé€ æˆéå¸¸ä¸¥é‡éå¸¸ä¸¥é‡çš„è¶…æ—¶ï¼Œnä¸ªæ•°å­—ï¼Œæ•°åˆ°ç¬¬mä¸ªå‡ºåˆ—ã€‚å› ä¸ºmå¦‚æœéå¸¸å¤§è¿œè¿œå¤§äºmï¼Œé‚£ä¹ˆå°†è¿›è¡Œå¾ˆå¤šæ¬¡è½¬åœˆåœˆã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆ©ç”¨æ±‚ä½™çš„æ–¹æ³•åˆ¤æ–­ç­‰ä»·æœ€ä½çš„æšä¸¾æ¬¡æ•°ï¼Œç„¶åå°†å…¶åˆ é™¤å³å¯ï¼Œåœ¨è¿™é‡Œä½ å¯ä»¥ç»§ç»­ä½¿ç”¨è‡ªå»ºé“¾è¡¨å»æ¨¡æ‹Ÿï¼Œä¸Šé¢çš„whileå¾ªç¯ä»¥åŠä¸Šé¢åªéœ€æ·»åŠ ä¸€ä¸ªè®°å½•é•¿åº¦çš„æ¯æ¬¡æ±‚ä½™ç®—åœˆæ•°å³å¯ï¼š\nint len=n;while (head.next!=head) &#123;  if(index==(m-2)%len)  &#123;    head.next=head.next.next;    index=0;    len--;  &#125;  else &#123;    index++;  &#125;  head=head.next;&#125;\nä½†æˆ‘ä»¬å¾ˆå¤šæ—¶å€™ä¸ä¼šæ‰‹åŠ¨å»å†™ä¸€ä¸ªé“¾è¡¨æ¨¡æ‹Ÿï¼Œæˆ‘ä»¬ä¼šå€ŸåŠ©ArrayListå’ŒLinkedListå»æ¨¡æ‹Ÿï¼Œå¦‚æœä½¿ç”¨LinkedListå…¶åº•å±‚ä¹Ÿæ˜¯é“¾è¡¨ï¼Œä½¿ç”¨ArrayListçš„è¯å…¶åº•å±‚æ•°æ®ç»“æ„æ˜¯æ•°ç»„ã€‚ä¸è¿‡åœ¨ä½¿ç”¨Listå…¶ä»£ç æ–¹æ³•ä¸€è‡´ã€‚\nListå¯ä»¥ç›´æ¥çŸ¥é“é•¿åº¦ï¼Œä¹Ÿå¯åˆ é™¤å…ƒç´ ï¼Œä½¿ç”¨Listçš„éš¾ç‚¹æ˜¯ä¸€ä¸ªé¡ºåºè¡¨æ€ä»¬æ¨¡æ‹Ÿæˆå¾ªç¯é“¾è¡¨ï¼Ÿ\nå’±ä»¬ä»”ç»†æ€è€ƒï¼šå‡è®¾å½“å‰é•¿åº¦ä¸ºnï¼Œæ•°åˆ°ç¬¬mä¸ª(é€šè¿‡ä¸Šé¢åˆ†æå¯ä»¥æ±‚ä½™è®©è¿™ä¸ªæœ‰æ•ˆçš„mä¸å¤§äºn)åˆ é™¤ï¼Œåœ¨indexä½ç½®åˆ é™¤ã€‚é‚£ä¹ˆåˆ é™¤åå‰©ä¸‹çš„å°±æ˜¯n-1é•¿åº¦ï¼Œindexä½ç½®å°±æ˜¯è¡¨ç¤ºç¬¬ä¸€ä¸ªè®¡æ•°çš„ä½ç½®ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ±‚ä½™å¾—çŸ¥èµ°ä¸‹ä¸€ä¸ªåˆ é™¤éœ€è¦å¤šå°‘æ­¥ï¼Œé‚£ä¹ˆä¸‹ä¸ªä½ç½®æ€ä¹ˆç¡®å®šå‘¢ï¼Ÿä½ å¯ä»¥åˆ†ç±»è®¨è®ºçœ‹çœ‹èµ°çš„æ¬¡æ•°æ˜¯å¦è¶Šç•Œï¼Œä½†è¿™é‡Œæœ‰æ›´å·§å¦™çš„æ–¹æ³•ï¼Œå¯ä»¥ç›´æ¥æ±‚çš„ä¸‹ä¸€æ¬¡å…·ä½“çš„ä½ç½®ï¼Œå…¬å¼å°±æ˜¯ä¸ºï¼š\nindex=(index+m-1)%(list.size());\nå› ä¸ºindexæ˜¯ä»1è®¡æ•°ï¼Œå¦‚æœæ˜¯å¾ªç¯çš„å†å¾€å‰m-1ä¸ªå°±æ˜¯çœŸæ­£çš„ä½ç½®ï¼Œä½†æ˜¯è¿™é‡Œå¯ä»¥å…ˆå‡è®¾å…ˆå°†è¿™ä¸ªæœ‰åºé›†åˆçš„é•¿åº¦æ‰©å¤§è‹¥å¹²å€ï¼Œç„¶åä»indexè®¡æ•°å¼€å§‹æ‰¾åˆ°å‡è®¾ä¸å¾ªç¯çš„ä½ç½®index2ï¼Œæœ€åæˆ‘ä»¬å°†è¿™ä¸ªä½ç½®index2%(é›†åˆé•¿åº¦)å³ä¸ºçœŸæ­£çš„é•¿åº¦ã€‚ä½¿ç”¨è¿™ä¸ªå…¬å¼ä¸€ä¸¾å‡ å¾—ï¼Œæ—¢èƒ½æŠŠä¸Šé¢mè¿‡å¤§å¾ªç¯è¿‡å¤šçš„æƒ…å†µè§£å†³ï¼Œåˆèƒ½æ‰¾åˆ°çœŸå®çš„ä½ç½®ï¼Œå°±æ˜¯å°†è¿™ä¸ªç¯å…ˆå‡è®¾æˆçº¿æ€§çš„ç„¶åå†å»æ‰¾åˆ°çœŸçš„ä½ç½®ï¼Œå¦‚æœä¸ç†è§£çš„è¯å¯ä»¥å†çœ‹çœ‹è¿™ä¸ªå›¾ï¼šè¿™ç§æƒ…å†µçš„è¯å¤§éƒ¨åˆ†çš„OJæ˜¯å¯ä»¥å‹‰å¼ºè¿‡å…³çš„ï¼Œé¢è¯•å®˜çš„å±‚é¢ä¹Ÿå¤§æ¦‚ç‡å·®ä¸å¤šçš„ï¼Œå…·ä½“ä»£ç ä¸ºï¼š\nclass Solution &#123;    public int lastRemaining(int n, int m) &#123;        if(m==1)            return n-1;        List&lt;Integer&gt;list=new ArrayList&lt;&gt;();        for(int i=0;i&lt;n;i++)        &#123;            list.add(i);        &#125;        int index=0;        while (list.size()&gt;1)        &#123;            index=(index+m-1)%(list.size());            list.remove(index);        &#125;        return list.get(0);    &#125;&#125;\né€’å½’å…¬å¼è§£å†³æˆ‘ä»¬å›é¡¾ä¸Šé¢çš„ä¼˜åŒ–è¿‡ç¨‹ï¼Œä¸Šé¢ç”¨æ±‚ä½™å¯ä»¥è§£å†³mæ¯”nå¤§å¾ˆå¤šå¾ˆå¤šçš„æƒ…å†µ(å³ç†è®ºä¸Šéœ€è¦è½¬å¾ˆå¤šå¾ˆå¤šåœˆçš„æƒ…å†µ)ã€‚ä½†æ˜¯è¿˜å¯èƒ½å­˜åœ¨næœ¬èº«å°±å¾ˆå¤§çš„æƒ…å†µï¼Œæ— è®ºæ˜¯é¡ºåºè¡¨ArrayListè¿˜æ˜¯é“¾è¡¨LinkedListå»é¢‘ç¹æŸ¥è¯¢ã€åˆ é™¤éƒ½æ˜¯å¾ˆä½æ•ˆçš„ã€‚\næ‰€ä»¥èªæ˜çš„äººå°±å¼€å§‹ä»æ•°æ®æ‰¾ä¸€äº›è§„å¾‹æˆ–è€…å…³ç³»ã€‚\nå…ˆæŠ›å‡ºå…¬å¼ï¼š\nf(n,m)=(f(n-1,m)+m)%nf(n,m)æŒ‡nä¸ªäººï¼ŒæŠ¥ç¬¬mä¸ªç¼–å·å‡ºåˆ—æœ€ç»ˆç¼–å·\nä¸‹é¢è¦è®¤çœŸçœ‹ä¸€ä¸‹æˆ‘çš„åˆ†æè¿‡ç¨‹ï¼š\næˆ‘ä»¬ä¸¾ä¸ªä¾‹å­ï¼Œæœ‰0 1 2 3 4 5 6 7 8 9åä¸ªæ•°å­—ï¼Œå‡è®¾mä¸º3,æœ€åç»“æœå¯ä»¥å…ˆè®°æˆf(10,3)ï¼Œå³ä½¿æˆ‘ä»¬ä¸çŸ¥é“å®ƒæ˜¯å¤šå°‘ã€‚\nå½“è¿›è¡Œç¬¬ä¸€æ¬¡æ—¶å€™ï¼Œæ‰¾åˆ°å…ƒç´ 2 åˆ é™¤ï¼Œæ­¤æ—¶è¿˜å‰©9ä¸ªå…ƒç´ ï¼Œä½†èµ·å§‹ä½ç½®å·²ç»å˜æˆå…ƒç´ 3ã€‚ç­‰ä»·æˆ3 4 5 6 7 8 9 0 1è¿™9ä¸ªæ•°å­—é‡å†™å¼€å§‹æ‰¾ã€‚\næ­¤æ—¶è¿™ä¸ªåºåˆ—æœ€ç»ˆå‰©ä¸‹çš„ä¸€ä¸ªå€¼å³ä¸ºf(10,3)ï¼Œè¿™ä¸ªåºåˆ—çš„å€¼å’Œf(9,3)ä¸åŒï¼Œä½†æ˜¯éƒ½æ˜¯9ä¸ªæ•°ä¸”mç­‰äº3ï¼Œæ‰€ä»¥å…¶åˆ é™¤ä½ç½®æ˜¯ç›¸åŒçš„ï¼Œå³ç®—æ³•å¤§ä½“æµç¨‹æ˜¯ä¸€è‡´çš„ï¼Œåªæ˜¯å„ä½ç½®ä¸Šçš„æ•°å­—ä¸ä¸€æ ·ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦åšçš„äº‹æƒ…æ˜¯æ‰¾æ‰¾è¿™ä¸ªåºåˆ—ä¸Šå’Œf(9,3)å€¼ä¸Šæœ‰æ²¡æœ‰ä»€ä¹ˆè”ç³»ã€‚\nå¯»æ‰¾è¿‡ç¨‹ä¸­åˆ«å¿˜è®°ä¸¤ç‚¹ï¼Œé¦–å…ˆå¯é€šè¿‡**%ç¬¦å·**å¯¹æ•°å­—æœ‰æ•ˆæ‰©å……ï¼Œå³æˆ‘ä»¬å¯ä»¥å°†3 4 5 6 7 8 9 0 1è¿™ä¸ªåºåˆ—çœ‹æˆ(3,4,5,6,7,8,9,10,11)%10.è¿™é‡Œçš„10å³ä¸ºæ­¤æ—¶çš„næ•°å€¼ã€‚\nå¦å¤–æ•°å€¼å¦‚æœæ˜¯è¿ç»­çš„ï¼Œé‚£ä¹ˆæœ€ç»ˆä¸€ä¸ªç»“æœçš„è¯æ˜¯å¯ä»¥æ‰¾åˆ°è”ç³»çš„(å·®å€¼ä¸ºä¸€ä¸ªå®šåˆ¶)ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°±æ‰¾åˆ°f(10,3)å’Œf(9,3)å€¼ä¹‹é—´ç»“æœçš„å…³ç³»ï¼Œå¯ä»¥çœ‹ä¸‹å›¾ï¼šæ‰€ä»¥f(10,3)çš„ç»“æœå°±å¯ä»¥è½¬åŒ–ä¸ºf(9,3)çš„è¡¨è¾¾,åé¢ä¹Ÿæ˜¯åŒç†ï¼š\nf(10,3)=(f(9,3)+3)%10f(9,3)=(f(8,3)+3)%9â€¦â€¦f(2,3)=(f(1,3)+3)%2f(1,3)=0\nè¿™æ ·ï¼Œæˆ‘ä»¬å°±ä¸ç”¨æ¨¡æ‹Ÿæ“ä½œï¼Œå¯ä»¥ç›´æ¥ä»æ•°å€¼çš„å…³ç³»æ‰¾åˆ°é€’æ¨çš„å…³ç³»ï¼Œå¯ä»¥è½»è½»æ¾æ¾çš„å†™ä¸‹ä»£ç ï¼š\nclass Solution &#123;    int index=0;    public int lastRemaining(int n, int m) &#123;         if(n==1)            return 0;              return (lastRemaining(n-1,m)+m)%n;    &#125;&#125;\nä½†æ˜¯é€’å½’æ•ˆç‡å› ä¸ºæœ‰ä¸ªæ¥å›çš„è§„ç¨‹ï¼Œæ•ˆç‡ç›¸æ¯”ç›´æ¥è¿­ä»£å·®ä¸€äº›ï¼Œä¹Ÿå¯ä»å‰å¾€åè¿­ä»£ï¼š\nclass Solution &#123;    public int lastRemaining(int n, int m) &#123;        int value=0;            for(int i=1;i&lt;=n;i++)            &#123;                value=(value+m)%i;            &#125;            return  value;    &#125;&#125;\nç»“è¯­","tags":["ç®—æ³•"]}]