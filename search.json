[{"url":"/2025/09/19/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","content":"IO多路复用\n\n需求：高性能网络服务器设计一个高性能的网络服务器，提供多个客户端同时连接，并处理客户端的处理请求。\n1.第一印象   当我们知道这个需求后，我们第一印象为了应对并发，可以基于多线程，写一个多线程的程序，但是多线程会有一些弊端就是需要cpu上下文切换，这样就会导致处理操作句柄，代价大。那多线程不够好的话，我们就把目光放在了单线程，用单线程处理大量客户端的连接，先抛出一个问题：加入有多个客户端连接，在处理A用户发过来的消息的同时，B用户也发来了小心，会不会导致B的消息丢失，答案是不会的，原因是处理IO时，处理IO操作时，接收B传过来消息的并不是CPU，而是DMA控制器，不会造成数据的丢失，为数据的不丢失性，提供了保障。\n  那我们知道每一个网络连接再内核中都已一个文件描述符来表示，我们可以用单线程程序写一个网络服务器\nwhile(1)&#123;for(fdx in (fdA~FdB))\t&#123;if(Fdx 有数据)\t\t&#123;读Fdx,处理数据\t\t&#125;\t&#125;&#125;\n\n那如果这样写一个网络服务器，他的性能也不够低，但是不够好，原因时判断有数据到来是程序在判断，效率不够好。那么我们看一下Select 是怎么做的？\n2.Select我们先看select的有关的函数：\n①:nfds：最大的文件描述符+1，fd_set *readfds：读文件描述符集合，\nint select(int nfds, fd_set *readfds, fd_set *writefds,                 fd_set *exceptfds, struct timeval *timeout);\n\n②：从fd_set 移除一个文件描述符\nvoid FD_CLR(int fd, fd_set *set);\n\n③：判断fd是否在fd_set集合中\nint  FD_ISSET(int fd, fd_set *set);\n\n④：向fd_set 加入一个文件描述符，当面向网络服务器设计中，这里加入的使tcp协议中三次握手中的accept返回的文件描述符\nvoid FD_SET(int fd, fd_set *set);\n\n⑤：初始化一个fd_set\nvoid FD_ZERO(fd_set *set);\n\n其中最核心的是fd_set,他是一个bitmap(位图)，\n1.调用selsct提前的准备工作：\n2.首先要创建一个fd_set 类型的变量，（监听集合）\n3.调用FD_ZERO,初始化这个监听集合，\n4.按需求调用FD_SET增加监听，\n5.调用select函数，使调用的进程陷入阻塞，操作系统轮询监听集合，\n那么select函数底层做了什么操作呢？\nselect函数会将用户态空间的fd_set拷贝到内核态，由内核态来判断是否有数据到来，如果没有数据到来，那么select函数就会阻塞，当有数据到来的时候select函数会将fd_set中标识有数据到来的fd标记，select会返回，然后程序再遍历文件描述符，遍历出就绪的文件描述符并做出相应的数据处理。\n那么，这样做的优点就是，判断文件描述符有数据到来变为了由内核来判断，提高了效率，也不会大量再内核态和用户态切换，\n缺点：\n①：fd_set 位图限制了数量，该数量需要重新编译内核\n②：数据仍然有大量的内核态和用户态之间的拷贝\n③：监听集合和就绪集合耦合\n④：再海量监听，少量就绪的情况下，大部分时间会浪费再FD_ISSET()中，原因使并不知道就绪的是哪一个！\n那么pool函数又做了哪些优化呢？简单说一下。\n3.Poll直接说结果，Poll函数中将select 中的bitmap 改为了结构体，那么就解决了位图数量限制的问题，\nint poll(struct pollfd *fds, nfds_t nfds, int timeout);// fds 是一个链表的指针，链表的节点是一个pollfd 的结构体，nfds 是节点的个数，struct pollfd &#123;               int   fd;         /* file descriptor */               short events;     /* requested events */               short revents;    /* returned events */           &#125;;//其中fd，依然是文件描述符，//events 标识的是，这个文件描述符在意的事件，当是这个事件来临的时候，poll函数会将pollfd.revects置位//来表征这个文件描述已经就绪//pollfd.revents 可以用来每次处理完就绪的文件描述否后，再置为0；//虽然并没有完全解决就序集合与遍历集合耦合的问题，但是poolfds 是可以重用的；select中的fd_set不可以重用！\n\n这样的优化，解决了部分问题，但是仍然不够完美，那么epoll又是怎样优化的：\n4.epollepoll 不支持跨平台，linux下独有的，不属于posxi规范，\nepoll相对于select 和 poll来说就比较复杂一点了\n我们先看相关的函数\n int epoll_create(int size);//创建一个epoll的文件对象，size值没有意义，只要是一个大于0的数值即可，\n\n调用epoll_create 时，内核除了我们在epoll文件系统里建了个file结点，再内核cache（缓冲区）里建了一个红黑树 用于存储以后epoll_ctl 传来的socket外还会建立一个list链表，用于存储准备就绪的事件。当就绪以后，会将就绪集合拷贝到用户。\nint  epoll_ctl(int  epfd,  int  op,  int  fd,  struct  epoll_event *event);// epfd是epoll_create 创建的epoll的文件对象，//op的选项：//EPOLL_CTL_ADD 向epfd中加入一个文件描述符  //EPOLL_CTL_MOD 向epfd更改与目标文件关联的事件事件描述符fd//EPOLL_CTL_DEL 向epfd中删除一个文件描述符//event 是一个指向结构体 epoll_event 的指针，//而 epoll_event 中的 events 描述的是事件的属性，读阻塞/写阻塞，data是携带的额外的信息，//epoll_data_t 是一个联合体一般是fd。typedef union epoll_data &#123;               void        *ptr;               int          fd;//一般是这个               uint32_t     u32;               uint64_t     u64;           &#125; epoll_data_t;struct epoll_event &#123;               uint32_t     events;      /* Epoll events */               epoll_data_t data;        /* User data variable */           &#125;;\n\n所以我们可以得出结论，epoll_ctl()函数中的event 所指向的结构体相比较poll中的结构体是去掉了revent。\n在这里我们不仅将fd 经过op操作可以加入epfd中，同时我们还传入一个携带同样fd的event结构体，所以，传入两份相同的数据确实会对空间造成影响，但是结构体中的fd，可以使我们再epoll_wait 函数中能够遍历这个数组\n用来遍历就绪集合，达到一个空间换时间的功能。他同时也处理了select 的就绪集合和监听集合耦合的问题。\nint epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);//如果 timeout 的值为负数，epoll_wait 函数会一直阻塞，直到有事件发生。//如果 timeout 的值为零，epoll_wait 函数会立即返回，无论是否有事件发生。这相当于在非阻塞模式下调用 epoll_wait。//如果 timeout 的值为正数，epoll_wait 函数将等待指定的时间，直到有事件发生或者超时。如果在超时之前有事件发生，epoll_wait 函数将立即返回，并将事件存储到 events 数组中。如果超时时间到达而没有事件发生，epoll_wait 函数也会返回，此时返回值为 0，表示没有事件发生。//struct epoll_event *events 是一个传入传出参数，events 是一个元素类型为struct epoll_event，长度为maxevents，他们将用来保存就绪集合，// return value 是就序集合的长度，再event.data.fd中找到就绪文件描述符。\n\n接下来我们看一个 实现epoll的一个示例代码：\n#define MAX_EVENTS 10           struct epoll_event ev, events[MAX_EVENTS];           int listen_sock, conn_sock, nfds, epollfd;           /* Code to set up listening socket, &#x27;listen_sock&#x27;,              (socket(), bind(), listen()) omitted */           epollfd = epoll_create1(0);           if (epollfd == -1) &#123;               perror(&quot;epoll_create1&quot;);               exit(EXIT_FAILURE);           &#125;           ev.events = EPOLLIN;           ev.data.fd = listen_sock;           if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) == -1) &#123;               perror(&quot;epoll_ctl: listen_sock&quot;);               exit(EXIT_FAILURE);           &#125;           for (;;) &#123;               nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);               if (nfds == -1) &#123;                   perror(&quot;epoll_wait&quot;);                   exit(EXIT_FAILURE);               &#125;               for (n = 0; n &lt; nfds; ++n) &#123;                   if (events[n].data.fd == listen_sock) &#123;                       conn_sock = accept(listen_sock,                                     (struct sockaddr *) &amp;addr, &amp;addrlen);                       if (conn_sock == -1) &#123;                           perror(&quot;accept&quot;);                           exit(EXIT_FAILURE);                       &#125;                       setnonblocking(conn_sock);                       ev.events = EPOLLIN | EPOLLET;                       ev.data.fd = conn_sock;                       if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,                                   &amp;ev) == -1) &#123;                           perror(&quot;epoll_ctl: conn_sock&quot;);                           exit(EXIT_FAILURE);                       &#125;                   &#125; else &#123;                       do_use_fd(events[n].data.fd);                   &#125;               &#125;           &#125;\n\nepoll 的边缘触发，水平触发，以及海量监听下性能也很好  scales well to \nredis 是用的epoll 。njinx javaNIO (linux 下)\n问题：既然fd_set 运用了bitmap select之前是标识监听的文件描述符，select 会把就绪的集合置为，所以底层怎么技既能标识监听又能表示就绪的？\n"},{"url":"/2025/09/19/STL/","content":"STL"},{"url":"/2025/09/19/lru/","content":"title:线性表+哈希表&gt;&gt;LRU算法\n\n\n线性表+哈希表&gt;&gt;LRU算法方法：哈希表 + 双向链表算法LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。\n双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。\n哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。\n这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)O(1)O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：\nint LRU::get(int key)&#123;&#125;\n\n对于 get 操作，首先判断 key 是否存在：\n如果 key 不存在，则返回 −1；\n如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。\n对于 put 操作，首先判断 key 是否存在：\nvoid LRU::put(int key,int value)&#123;&#125;\n\n如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；\n如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。\n上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)时间内完成。\n小贴士在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。\n复杂度分析时间复杂度：对于 put 和 get 都是 O(1)。\n空间复杂度：O(capacity)O(\\text{capacity})O(capacity)，因为哈希表和双向链表最多存储 capacity+1\\text{capacity} + 1capacity+1 个元素。\n#include &lt;iostream&gt;#include&lt;list&gt;#include&lt;unordered_map&gt;using namespace std;using std::cout;using std::endl;class LRU&#123;public:    LRU(int cap)    :_capacity(cap)    &#123;        cout &lt;&lt; &quot;LRU(int cap)&quot; &lt;&lt; endl;            &#125;    int get(int key);    void put(int key,int value);private:    struct cacheNode    &#123;        cacheNode(int key,int v)        :_key(key)        ,_value(v)        &#123;            cout &lt;&lt; &quot;cacheNode(int key,int v)&quot; &lt;&lt; endl;        &#125;        int _key;        int _value;    &#125;;    list&lt;cacheNode&gt; _nodes;//双向链表存，    int _capacity;//缓存的大小    unordered_map&lt;int,list&lt;cacheNode&gt;::iterator &gt; _cache;//无序map ，    //存放的是 key值，和链表的迭代器&#125;;int LRU::get(int key)&#123;    //TODO 判断key值是否在map中，如果存在，直接把他    //更新在链表的头，并且返回他的value,不存在则返回-1；        auto it = _cache.find(key);//unordered_map 的 find 函数返回值为                            // 该key值所对应的迭代器    if(it!=_cache.end())    &#123;        _nodes.splice(_nodes.begin(),_nodes,it-&gt;second);        //链表的splice 函数可以将 _nodes链表中的 it-&gt;second所指向的元素        //转移到_nodes.begin()的前面        return it-&gt;second-&gt;_value;    &#125;    else    &#123;        return -1;    &#125;&#125;void LRU::put(int key,int value)&#123;    //TODO 判断key 是否存在，如果存在那么，直接放在链表表头    //如果不存在则判断链表是不是满的，如果满了删除末尾元素    //然后在链表头插入，并且插入到map中        auto it = _cache.find(key);     if(it!=_cache.end())    &#123;        it-&gt;second-&gt;_value= value;        _nodes.splice(_nodes.begin(),_nodes,it-&gt;second);    &#125;    else    &#123;        if((int)_nodes.size()==_capacity)        &#123;            auto &amp;deleteNode = _nodes.back();            _cache.erase(deleteNode._key);//unordered_map 的 earse操作                                        // size_type earse(const key_type&amp;key);            _nodes.pop_back();        &#125;        _nodes.push_front(cacheNode(key,value));        _cache.insert(std::make_pair(key,_nodes.begin()));    &#125;&#125;void test0()&#123;        LRU lru(2);    lru.put(1,88);    cout &lt;&lt; &quot;get(1)&quot; &lt;&lt; lru.get(1) &lt;&lt; endl;    lru.put(3,99);    lru.put(4,77);    cout &lt;&lt; &quot;get(1)&quot; &lt;&lt; lru.get(1) &lt;&lt; endl;&#125;int main(void)&#123;    test0();    return 0;&#125;\n\n"},{"title":"约瑟夫环问题","url":"/2025/09/19/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/","content":"约瑟夫环问题的三种解决方法\n什么是约瑟夫环问题：约瑟夫环问题在不同平台被”优化”描述的不一样，例如在牛客剑指offer叫孩子们的游戏，还有叫杀人游戏，点名……最直接的感觉还是力扣上剑指offer62的描述：圆圈中最后剩下的数字问题描述：0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n列表循环模拟：这个问题最本质其实就是循环链表的问题，围成一个圈之后，就没有结尾这就是一个典型的循环链表嘛！一个一个顺序报数，那不就是链表的遍历枚举嘛！数到对应数字的出列，这不就是循环链表的删除嘛！\n并且这里还有非常方便的地方：\n循环链表的向下枚举不需要考虑头尾问题，直接node&#x3D;node.next向下循环聊表的删除也不需要考虑头尾问题，直接node.next&#x3D;node.next.next删除当然也有一些需要注意的地方\n形成环形链表很简单，只需要将普通链表的最后一个节点的next指向第一个节点即可\n循环链表中只有一个节点的时候停止返回，即node.next&#x3D;node的时候\n删除，需要找到待删除的前面节点，所以我们删除计数的时候要少即一位，利用前面的那个节点直接删除后面节点即可\n这样，思路明确，直接开撸代码：\nclass Solution &#123;    class node//链表节点    &#123;        int val;        public node(int value) &#123;            this.val=value;        &#125;        node next;    &#125;    public int lastRemaining(int n, int m) &#123;        if(m==1)return n-1;//一次一个直接返回最后一个即可        node head=new node(0);        node team=head;//创建一个链表        for(int i=1;i&lt;n;i++)        &#123;            team.next=new node(i);            team=team.next;        &#125;        team.next=head;//使形成环        int index=0;//从0开始计数        while (head.next!=head) &#123;//当剩余节点不止一个的时候            //如果index=m-2 那就说明下个节点(m-1)该删除了            if(index==m-2)            &#123;                head.next=head.next.next;                index=0;            &#125;            else &#123;                index++;            &#125;            head=head.next;        &#125;        return head.val;    &#125;&#125;\n当然，这种算法太复杂了，大部分的OJ你提交上去是无法AC的，因为超时太严重了，具体的我们可以下面分析。\n有序集合模拟上面使用链表直接模拟游戏过程会造成非常严重非常严重的超时，n个数字，数到第m个出列。因为m如果非常大远远大于m，那么将进行很多次转圈圈。所以我们可以利用求余的方法判断等价最低的枚举次数，然后将其删除即可，在这里你可以继续使用自建链表去模拟，上面的while循环以及上面只需添加一个记录长度的每次求余算圈数即可：\nint len=n;while (head.next!=head) &#123;  if(index==(m-2)%len)  &#123;    head.next=head.next.next;    index=0;    len--;  &#125;  else &#123;    index++;  &#125;  head=head.next;&#125;\n但我们很多时候不会手动去写一个链表模拟，我们会借助ArrayList和LinkedList去模拟，如果使用LinkedList其底层也是链表，使用ArrayList的话其底层数据结构是数组。不过在使用List其代码方法一致。\nList可以直接知道长度，也可删除元素，使用List的难点是一个顺序表怎们模拟成循环链表？\n咱们仔细思考：假设当前长度为n，数到第m个(通过上面分析可以求余让这个有效的m不大于n)删除，在index位置删除。那么删除后剩下的就是n-1长度，index位置就是表示第一个计数的位置，我们可以通过求余得知走下一个删除需要多少步，那么下个位置怎么确定呢？你可以分类讨论看看走的次数是否越界，但这里有更巧妙的方法，可以直接求的下一次具体的位置，公式就是为：\nindex=(index+m-1)%(list.size());\n因为index是从1计数，如果是循环的再往前m-1个就是真正的位置，但是这里可以先假设先将这个有序集合的长度扩大若干倍，然后从index计数开始找到假设不循环的位置index2，最后我们将这个位置index2%(集合长度)即为真正的长度。使用这个公式一举几得，既能把上面m过大循环过多的情况解决，又能找到真实的位置，就是将这个环先假设成线性的然后再去找到真的位置，如果不理解的话可以再看看这个图：这种情况的话大部分的OJ是可以勉强过关的，面试官的层面也大概率差不多的，具体代码为：\nclass Solution &#123;    public int lastRemaining(int n, int m) &#123;        if(m==1)            return n-1;        List&lt;Integer&gt;list=new ArrayList&lt;&gt;();        for(int i=0;i&lt;n;i++)        &#123;            list.add(i);        &#125;        int index=0;        while (list.size()&gt;1)        &#123;            index=(index+m-1)%(list.size());            list.remove(index);        &#125;        return list.get(0);    &#125;&#125;\n递归公式解决我们回顾上面的优化过程，上面用求余可以解决m比n大很多很多的情况(即理论上需要转很多很多圈的情况)。但是还可能存在n本身就很大的情况，无论是顺序表ArrayList还是链表LinkedList去频繁查询、删除都是很低效的。\n所以聪明的人就开始从数据找一些规律或者关系。\n先抛出公式：\nf(n,m)=(f(n-1,m)+m)%nf(n,m)指n个人，报第m个编号出列最终编号\n下面要认真看一下我的分析过程：\n我们举个例子，有0 1 2 3 4 5 6 7 8 9十个数字，假设m为3,最后结果可以先记成f(10,3)，即使我们不知道它是多少。\n当进行第一次时候，找到元素2 删除，此时还剩9个元素，但起始位置已经变成元素3。等价成3 4 5 6 7 8 9 0 1这9个数字重写开始找。\n此时这个序列最终剩下的一个值即为f(10,3)，这个序列的值和f(9,3)不同，但是都是9个数且m等于3，所以其删除位置是相同的，即算法大体流程是一致的，只是各位置上的数字不一样。所以我们需要做的事情是找找这个序列上和f(9,3)值上有没有什么联系。\n寻找过程中别忘记两点，首先可通过**%符号**对数字有效扩充，即我们可以将3 4 5 6 7 8 9 0 1这个序列看成(3,4,5,6,7,8,9,10,11)%10.这里的10即为此时的n数值。\n另外数值如果是连续的，那么最终一个结果的话是可以找到联系的(差值为一个定制)。所以我们可以就找到f(10,3)和f(9,3)值之间结果的关系，可以看下图：所以f(10,3)的结果就可以转化为f(9,3)的表达,后面也是同理：\nf(10,3)=(f(9,3)+3)%10f(9,3)=(f(8,3)+3)%9……f(2,3)=(f(1,3)+3)%2f(1,3)=0\n这样，我们就不用模拟操作，可以直接从数值的关系找到递推的关系，可以轻轻松松的写下代码：\nclass Solution &#123;    int index=0;    public int lastRemaining(int n, int m) &#123;         if(n==1)            return 0;              return (lastRemaining(n-1,m)+m)%n;    &#125;&#125;\n但是递归效率因为有个来回的规程，效率相比直接迭代差一些，也可从前往后迭代：\nclass Solution &#123;    public int lastRemaining(int n, int m) &#123;        int value=0;            for(int i=1;i&lt;=n;i++)            &#123;                value=(value+m)%i;            &#125;            return  value;    &#125;&#125;\n结语我想，通过本篇文章你应该掌握和理解了约瑟夫环问题，这种裸的约瑟夫环问题出现的概率很大，考察很频繁，链表模拟是根本思想，有序集合模拟链表是提升，而公式递推才是最有学习价值的地方，如果你刚开始接触不理解可以多看几遍。如果能用公式递推给面试官说两句，讲讲原理，那一定会让面试官眼前一亮的\n"},{"title":"Mymap Myset","url":"/2025/09/19/mymap_myset/","content":"红黑树模拟实现map和set\n\n\n一、map和set模板set用value标识元素(value就是key，类型为T)，并且每个value必须唯一 。\ntemplate &lt; class Key&gt;//set\n\n\n\n在map中，键值key通常用于排序和惟一地标识元素，而值value中存储与此键值key关联的内容。键值key和值value的类型可能不同，并且在map的内部，key与value通过成员类型value_type绑定在一起，为其取别名称为pair：\ntypedef pair&lt;const Key, T&gt; value_type;template &lt; class Key, class T&gt;//map\n\n 用红黑树同时封装出set和map时，set传给value的是一个value，map传给value的是一个pair，set和map传给红黑树的value决定了这棵树里面存的节点值类型。上层容器不同，底层红黑树的Key和T也不同。\n\n在上层容器set中，K和T都代表Key，底层红黑树节点当中存储K和T都是一样的；map中，K代表键值Key，T代表由Key和Value构成的键值对，底层红黑树中只能存储T。所以红黑树为了满足同时支持set和map，节点当中存储T\n这就要对红黑树进行改动。\n二、红黑树节点定义1.红黑树节点定义由类模板template&lt;class K,class V&gt;\n\n修改为\ntemplate&lt;class T&gt;\n\n那么节点定义修改为:\n//红黑树节点定义template&lt;class T&gt;struct RBTreeNode&#123;\tRBTreeNode&lt;T&gt;* _left;//节点的左孩子\tRBTreeNode&lt;T&gt;* _right;//节点的右孩子\tRBTreeNode&lt;T&gt;* _parent;//节点的父亲 \tT _data;//节点的值，_data里面存的是K就传K，存的是pair就传pair\tColour _col;//节点颜色 \tRBTreeNode(const T&amp; x)\t\t:_left(nullptr)\t\t, _right(nullptr)\t\t, _parent(nullptr)\t\t, _data(x)\t\t, _col(RED)\t&#123;&#125;&#125;;\n\n由于红黑树不知道上层传的是K还是pair，这是由上层传递的模板参数T决定的，上层是封装我的map和set\n2.仿函数（1）节点比较大小时存在的问题红黑树插入节点时，需要比较节点的大小，kv需要改成_data:\n//插入pair&lt;Node*, bool&gt; Insert(const T&amp; data)&#123;\tif (_root == nullptr)\t&#123;\t\t_root = new Node(data);\t\t_root-&gt;_col = BLACK;\t\treturn make_pair(_root, true);\t&#125;\t//1.先看树中，kv是否存在\tNode* parent = nullptr;\tNode* cur = _root;\twhile (cur)\t&#123;\t\tif (cur-&gt;_data &lt; data)\t\t&#123;\t\t\t//kv比当前节点值大，向右走\t\t\tparent = cur;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (cur-&gt;_data &gt; data)\t\t&#123;\t\t\t//kv比当前节点值小，向左走\t\t\tparent = cur;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse\t\t&#123;\t\t\t//kv和当前节点值相等，已存在，插入失败\t\t\treturn make_pair(cur, false);\t\t&#125;\t&#125;\t//2.走到这里，说明kv在树中不存在，需要插入kv，并且cur已经为空，parent已经是叶子节点了\tNode* newNode = new Node(kv);\tnewNode-&gt;_col = RED;\tif (parent-&gt;_data &lt; data)\t&#123;\t\t//kv比parent值大，插入到parent的右边\t\tparent-&gt;_right = newNode;\t\tnewNode-&gt;_parent = parent;\t&#125;\telse\t&#123;\t\t//kv比parent值小，插入到parent的左边\t\tparent-&gt;_left = newNode;\t\tnewNode-&gt;_parent = parent;\t&#125;\tcur = newNode;\t       //如果父亲存在，且父亲颜色为红就要处理\twhile (parent &amp;&amp; parent-&gt;_col == RED)\t&#123;\t\t//情况一和情况二、三的区别关键看叔叔\t\tNode* grandfather = parent-&gt;_parent;//当父亲是红色时，根据规则（2）根节点一定是黑色，祖父一定存在\t\tif (parent == grandfather-&gt;_left)//父亲是祖父的左子树\t\t&#123;\t\t\tNode* uncle = grandfather-&gt;_right;\t\t\t//情况一：叔叔存在且为红\t\t\tif (uncle-&gt;_col == RED)\t\t\t&#123;\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t//继续向上调整\t\t\t\tcur = grandfather;\t\t\t\tparent = cur-&gt;_parent;\t\t\t&#125;\t\t\telse//情况二+情况三：叔叔不存在或叔叔存在且为黑\t\t\t&#123;\t\t\t\t//情况二：单旋\t\t\t\tif (cur == parent-&gt;_left)\t\t\t\t&#123;\t\t\t\t\tRotateR(grandfather);\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\telse//情况三：双旋\t\t\t\t&#123;\t\t\t\t\tRotateL(parent);\t\t\t\t\tRotateR(grandfather);\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\tbreak;//插入结束\t\t\t&#125;\t\t&#125;\t\telse//父亲是祖父的右子树\t\t&#123;\t\t\tNode* uncle = grandfather-&gt;_left;\t\t\t//情况一：叔叔存在且为红\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == RED)\t\t\t&#123;\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t//继续往上调整\t\t\t\tcur = grandfather;\t\t\t\tparent = grandfather-&gt;_parent;\t\t\t&#125;\t\t\telse//情况二+情况三：叔叔不存在或叔叔存在且为黑\t\t\t&#123;\t\t\t\t//情况二：单旋\t\t\t\tif (cur == parent-&gt;_right)\t\t\t\t&#123;\t\t\t\t\tRotateL(grandfather);\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\telse//情况三：双旋\t\t\t\t&#123;\t\t\t\t\tRotateR(parent);\t\t\t\t\tRotateL(grandfather);\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\tbreak;//插入结束\t\t\t&#125;\t\t&#125;\t&#125;\t_root-&gt;_col = BLACK;\treturn make_pair(newNode, true);&#125;\n\n但是以上代码在插入新节和查找节点时，当和当前节点比较大小时，Key可以比较，但是pair比较不了，也就是set可以比较，但是map比较不了。这就需要写一个仿函数，如果是map就取_data里面的first也就是Key进行比较，通过泛型解决红黑树里面存的是什么。所以上层容器map需要向底层的红黑树提供仿函数来获取T里面的Key，这样无论上层容器是set还是map，都可以用统一的方式进行比较了。\n(2) 仿函数仿函数让一个类的使用看上去像个函数。仿函数是在类中实现了一个operator( )，是一个类的对象，这个类就有了类似函数的行为，所以这个类就是一个仿函数类，目的是为了让函数拥有类的性质。\n这个类的对象即仿函数，可以当作一般函数去用，只不过仿函数的功能是在一个类中的运算符operator()中实现的，使用的时候把函数作为参进行传递即可。\nset有set的仿函数，map有map的仿函数，尽管set的仿函数看起来没有什么作用，但是，必须要把它传给底层红黑树，这样红黑树就能根据仿函数分别获取set的key和map的first。\n①：set的仿函数\nnamespace delia&#123;\ttemplate&lt;class K&gt;\tclass set\t&#123;\t\t//仿函数，获取set的key\t\tstruct SetKeyOfT\t\t&#123;\t\t\tconst K&amp; operator()(const K&amp; key)\t\t\t&#123;\t\t\t\treturn key;\t\t\t&#125;\t\t&#125;;        public:\t\tbool insert(const K&amp; k)\t\t&#123;\t\t\t_t.Insert(k);\t\t\treturn true;\t\t&#125; \tprivate:\t\tRBTree&lt;K, K,SetKeyOfT&gt; _t;\t&#125;;&#125;\n\n②map的仿函数\nnamespace delia&#123;\ttemplate&lt;class K,class V&gt;\tclass map\t&#123;\t\t//仿函数，获取map的first\t\tstruct MapKeyOfT\t\t&#123;\t\t\tconst K&amp; operator()(const pair&lt;const K, V&gt;&amp; kv)\t\t\t&#123;\t\t\t\treturn kv.first;\t\t\t&#125;\t\t&#125;;     public:        //插入\t\tbool insert(const pair&lt;const K, V&gt;&amp; kv)\t\t&#123;\t\t\t_t.Insert(kv);\t\t\treturn true;\t\t&#125;\tprivate:\t\tRBTree&lt;K, pair&lt;const K, V&gt;, MapKeyOfT&gt; _t;\t&#125;;&#125;\n\n有了仿函数红黑树的类在实现时，就要在模板参数中增加KeyOfT仿函数。\n（3）修改红黑树定义template&lt;class K, class T, class KeyOfT&gt;class RBTree&#123;\ttypedef RBTreeNode&lt;T&gt; Node;\tprivate:\tNode* _root;&#125;;\n\n（4）修改红黑树插入//插入pair&lt;Node*, bool&gt; Insert(const pair&lt;K, V&gt;&amp; kv)&#123;\tif (_root == nullptr)\t&#123;\t\t_root = new Node(kv);\t\t_root-&gt;_col = BLACK;\t\treturn make_pair(_root, true);\t&#125;\tKeyOfT kot;\t//1.先看树中，kv是否存在\tNode* parent = nullptr;\tNode* cur = _root;\twhile (cur)\t&#123;\t\tif (kot(cur-&gt;_data) &lt; kot(data))\t\t&#123;\t\t\t//kv比当前节点值大，向右走\t\t\tparent = cur;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (kot(cur-&gt;_data) &gt; kot(data))\t\t&#123;\t\t\t//kv比当前节点值小，向左走\t\t\tparent = cur;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse\t\t&#123;\t\t\t//kv和当前节点值相等，已存在，插入失败\t\t\treturn make_pair(cur, false);\t\t&#125;\t&#125;\t//2.走到这里，说明kv在树中不存在，需要插入kv，并且cur已经为空，parent已经是叶子节点了\tNode* newNode = new Node(kv);\tnewNode-&gt;_col = RED;\tif (kot(parent-&gt;_data) &lt; kot(data))\t&#123;\t\t//kv比parent值大，插入到parent的右边\t\tparent-&gt;_right = newNode;\t\tnewNode-&gt;_parent = parent;\t&#125;\telse\t&#123;\t\t//kv比parent值小，插入到parent的左边\t\tparent-&gt;_left = newNode;\t\tnewNode-&gt;_parent = parent;\t&#125;\tcur = newNode;\t//如果父亲存在，且父亲颜色为红就要处理\twhile (parent &amp;&amp; parent-&gt;_col == RED)\t&#123;\t\t//情况一和情况二、三的区别关键看叔叔\t\tNode* grandfather = parent-&gt;_parent;//当父亲是红色时，根据规则（2）根节点一定是黑色，祖父一定存在\t\tif (parent == grandfather-&gt;_left)//父亲是祖父的左子树\t\t&#123;\t\t\tNode* uncle = grandfather-&gt;_right;\t\t\t//情况一：叔叔存在且为红\t\t\tif (uncle-&gt;_col == RED)\t\t\t&#123;\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t//继续向上调整\t\t\t\tcur = grandfather;\t\t\t\tparent = cur-&gt;_parent;\t\t\t&#125;\t\t\telse//情况二+情况三：叔叔不存在或叔叔存在且为黑\t\t\t&#123;\t\t\t\t//情况二：单旋\t\t\t\tif (cur == parent-&gt;_left)\t\t\t\t&#123;\t\t\t\t\tRotateR(grandfather);\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\telse//情况三：双旋\t\t\t\t&#123;\t\t\t\t\tRotateL(parent);\t\t\t\t\tRotateR(grandfather);\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\tbreak;//插入结束\t\t\t&#125;\t\t&#125;\t\telse//父亲是祖父的右子树\t\t&#123;\t\t\tNode* uncle = grandfather-&gt;_left;\t\t\t//情况一：叔叔存在且为红\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == RED)\t\t\t&#123;\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t//继续往上调整\t\t\t\tcur = grandfather;\t\t\t\tparent = grandfather-&gt;_parent;\t\t\t&#125;\t\t\telse//情况二+情况三：叔叔不存在或叔叔存在且为黑\t\t\t&#123;\t\t\t\t//情况二：单旋\t\t\t\tif (cur == parent-&gt;_right)\t\t\t\t&#123;\t\t\t\t\tRotateL(grandfather);\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\telse//情况三：双旋\t\t\t\t&#123;\t\t\t\t\tRotateR(parent);\t\t\t\t\tRotateL(grandfather);\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\tbreak;//插入结束\t\t\t&#125;\t\t&#125;\t&#125;\t_root-&gt;_col = BLACK;\treturn make_pair(newNode, true);&#125;void RotateR(Node* parent)&#123;\tNode* subL = parent-&gt;_left;\tNode* subLR = nullptr;\tif (subL)\t&#123;\t\tsubLR = subL-&gt;_right;\t&#125;\t//1.左子树的右子树变我的左子树\tparent-&gt;_left = subLR;\tif (subLR)\t&#123;\t\tsubLR-&gt;_parent = parent;\t&#125;\t//左子树变父亲\tsubL-&gt;_right = parent;\tNode* parentParent = parent-&gt;_parent;\tparent-&gt;_parent = subL;\tif (parent == _root)//parent是根\t&#123;\t\t_root = subL;\t\t_root-&gt;_parent = nullptr;\t&#125;\telse//parent不是根，是子树\t&#123;\t\tif (parentParent-&gt;_left == parent)\t\t&#123;\t\t\t//parent是自己父亲的左子树,将subL作为parent父亲的左孩子\t\t\tparentParent-&gt;_left = subL;\t\t&#125;\t\telse\t\t&#123;\t\t\t//parent是自己父亲的右子树,将subL作为parent父亲的右孩子\t\t\tparentParent-&gt;_right = subL;\t\t&#125;\t\t//subL的父亲就是parent的父亲\t\tsubL-&gt;_parent = parentParent;\t&#125;&#125;void RotateL(Node* parent)&#123;\tNode* subR = parent-&gt;_right;\tNode* subRL = nullptr;\tif (subR)\t&#123;\t\tsubRL = subR-&gt;_left;\t&#125;\t//1.右子树的左子树变我的右子树\tparent-&gt;_right = subRL;\tif (subRL)\t&#123;\t\tsubRL-&gt;_parent = parent;\t&#125;\t//2.右子树变父亲\tsubR-&gt;_left = parent;\tNode* parentParent = parent-&gt;_parent;\tparent-&gt;_parent = subR;\tif (parent == _root)//parent是根\t&#123;\t\t_root = parent;\t\t_root-&gt;_parent = nullptr;\t&#125;\telse//parent不是根，是子树\t&#123;\t\tif (parentParent-&gt;_left == parent)\t\t&#123;\t\t\t//parent是自己父亲的左子树,将subR作为parent父亲的左孩子\t\t\tparentParent-&gt;_left = subR;\t\t&#125;\t\telse\t\t&#123;\t\t\t//parent是自己父亲的右子树,将subR作为parent父亲的右孩子\t\t\tparentParent-&gt;_right = subR;\t\t&#125;\t\t//subR的父亲就是parent的父亲\t\tsubR-&gt;_parent = parentParent;\t&#125;&#125;\n\n（5）修改红黑树查找//查找Node* Find(const K&amp; key)&#123;\tKeyOfT kot;\tNode* cur = _root;\twhile (cur)\t&#123;\t\tif (kot(cur-&gt;_data) &lt; key)\t\t&#123;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (kot(cur-&gt;_data) &gt; key)\t\t&#123;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse\t\t&#123;\t\t\treturn cur;\t\t&#125;\t&#125;\treturn nullptr;//空树，直接返回&#125;\n\n三、红黑树迭代器map和set的迭代器的实现其实本质上是红黑树迭代器的实现，迭代器的实现需要定义模板类型、模板类型引用、模板类型指针。 \n1.红黑树中迭代器重命名 在红黑树中重命名模板类型、模板类型引用、模板类型指针，定义为public，外部就能使用iterator了：\ntemplate&lt;class K, class T, class KeyOfT&gt;class RBTree&#123;\ttypedef RBTreeNode&lt;T&gt; Node; public:\ttypedef __TreeIterator&lt;T, T&amp;, T*&gt; iterator;//模板类型、模板类型引用、模板类型指针        //红黑树函数...    private:\tNode* _root;&#125;;\n\n2.正向迭代器定义红黑树的迭代器的本质是对节点指针进行封装，所以迭代器中只有封装红黑树节点指针这一个成员变量 。正向迭代器：\ntemplate&lt;class T,class Ref,class ptr&gt;struct __TreeIterator&#123;\ttypedef RBTreeNode&lt;T&gt; Node;\ttypedef __TreeIterator&lt;T, Ref, ptr&gt; Self;      \tNode* _node;//成员变量\t&#125;;\n\n3.迭代器构造用节点指针构造正向迭代器：\n//构造函数__TreeIterator(Node* node)\t:_node(node)&#123;&#125;\n\n4.正向迭代器重载*Ref对正向迭代器解引用，返回节点数据引用\n//* 解引用，返回节点数据Ref Operator*()&#123;\treturn _node-&gt;_data;&#125;\n\n5.正向迭代器重载-&gt;Ptr对正向迭代器使用-&gt;，返回节点数据指针：\n//-&gt; 返回节点数据地址Ptr Operator-&gt;()&#123;\treturn &amp;_node-&gt;_data;&#125;\n\n6.正向迭代器重载&#x3D;&#x3D;判断节点是否相同\n//判断两个迭代器是否相同bool operator==(const Self&amp; s)&#123;\treturn _node == s._node;//判断节点是否相同&#125;\n\n7.正向迭代器重载！&#x3D;判断节点是否不同\n//判断两个迭代器是否不同bool operator!=(const Self&amp; s)&#123;\treturn _node != s._node;//判断节点是否不同&#125;\n\n8.正向迭代器++①当节点的右子树不为空时，++就要走到右子树的最左节点\n ②当节点的右子树为空时，++就要走到节点的父亲\n\t//红黑树迭代器的++也就是红黑树的++\tSelf operator++()\t&#123;\t\t//1.右子树不为空\t\tif (_node-&gt;_right)\t\t&#123;\t\t\t//下一个访问的是右树的中序第一个节点（即右子树最左节点）。\t\t\tNode* left = _node-&gt;_right; \t\t\t//找最左节点\t\t\twhile (left-&gt;_left)\t\t\t&#123;\t\t\t\tleft = left-&gt;_left;\t\t\t&#125;\t\t\t_node = left;\t\t&#125;\t\telse//2.右子树为空，下一个访问的就是当前节点的父亲\t\t&#123;\t\t\tNode* cur = _node;\t\t\tNode* parent = cur-&gt;_parent;\t\t\twhile (parent &amp;&amp; cur == parent-&gt;_right)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_parent;\t\t\t\tparent = parent-&gt;_parent;\t\t\t&#125;\t\t\t_node = parent;\t\t&#125; \t\treturn *this;\t&#125;&#125;;\n\n9.正向迭代器– ①当节点的左子树不为空时，++就要走到左子树的最右节点\n ②当节点的左子树为空时，++就要走到节点的父亲\n//红黑树迭代器的--也就是红黑树的--Self operator--()&#123;\t//1.左子树不为空\tif (_node-&gt;_left)\t&#123;\t\t//下一个访问的是左树的中序左后节点（即做子树最右节点）。\t\tNode* right = _node-&gt;_left;\t\t//找最右节点\t\twhile (right-&gt;_right)\t\t&#123;\t\t\tright = right-&gt;_right;\t\t&#125;\t\t_node = right;\t&#125;\telse//2.左子树为空，下一个访问的就是当前节点的父亲\t&#123;\t\tNode* cur = _node;\t\tNode* parent = cur-&gt;_parent;\t\twhile (parent &amp;&amp; cur == parent-&gt;_left)\t\t&#123;\t\t\tcur = cur-&gt;_parent;\t\t\tparent = parent-&gt;_parent;\t\t&#125;\t\t_node = parent;\t&#125;\treturn *this;&#125;\n\n10.红黑树中实现迭代器实现begin( )找最左节点，end( )最后一个节点的下一个位置\ntemplate&lt;class K, class T, class KeyOfT&gt;class RBTree&#123;\ttypedef RBTreeNode&lt;T&gt; Node; public:\ttypedef __TreeIterator&lt;T, T&amp;, T*&gt; iterator;//模板类型、模板类型引用、模板类型指针        //找最左节点\titerator begin()\t&#123;\t\tNode* left = _root;\t\twhile (left &amp;&amp; left-&gt;_left)\t\t&#123;\t\t\tleft = left-&gt;_left;\t\t&#125; \t\treturn iterator(left)//返回最左节点的正向迭代器\t&#125; \t//结束\titerator end()\t&#123;\t\treturn iterator(nullptr);\t&#125;    private:\tNode* _root;&#125;;\n\n四、set模拟实现调用红黑树对应接口实现set，插入和查找函数返回值当中的节点指针改为迭代器:\n#pragma once#include &quot;RBTree.h&quot;namespace delia&#123;\ttemplate&lt;class K&gt;\tclass set\t&#123;\t\t//仿函数，获取set的key\t\tstruct SetKeyOfT\t\t&#123;\t\t\tconst K&amp; operator()(const K&amp; key)\t\t\t&#123;\t\t\t\treturn key;\t\t\t&#125;\t\t&#125;;\tpublic:\t\ttypedef typename RBTree&lt;K, K, SetKeyOfT&gt;::iterator iterator;\t\t\t\t//迭代器开始\t\titerator begin()\t\t&#123;\t\t\treturn _t.begin();\t\t&#125; \t\t//迭代器结束\t\titerator end()\t\t&#123;\t\t\treturn _t.end();\t\t&#125; \t\t//插入函数\t\tpair&lt;iterator,bool&gt; insert(const K&amp; key)\t\t&#123;\t\t\t\t\t\treturn _t.Insert(key);\t\t&#125; \t\t//查找\t\titerator find(const K&amp; key)\t\t&#123;\t\t\treturn _t.find(key);\t\t&#125;\tprivate:\t\tRBTree&lt;K, K, SetKeyOfT&gt; _t;\t&#125;;&#125;\n\n五、map模拟实现调用红黑树对应接口实现map，插入和查找函数返回值当中的节点指针改为迭代器，增加operator[ ]的重载:\n#pragma once#include &quot;RBTree.h&quot;namespace delia&#123;\ttemplate&lt;class K, class V&gt;\tclass map\t&#123;\t\t//仿函数，获取map的first\t\tstruct MapKeyOfT\t\t&#123;\t\t\tconst K&amp; operator()(const pair&lt;const K, V&gt;&amp; kv)\t\t\t&#123;\t\t\t\treturn kv.first;\t\t\t&#125;\t\t&#125;;\tpublic:\t\ttypedef typename RBTree&lt;K, K, MapKeyOfT&gt;::iterator iterator; \t\t//迭代器开始\t\titerator begin()\t\t&#123;\t\t\treturn _t.begin();\t\t&#125; \t\t//迭代器结束\t\titerator end()\t\t&#123;\t\t\treturn _t.end();\t\t&#125; \t\t//插入\t\tpair&lt;iterator, bool&gt; insert(const pair&lt;const K, V&gt;&amp; kv)\t\t&#123;\t\t\treturn _t.Insert(kv);\t\t&#125; \t\t//重载operator[]\t\tV&amp; operator[](const K&amp; key)\t\t&#123;\t\t\tpair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));\t\t\titerator it = ret.first;\t\t\treturn it-&gt;second;\t\t&#125; \t\t//查找\t\titerator find(const K&amp; key)\t\t&#123;\t\t\treturn _t.find(key);\t\t&#125; \tprivate:\t\tRBTree&lt;K, pair&lt;const K, V&gt;, MapKeyOfT&gt; _t;\t&#125;;&#125;\n\n六、红黑树完整代码段#pragma once#include&lt;iostream&gt;using namespace std;  //节点颜色enum Colour&#123;\tRED,\tBLACK,&#125;; //红黑树节点定义template&lt;class T&gt;struct RBTreeNode&#123;\tRBTreeNode&lt;T&gt;* _left;//节点的左孩子\tRBTreeNode&lt;T&gt;* _right;//节点的右孩子\tRBTreeNode&lt;T&gt;* _parent;//节点的父亲 \tT _data;//节点的值\tColour _col;//节点颜色 \tRBTreeNode(const T&amp; x)\t\t:_left(nullptr)\t\t, _right(nullptr)\t\t, _parent(nullptr)\t\t, _data(x)\t\t, _col(RED)\t&#123;&#125;&#125;;  template&lt;class T,class Ref,class ptr&gt;struct __TreeIterator&#123;\ttypedef RBTreeNode&lt;T&gt; Node;\ttypedef __TreeIterator&lt;T, Ref, ptr&gt; Self; \tNode* _node; \t//构造函数\t__TreeIterator(Node* node)\t\t:_node(node)\t&#123;&#125;\t\t//* 解引用，返回节点数据\tRef operator*()\t&#123;\t\treturn _node-&gt;_data;\t&#125; \t//-&gt; 返回节点数据地址\t//Ptr operator-&gt;()\t//&#123;\t//\treturn &amp;_node-&gt;_data;\t//&#125; \t//判断两个迭代器是否相同\tbool operator==(const Self&amp; s)\t&#123;\t\treturn _node == s._node;\t&#125; \t//判断两个迭代器是否不同\tbool operator!=(const Self&amp; s)\t&#123;\t\treturn _node != s._node;\t&#125; \t//红黑树迭代器的++也就是红黑树的++\tSelf operator++()\t&#123;\t\t//1.右子树不为空\t\tif (_node-&gt;_right)\t\t&#123;\t\t\t//下一个访问的是右树的中序第一个节点（即右子树最左节点）。\t\t\tNode* left = _node-&gt;_right; \t\t\t//找最左节点\t\t\twhile (left-&gt;_left)\t\t\t&#123;\t\t\t\tleft = left-&gt;_left;\t\t\t&#125;\t\t\t_node = left;\t\t&#125;\t\telse//2.右子树为空，下一个访问的就是当前节点的父亲\t\t&#123;\t\t\tNode* cur = _node;\t\t\tNode* parent = cur-&gt;_parent;\t\t\twhile (parent &amp;&amp; cur == parent-&gt;_right)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_parent;\t\t\t\tparent = parent-&gt;_parent;\t\t\t&#125;\t\t\t_node = parent;\t\t&#125; \t\treturn *this;\t&#125; \t//红黑树迭代器的--也就是红黑树的--\tSelf operator--()\t&#123;\t\t//1.左子树不为空\t\tif (_node-&gt;_left)\t\t&#123;\t\t\t//下一个访问的是左树的中序左后节点（即做子树最右节点）。\t\t\tNode* right = _node-&gt;_left; \t\t\t//找最右节点\t\t\twhile (right-&gt;_right)\t\t\t&#123;\t\t\t\tright = right-&gt;_right;\t\t\t&#125;\t\t\t_node = right;\t\t&#125;\t\telse//2.左子树为空，下一个访问的就是当前节点的父亲\t\t&#123;\t\t\tNode* cur = _node;\t\t\tNode* parent = cur-&gt;_parent;\t\t\twhile (parent &amp;&amp; cur == parent-&gt;_left)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_parent;\t\t\t\tparent = parent-&gt;_parent;\t\t\t&#125;\t\t\t_node = parent;\t\t&#125; \t\treturn *this;\t&#125;  &#125;; //插入节点颜色是红色好，还是黑色好，红色//因为插入红色节点，可能破坏规则3，影响不大//插入黑色节点，一定破坏规则4 ，并且影响其他路径，影响很大 template&lt;class K, class T, class KeyOfT&gt;class RBTree&#123;\ttypedef RBTreeNode&lt;T&gt; Node;public:\ttypedef __TreeIterator&lt;T, T&amp;, T*&gt; iterator;//模板类型、模板类型引用、模板类型指针 \t//构造函数\tRBTree()\t\t:_root(nullpte)\t&#123;&#125; \t//析构\t~RBTree()\t&#123;\t\t_Destroy(_root);\t\t_root = nullptr;\t&#125; \tvoid _Destroy(Node* root)\t&#123;\t\tif (root == nullptr)\t\t&#123;\t\t\treturn;\t\t&#125;\t\t_Destroy(root-&gt;_left);\t\t_Destroy(root-&gt;_right);\t\tdelete root;\t&#125; \t//找最左节点\titerator begin()\t&#123;\t\tNode* left = _root;\t\twhile (left &amp;&amp; left-&gt;_left)\t\t&#123;\t\t\tleft = left-&gt;_left;\t\t&#125; \t\treturn iterator(left);//返回最左节点的正向迭代器\t&#125; \t//结束\titerator end()\t&#123;\t\treturn iterator(nullptr);\t&#125; \t//构造函数\tRBTree()\t\t:_root(nullptr)\t&#123;&#125; \tvoid Destroy(Node* root)\t&#123;\t\tif (root == nullptr)\t\t&#123;\t\t\treturn;\t\t&#125; \t\tDestroy(root-&gt;_left);\t\tDestroy(root-&gt;_right);\t&#125;\t~RBTree()\t&#123;\t\tDestroy(_root);\t\t_root = nullptr;\t&#125; \t//插入\tpair&lt;Node*, bool&gt; Insert(const T&amp; data)\t&#123;\t\tif (_root == nullptr)\t\t&#123;\t\t\t_root = new Node(data);\t\t\t_root-&gt;_col = BLACK;\t\t\treturn make_pair(_root, true);\t\t&#125; \t\tKeyOfT kot; \t\t//1.先看树中，kv是否存在\t\tNode* parent = nullptr;\t\tNode* cur = _root;\t\twhile (cur)\t\t&#123;\t\t\tif (kot(cur-&gt;_data) &lt; kot(data))\t\t\t&#123;\t\t\t\t//kv比当前节点值大，向右走\t\t\t\tparent = cur;\t\t\t\tcur = cur-&gt;_right;\t\t\t&#125;\t\t\telse if (kot(cur-&gt;_data) &gt; kot(data))\t\t\t&#123;\t\t\t\t//kv比当前节点值小，向左走\t\t\t\tparent = cur;\t\t\t\tcur = cur-&gt;_left;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//kv和当前节点值相等，已存在，插入失败\t\t\t\treturn make_pair(cur, false);\t\t\t&#125;\t\t&#125; \t\t//2.走到这里，说明kv在树中不存在，需要插入kv，并且cur已经为空，parent已经是叶子节点了\t\tNode* newNode = new Node(data);\t\tnewNode-&gt;_col = RED;\t\tif (kot(parent-&gt;_data) &lt; kot(data))\t\t&#123;\t\t\t//kv比parent值大，插入到parent的右边\t\t\tparent-&gt;_right = newNode;\t\t\tnewNode-&gt;_parent = parent;\t\t&#125;\t\telse\t\t&#123;\t\t\t//kv比parent值小，插入到parent的左边\t\t\tparent-&gt;_left = newNode;\t\t\tnewNode-&gt;_parent = parent;\t\t&#125;\t\tcur = newNode; \t\t//如果父亲存在，且父亲颜色为红就要处理\t\twhile (parent &amp;&amp; parent-&gt;_col == RED)\t\t&#123;\t\t\t//情况一和情况二、三的区别关键看叔叔\t\t\tNode* grandfather = parent-&gt;_parent;//当父亲是红色时，根据规则（2）根节点一定是黑色，祖父一定存在\t\t\tif (parent == grandfather-&gt;_left)//父亲是祖父的左子树\t\t\t&#123;\t\t\t\tNode* uncle = grandfather-&gt;_right;\t\t\t\t//情况一：叔叔存在且为红\t\t\t\tif (uncle-&gt;_col == RED)\t\t\t\t&#123;\t\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED; \t\t\t\t\t//继续向上调整\t\t\t\t\tcur = grandfather;\t\t\t\t\tparent = cur-&gt;_parent;\t\t\t\t&#125;\t\t\t\telse//情况二+情况三：叔叔不存在或叔叔存在且为黑\t\t\t\t&#123;\t\t\t\t\t//情况二：单旋\t\t\t\t\tif (cur == parent-&gt;_left)\t\t\t\t\t&#123;\t\t\t\t\t\tRotateR(grandfather);\t\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t\t&#125;\t\t\t\t\telse//情况三：双旋\t\t\t\t\t&#123;\t\t\t\t\t\tRotateL(parent);\t\t\t\t\t\tRotateR(grandfather);\t\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t\t&#125;\t\t\t\t\tbreak;//插入结束\t\t\t\t&#125;\t\t\t&#125;\t\t\telse//父亲是祖父的右子树\t\t\t&#123;\t\t\t\tNode* uncle = grandfather-&gt;_left;\t\t\t\t//情况一：叔叔存在且为红\t\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == RED)\t\t\t\t&#123;\t\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED; \t\t\t\t\t//继续往上调整\t\t\t\t\tcur = grandfather;\t\t\t\t\tparent = grandfather-&gt;_parent;\t\t\t\t&#125;\t\t\t\telse//情况二+情况三：叔叔不存在或叔叔存在且为黑\t\t\t\t&#123;\t\t\t\t\t//情况二：单旋\t\t\t\t\tif (cur == parent-&gt;_right)\t\t\t\t\t&#123;\t\t\t\t\t\tRotateL(grandfather);\t\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t\t&#125;\t\t\t\t\telse//情况三：双旋\t\t\t\t\t&#123;\t\t\t\t\t\tRotateR(parent);\t\t\t\t\t\tRotateL(grandfather);\t\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t\t&#125;\t\t\t\t\tbreak;//插入结束\t\t\t\t&#125;\t\t\t&#125; \t\t&#125;\t\t_root-&gt;_col = BLACK; \t\treturn make_pair(newNode, true);\t&#125; \tvoid RotateR(Node* parent)\t&#123;\t\tNode* subL = parent-&gt;_left;\t\tNode* subLR = nullptr; \t\tif (subL)\t\t&#123;\t\t\tsubLR = subL-&gt;_right;\t\t&#125;\t\t//1.左子树的右子树变我的左子树\t\tparent-&gt;_left = subLR; \t\tif (subLR)\t\t&#123;\t\t\tsubLR-&gt;_parent = parent;\t\t&#125; \t\t//左子树变父亲\t\tsubL-&gt;_right = parent;\t\tNode* parentParent = parent-&gt;_parent;\t\tparent-&gt;_parent = subL;  \t\tif (parent == _root)//parent是根\t\t&#123;\t\t\t_root = subL;\t\t\t_root-&gt;_parent = nullptr;\t\t&#125;\t\telse//parent不是根，是子树\t\t&#123;\t\t\tif (parentParent-&gt;_left == parent)\t\t\t&#123;\t\t\t\t//parent是自己父亲的左子树,将subL作为parent父亲的左孩子\t\t\t\tparentParent-&gt;_left = subL;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//parent是自己父亲的右子树,将subL作为parent父亲的右孩子\t\t\t\tparentParent-&gt;_right = subL;\t\t\t&#125; \t\t\t//subL的父亲就是parent的父亲\t\t\tsubL-&gt;_parent = parentParent;\t\t&#125;\t&#125; \tvoid RotateL(Node* parent)\t&#123;\t\tNode* subR = parent-&gt;_right;\t\tNode* subRL = nullptr; \t\tif (subR)\t\t&#123;\t\t\tsubRL = subR-&gt;_left;\t\t&#125; \t\t//1.右子树的左子树变我的右子树\t\tparent-&gt;_right = subRL; \t\tif (subRL)\t\t&#123;\t\t\tsubRL-&gt;_parent = parent;\t\t&#125; \t\t//2.右子树变父亲\t\tsubR-&gt;_left = parent;\t\tNode* parentParent = parent-&gt;_parent;\t\tparent-&gt;_parent = subR; \t\tif (parent == _root)//parent是根\t\t&#123;\t\t\t_root = parent;\t\t\t_root-&gt;_parent = nullptr;\t\t&#125;\t\telse//parent不是根，是子树\t\t&#123;\t\t\tif (parentParent-&gt;_left == parent)\t\t\t&#123;\t\t\t\t//parent是自己父亲的左子树,将subR作为parent父亲的左孩子\t\t\t\tparentParent-&gt;_left = subR;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//parent是自己父亲的右子树,将subR作为parent父亲的右孩子\t\t\t\tparentParent-&gt;_right = subR;\t\t\t&#125; \t\t\t//subR的父亲就是parent的父亲\t\t\tsubR-&gt;_parent = parentParent;\t\t&#125;\t&#125; \t//查找\tNode* Find(const K&amp; key)\t&#123;\t\tKeyOfT kot;\t\tNode* cur = _root;\t\twhile (cur)\t\t&#123;\t\t\tif (kot(cur-&gt;_data) &lt; key)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_right;\t\t\t&#125;\t\t\telse if (kot(cur-&gt;_data) &gt; key)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_left;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\treturn cur;\t\t\t&#125;\t\t&#125;\t\treturn nullptr;//空树，直接返回\t&#125; \tbool _CheckBalance(Node* root, int blackNum, int count)\t&#123;\t\tif (root == nullptr)\t\t&#123;\t\t\tif (count != blackNum)\t\t\t&#123;\t\t\t\tcout &lt;&lt; &quot;黑色节点数量不相等&quot; &lt;&lt; endl;\t\t\t\treturn false;\t\t\t&#125;\t\t\treturn true;\t\t&#125; \t\tif (root-&gt;_col == RED &amp;&amp; root-&gt;_parent-&gt;_col == RED)\t\t&#123;\t\t\tcout &lt;&lt; &quot;存在连续红色节点&quot; &lt;&lt; endl;\t\t\treturn false;\t\t&#125; \t\tif (root-&gt;_col == BLACK)\t\t&#123;\t\t\tcount++;\t\t&#125; \t\treturn _CheckBalance(root-&gt;_left, blackNum, count)\t\t\t&amp;&amp; _CheckBalance(root-&gt;_right, blackNum, count);\t&#125; \t//检查是否平衡\tbool CheckBalance()\t&#123;\t\tif (_root == nullptr)\t\t&#123;\t\t\treturn true;\t\t&#125; \t\tif (_root-&gt;_col == RED)\t\t&#123;\t\t\tcout &lt;&lt; &quot;根节点为红色&quot; &lt;&lt; endl;\t\t\treturn false;\t\t&#125; \t\t//找最左路径做黑色节点数量参考值\t\tint blackNum = 0;\t\tNode* left = _root;\t\twhile (left)\t\t&#123;\t\t\tif (left-&gt;_col == BLACK)\t\t\t&#123;\t\t\t\tblackNum++;\t\t\t&#125;\t\t\tleft = left-&gt;_left;\t\t&#125; \t\tint count = 0;\t\treturn _CheckBalance(_root, blackNum, count);\t&#125;  \t//遍历\tvoid _InOrder(Node* root)\t&#123;\t\tif (root == nullptr)\t\t&#123;\t\t\treturn;\t\t&#125; \t\t_InOrder(root-&gt;_left);\t\tcout &lt;&lt; root-&gt;_kv.first &lt;&lt; &quot;:&quot; &lt;&lt; root-&gt;_kv.second &lt;&lt; endl;\t\t_InOrder(root-&gt;_right);\t&#125; \tvoid InOrder()\t&#123;\t\t_InOrder(_root);\t\tcout &lt;&lt; endl;\t&#125;private:\tNode* _root;&#125;;\n\n七、验证代码#pragma once#include &quot;RBTree.h&quot;#include &lt;vector&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &quot;Map.h&quot;#include &quot;Set.h&quot; int main()&#123;\tdelia::map&lt;int, int&gt; m;\tm.insert(make_pair(1, 1));\tm.insert(make_pair(3, 3));\tm.insert(make_pair(0, 0));\tm.insert(make_pair(9, 9));  \tdelia::set&lt;int&gt; s;\ts.insert(1);\ts.insert(5);\ts.insert(2);\ts.insert(1);\ts.insert(13);\ts.insert(0);\ts.insert(15);\ts.insert(18);  \tdelia::set&lt;int&gt;::iterator sit = s.begin();\twhile (sit != s.end())\t&#123;\t\tcout &lt;&lt; *sit &lt;&lt; &quot; &quot;;\t\t++sit;\t&#125;\tcout &lt;&lt; endl;  \treturn 0;&#125;\n\n"}]