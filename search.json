[{"url":"/2025/09/19/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","content":"IO多路复用\n\n需求：高性能网络服务器设计一个高性能的网络服务器，提供多个客户端同时连接，并处理客户端的处理请求。\n1.第一印象   当我们知道这个需求后，我们第一印象为了应对并发，可以基于多线程，写一个多线程的程序，但是多线程会有一些弊端就是需要cpu上下文切换，这样就会导致处理操作句柄，代价大。那多线程不够好的话，我们就把目光放在了单线程，用单线程处理大量客户端的连接，先抛出一个问题：加入有多个客户端连接，在处理A用户发过来的消息的同时，B用户也发来了小心，会不会导致B的消息丢失，答案是不会的，原因是处理IO时，处理IO操作时，接收B传过来消息的并不是CPU，而是DMA控制器，不会造成数据的丢失，为数据的不丢失性，提供了保障。\n  那我们知道每一个网络连接再内核中都已一个文件描述符来表示，我们可以用单线程程序写一个网络服务器\nwhile(1)&#123;for(fdx in (fdA~FdB))\t&#123;if(Fdx 有数据)\t\t&#123;读Fdx,处理数据\t\t&#125;\t&#125;&#125;\n\n那如果这样写一个网络服务器，他的性能也不够低，但是不够好，原因时判断有数据到来是程序在判断，效率不够好。那么我们看一下Select 是怎么做的？\n2.Select我们先看select的有关的函数：\n①:nfds：最大的文件描述符+1，fd_set *readfds：读文件描述符集合，\nint select(int nfds, fd_set *readfds, fd_set *writefds,                 fd_set *exceptfds, struct timeval *timeout);\n\n②：从fd_set 移除一个文件描述符\nvoid FD_CLR(int fd, fd_set *set);\n\n③：判断fd是否在fd_set集合中\nint  FD_ISSET(int fd, fd_set *set);\n\n④：向fd_set 加入一个文件描述符，当面向网络服务器设计中，这里加入的使tcp协议中三次握手中的accept返回的文件描述符\nvoid FD_SET(int fd, fd_set *set);\n\n⑤：初始化一个fd_set\nvoid FD_ZERO(fd_set *set);\n\n其中最核心的是fd_set,他是一个bitmap(位图)，\n1.调用selsct提前的准备工作：\n2.首先要创建一个fd_set 类型的变量，（监听集合）\n3.调用FD_ZERO,初始化这个监听集合，\n4.按需求调用FD_SET增加监听，\n5.调用select函数，使调用的进程陷入阻塞，操作系统轮询监听集合，\n那么select函数底层做了什么操作呢？\nselect函数会将用户态空间的fd_set拷贝到内核态，由内核态来判断是否有数据到来，如果没有数据到来，那么select函数就会阻塞，当有数据到来的时候select函数会将fd_set中标识有数据到来的fd标记，select会返回，然后程序再遍历文件描述符，遍历出就绪的文件描述符并做出相应的数据处理。\n那么，这样做的优点就是，判断文件描述符有数据到来变为了由内核来判断，提高了效率，也不会大量再内核态和用户态切换，\n缺点：\n①：fd_set 位图限制了数量，该数量需要重新编译内核\n②：数据仍然有大量的内核态和用户态之间的拷贝\n③：监听集合和就绪集合耦合\n④：再海量监听，少量就绪的情况下，大部分时间会浪费再FD_ISSET()中，原因使并不知道就绪的是哪一个！\n那么pool函数又做了哪些优化呢？简单说一下。\n3.Poll直接说结果，Poll函数中将select 中的bitmap 改为了结构体，那么就解决了位图数量限制的问题，\nint poll(struct pollfd *fds, nfds_t nfds, int timeout);// fds 是一个链表的指针，链表的节点是一个pollfd 的结构体，nfds 是节点的个数，struct pollfd &#123;               int   fd;         /* file descriptor */               short events;     /* requested events */               short revents;    /* returned events */           &#125;;//其中fd，依然是文件描述符，//events 标识的是，这个文件描述符在意的事件，当是这个事件来临的时候，poll函数会将pollfd.revects置位//来表征这个文件描述已经就绪//pollfd.revents 可以用来每次处理完就绪的文件描述否后，再置为0；//虽然并没有完全解决就序集合与遍历集合耦合的问题，但是poolfds 是可以重用的；select中的fd_set不可以重用！\n\n这样的优化，解决了部分问题，但是仍然不够完美，那么epoll又是怎样优化的：\n4.epollepoll 不支持跨平台，linux下独有的，不属于posxi规范，\nepoll相对于select 和 poll来说就比较复杂一点了\n我们先看相关的函数\n int epoll_create(int size);//创建一个epoll的文件对象，size值没有意义，只要是一个大于0的数值即可，\n\n调用epoll_create 时，内核除了我们在epoll文件系统里建了个file结点，再内核cache（缓冲区）里建了一个红黑树 用于存储以后epoll_ctl 传来的socket外还会建立一个list链表，用于存储准备就绪的事件。当就绪以后，会将就绪集合拷贝到用户。\nint  epoll_ctl(int  epfd,  int  op,  int  fd,  struct  epoll_event *event);// epfd是epoll_create 创建的epoll的文件对象，//op的选项：//EPOLL_CTL_ADD 向epfd中加入一个文件描述符  //EPOLL_CTL_MOD 向epfd更改与目标文件关联的事件事件描述符fd//EPOLL_CTL_DEL 向epfd中删除一个文件描述符//event 是一个指向结构体 epoll_event 的指针，//而 epoll_event 中的 events 描述的是事件的属性，读阻塞/写阻塞，data是携带的额外的信息，//epoll_data_t 是一个联合体一般是fd。typedef union epoll_data &#123;               void        *ptr;               int          fd;//一般是这个               uint32_t     u32;               uint64_t     u64;           &#125; epoll_data_t;struct epoll_event &#123;               uint32_t     events;      /* Epoll events */               epoll_data_t data;        /* User data variable */           &#125;;\n\n所以我们可以得出结论，epoll_ctl()函数中的event 所指向的结构体相比较poll中的结构体是去掉了revent。\n在这里我们不仅将fd 经过op操作可以加入epfd中，同时我们还传入一个携带同样fd的event结构体，所以，传入两份相同的数据确实会对空间造成影响，但是结构体中的fd，可以使我们再epoll_wait 函数中能够遍历这个数组\n用来遍历就绪集合，达到一个空间换时间的功能。他同时也处理了select 的就绪集合和监听集合耦合的问题。\nint epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);//如果 timeout 的值为负数，epoll_wait 函数会一直阻塞，直到有事件发生。//如果 timeout 的值为零，epoll_wait 函数会立即返回，无论是否有事件发生。这相当于在非阻塞模式下调用 epoll_wait。//如果 timeout 的值为正数，epoll_wait 函数将等待指定的时间，直到有事件发生或者超时。如果在超时之前有事件发生，epoll_wait 函数将立即返回，并将事件存储到 events 数组中。如果超时时间到达而没有事件发生，epoll_wait 函数也会返回，此时返回值为 0，表示没有事件发生。//struct epoll_event *events 是一个传入传出参数，events 是一个元素类型为struct epoll_event，长度为maxevents，他们将用来保存就绪集合，// return value 是就序集合的长度，再event.data.fd中找到就绪文件描述符。\n\n接下来我们看一个 实现epoll的一个示例代码：\n#define MAX_EVENTS 10           struct epoll_event ev, events[MAX_EVENTS];           int listen_sock, conn_sock, nfds, epollfd;           /* Code to set up listening socket, &#x27;listen_sock&#x27;,              (socket(), bind(), listen()) omitted */           epollfd = epoll_create1(0);           if (epollfd == -1) &#123;               perror(&quot;epoll_create1&quot;);               exit(EXIT_FAILURE);           &#125;           ev.events = EPOLLIN;           ev.data.fd = listen_sock;           if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) == -1) &#123;               perror(&quot;epoll_ctl: listen_sock&quot;);               exit(EXIT_FAILURE);           &#125;           for (;;) &#123;               nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);               if (nfds == -1) &#123;                   perror(&quot;epoll_wait&quot;);                   exit(EXIT_FAILURE);               &#125;               for (n = 0; n &lt; nfds; ++n) &#123;                   if (events[n].data.fd == listen_sock) &#123;                       conn_sock = accept(listen_sock,                                     (struct sockaddr *) &amp;addr, &amp;addrlen);                       if (conn_sock == -1) &#123;                           perror(&quot;accept&quot;);                           exit(EXIT_FAILURE);                       &#125;                       setnonblocking(conn_sock);                       ev.events = EPOLLIN | EPOLLET;                       ev.data.fd = conn_sock;                       if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,                                   &amp;ev) == -1) &#123;                           perror(&quot;epoll_ctl: conn_sock&quot;);                           exit(EXIT_FAILURE);                       &#125;                   &#125; else &#123;                       do_use_fd(events[n].data.fd);                   &#125;               &#125;           &#125;\n\nepoll 的边缘触发，水平触发，以及海量监听下性能也很好  scales well to \nredis 是用的epoll 。njinx javaNIO (linux 下)\n问题：既然fd_set 运用了bitmap select之前是标识监听的文件描述符，select 会把就绪的集合置为，所以底层怎么技既能标识监听又能表示就绪的？\n"},{"url":"/2025/09/19/STL/","content":"STL"},{"title":"crmson预览版.md","url":"/2025/09/19/crmson%E9%A2%84%E8%A7%88%E7%89%88-md/","content":"Crimson 是 Crimson OSD 的代码名称，它是下一代用于多核心可扩展性的 OSD 。它通过快速网络和存储设备提高性能，采用包括 DPDK 和 SPDK 的顶级技术。BlueStore 继续支持 HDD 和 SSD。Crimson 旨在与早期版本的 OSD 守护进程与类 Ceph OSD 兼容。\nCrimson 基于 SeaStar C++ 框架构建，是核心 Ceph 对象存储守护进程 OSD 组件的新实现，并替换了 Ceph OSD 。Crimson OSD 最小化延迟并增加 CPU 处理器用量。它使用高性能异步 IO 和新的线程架构，旨在最小化上下文切换和用于跨通信的操作间的线程通信。\n以下分析基于 v19.2.1 进行分析。\n\n\n一、架构对比Ceph OSD 是 Ceph 集群的一部分，负责通过网络提供对象访问、维护冗余和高可用性，并将对象持久化到本地存储设备。作为 Classic OSD 的重写版本，Crimson OSD 从客户端和其他 OSD 的角度兼容现有的 RADOS 协议，提供相同的接口和功能。Ceph OSD 的模块（例如 Messenger、OSD 服务和 ObjectStore）在其职责上保持不变，但跨组件交互的形式和内部资源管理经过了大幅重构，以应用无共享设计和自下而上的用户空间任务调度。\n经典 OSD 的架构对多核处理器并不友好，因为每个组件都包含工作线程池，并且每个组件之间共享队列。举个简单的例子，一个 PG 操作首先需要由一个 Messenger 工作线程处理，将原始数据流组装或解码成一条消息，然后放入消息队列进行调度。之后， PG 工作线程获取该消息，经过必要的处理后，将请求以事务的形式交给 ObjectStore 。事务提交后， PG 将完成操作，并通过发送队列和 Messenger 工作线程再次发送回复。虽然可以通过向池中添加更多线程将工作负载扩展到多个 CPU ，但这些线程默认共享资源，因此需要使用锁，从而引入争用。实际情况会更加复杂，因为每个组件内部都会实现更多的线程池，并且如果跨 OSD 进行复制，数据路径也会更长。\n\n经典架构面临的一个主要挑战是，锁争用开销会随着任务和核心数量的增加而迅速增长，并且每个锁定点在某些情况下都可能成为扩展瓶颈。此外，即使在无争用的情况下，这些锁和队列也会产生延迟成本。多年来，人们在分析和优化更细粒度的资源管理和快速路径实现以跳过排队方面付出了巨大的努力。未来唾手可得的成果将会减少，在类似的设计下，可扩展性似乎正在收敛到某个乘数。此外，还存在其他挑战。由于簿记工作会在工作线程之间委派任务，延迟问题将随着线程池和任务队列的出现而恶化。锁可能会强制上下文切换，这会使情况更加糟糕。\nCrimson 项目希望通过无共享设计和运行至完成模型来解决 CPU 的可扩展性问题。该设计的基本原理是强制每个核心（或 CPU）运行一个固定线程，并在用户空间中调度非阻塞任务。请求及其资源按核心进行分片，因此它们可以在同一核心中处理直至完成。理想情况下，所有锁和上下文切换都不再需要，因为每个正在运行的非阻塞任务都拥有 CPU，直到其完成或协同让出。没有其他线程可以同时抢占该任务。如果无需与数据路径中的其他分片通信，则理想的性能将随着核心数量线性扩展，直到 IO 设备达到其极限。这种设计非常适合 Ceph OSD，因为在 OSD 级别，所有 IO 都已按 PG 分片。\n\n二、配置解析流程配置解析的代码位于 src/crimson/osd/main.cc 文件中的 auto early_config_result = crimson::osd::get_early_config(argc, argv); 函数，该函数主要逻辑如下:\n\n创建一个子进程，在子进程中尝试解析参数后，将参数编码后通过管道传递给父进程；\n父进程解析并返回参数给 main 函数中；\n\n子进程在 _get_early_config 函数中解析参数，其中 ceph 相关的参数使用 ceph_argparse_early_args 函数解析，并且根据 ceph 的 crimson_seastar_cpu_cores 参数来设置 --cpuset $cpu_cores --thread-affinity 1 ；或者根据 ceph 的 crimson_seastar_num_threads 参数来设置 --smp $smp --thread-affinity 0。注意 crimson_seastar_cpu_cores 参数的优先级高于 crimson_seastar_num_threads 参数。\n之后 main 函数中通过 app.run 函数调用，将解析到的参数传递给 seastar ，进而设置了 seastar 要启动的 shard 的数量及绑定 cpu 的配置。但是由于目前 main 中的 seastar::async 函数逻辑中没有显示的使用 seastar::smp::count 来将任务分发给多个 shard 执行，因此关于日志的配置，prometheus 的配置，crimson osd 的对象均是在 shard 0 （即 PRIMARY_CORE ）上执行的。\n三、网络通信流程在 crimson osd 进程启动的时候，会调用 OSD::start() 函数，其内部会对 public_msgr 和 cluster_msgr 两个对象执行 bind 和 start 操作。\n\nbind 操作: 对应的函数为 SocketMessenger::bind ， 该函数内部最终通过调用 seastar 的 invoke_on_all 下发 seastar::listen(s_addr, lo) 操作给所有 shard ，使所有的 shard 开始监听相同的端口；\nstart 操作: 对应的函数为 SocketMessenger::start ， 该函数内部通过调用 ShardedServerSocket::accept ，并在其内部调用 seastar 的 invoke_on_all 方法使每个 shard 接收新连接请求。每个 shard 接收到请求后，会逐步调用 SocketMessenger::accept &#x3D;&gt; SocketConnection::start_accept &#x3D;&gt; ProtocolV2::start_accept &#x3D;&gt; ProtocolV2::execute_accepting 等函数逐步处理请求，最终会调用到 OSD::do_ms_dispatch 函数正式处理客户端请求。\n\n在 OSD::do_ms_dispatch 函数内部，针对于请求消息的类型，有如下操作：\n\n必须在 PRIMARY_CORE shard 上执行的操作: 包括 CEPH_MSG_OSD_MAP、MSG_COMMAND、MSG_OSD_MARK_ME_DOWN 等；\n其他可以在任意 shard 上执行的操作：包括 CEPH_MSG_OSD_MAP、CEPH_MSG_OSD_OP、MSG_COMMAND 等；\n\n\n\n由于 OSD 中的每个 Shard 都会监听网络信息，所以每个 Shard 都可以处理网络请求；\n但是由于需要对请求按照 PG 映射到 Shard 中，所以内部引入了 pg_to_shard_mapping 的映射结构，每个请求都需要在 Shard 中检索映射表；\n如果当前 Shard 中的映射表中缺少 PG 的映射信息，会将请求发送给 Shard 0 来尝试创建对应的映射记录，并将该记录广播给所有的 Shard ；\n\n对于请求类型为 CEPH_MSG_OSD_OP 的关键代码链路如下:\nc// 处理对应的 op 请求seastar::future&lt;&gt; OSD::handle_osd_op(crimson::net::ConnectionRef conn, Ref&lt;MOSDOp&gt; m)&#123;    return pg_shard_manager.start_pg_operation&lt;ClientRequest&gt;(get_shard_services(), conn, std::move(m)).second;&#125;// 开始 pg 操作template&lt;typename T, typename... Args&gt; auto start_pg_operation(Args&amp;&amp;... args)&#123;......    auto fut =        opref.template enter_stage&lt;&gt;(opref.get_connection_pipeline().await_active)            ......            // 从 pg_to_shard_mapping 中获取 pg 与 shard 的对应关系，            // 如果对应的映射关系不存在，则根据各 shard 的负载情况创建映射关系。            .then([this, &amp;opref] &#123; return get_pg_to_shard_mapping().get_or_create_pg_mapping(opref.get_pgid()); &#125;)            .then_wrapped([this, &amp;logger, op = std::move(op)](auto fut) mutable &#123;                ......                auto core = fut.get();                logger.debug(&quot;&#123;&#125;: can_create=&#123;&#125;, target-core=&#123;&#125;&quot;, *op, T::can_create(), core);                // 处理已知 shard id 的 op 请求                return this-&gt;template with_remote_shard_state_and_op&lt;T&gt;(                    core, std::move(op), [this](ShardServices&amp; target_shard_services, typename T::IRef op) &#123;                        auto&amp; opref = *op;                        auto&amp; logger = crimson::get_logger(ceph_subsys_osd);                        logger.debug(&quot;&#123;&#125;: entering create_or_wait_pg&quot;, opref);                        return opref                            .template enter_stage&lt;&gt;(                                opref.get_pershard_pipeline(target_shard_services).create_or_wait_pg)                            .then([this, &amp;target_shard_services, op = std::move(op)]() mutable &#123;                                if constexpr (T::can_create()) &#123;                                    return this-&gt;template run_with_pg_maybe_create&lt;T&gt;(std::move(op),                                                                                        target_shard_services);                                &#125;                                else &#123;                                    return this-&gt;template run_with_pg_maybe_wait&lt;T&gt;(std::move(op),                                                                                    target_shard_services);                                &#125;                            &#125;);                    &#125;);            &#125;);    return std::make_pair(id, std::move(fut));&#125;// 获取或创建 pg 和 shard 的映射关系seastar::future&lt;core_id_t&gt; PGShardMapping::get_or_create_pg_mapping(spg_t pgid, core_id_t core_expected)&#123;    LOG_PREFIX(PGShardMapping::get_or_create_pg_mapping);    auto find_iter = pg_to_core.find(pgid);    if (find_iter != pg_to_core.end()) &#123;        auto core_found = find_iter-&gt;second;        // 一些校验逻辑        assert(core_found != NULL_CORE);        if (core_expected != NULL_CORE &amp;&amp; core_expected != core_found) &#123;            ERROR(&quot;the mapping is inconsistent for pg &#123;&#125;: core &#123;&#125;, expected &#123;&#125;&quot;, pgid, core_found, core_expected);            ceph_abort(&quot;The pg mapping is inconsistent!&quot;);        &#125;        return seastar::make_ready_future&lt;core_id_t&gt;(core_found);    &#125;    else &#123;        DEBUG(&quot;calling primary to add mapping for pg &#123;&#125; to the expected core &#123;&#125;&quot;, pgid, core_expected);        // 如果没有找到 pg 和 shard 的映射关系，则需要创建映射，        // 创建操作必须由 shard 0 执行。        return container()            .invoke_on(                0,                [pgid, core_expected, FNAME](auto&amp; primary_mapping) &#123;                    auto core_to_update = core_expected;                    // 在 shard 0 中判断对应的映射关系是否存在，                    // 如果存在且校验正常则可使用该映射关系                    auto find_iter = primary_mapping.pg_to_core.find(pgid);                    if (find_iter != primary_mapping.pg_to_core.end()) &#123;                        ......                    &#125;                    else &#123;                        // 如果在 shard 0 中也没有找到映射关系，则创建映射                        ceph_assert_always(primary_mapping.core_to_num_pgs.size() &gt; 0);                        std::map&lt;core_id_t, unsigned&gt;::iterator count_iter;                        if (core_expected == NULL_CORE) &#123;                            // 从 shard 中选择 pg 映射数量最少的最为当前 pg 的关联 shard                            count_iter = std::min_element(                                primary_mapping.core_to_num_pgs.begin(),                                primary_mapping.core_to_num_pgs.end(),                                [](const auto&amp; left, const auto&amp; right) &#123; return left.second &lt; right.second; &#125;);                            core_to_update = count_iter-&gt;first;                        &#125;                        ......                    &#125;                    assert(core_to_update != NULL_CORE);                    // 广播同步                    // 通过 invoke_on_others 确保所有 Core 的映射表同步更新                    // 将变更的映射关系广播给其他所有的 shard                    return primary_mapping.container().invoke_on_others(                        [pgid, core_to_update, FNAME](auto&amp; other_mapping) &#123;                            ......                        &#125;);                &#125;)                ......    &#125;&#125;// 处理 op 请求template&lt;typename T, typename F&gt; auto with_remote_shard_state_and_op(core_id_t core, typename T::IRef&amp;&amp; op, F&amp;&amp; f)&#123;    ceph_assert(op-&gt;use_count() == 1);    // 如果 op 请求的目标 shard 为当前 shard ，则在当前 shard 中处理    if (seastar::this_shard_id() == core) &#123;        auto f_conn = op-&gt;prepare_remote_submission();        op-&gt;finish_remote_submission(std::move(f_conn));        auto&amp; target_shard_services = shard_services.local();        return std::invoke(std::move(f), target_shard_services, std::move(op));    &#125;    ......    // 否则，将对应的 op 请求转发给对应的 shard 处理    logger.debug(&quot;&#123;&#125;: send &#123;&#125; to the remote pg core &#123;&#125;&quot;, opref, cc_seq, core);    return opref.get_handle().complete().then([this, core, cc_seq, op = std::move(op), f = std::move(f)]() mutable &#123;        get_local_state().registry.remove_from_registry(*op);        auto f_conn = op-&gt;prepare_remote_submission();        return shard_services.invoke_on(            core,            [this, cc_seq, f = std::move(f), op = std::move(op), f_conn = std::move(f_conn)](                auto&amp; target_shard_services) mutable &#123;                op-&gt;finish_remote_submission(std::move(f_conn));                target_shard_services.local_state.registry.add_to_registry(*op);                return this-&gt;template process_ordered_op_remotely&lt;T&gt;(                    cc_seq, target_shard_services, std::move(op), std::move(f));            &#125;);    &#125;);&#125;\n\n四、线程模型在服务启动时会通过解析 crimson_seastar_cpu_cores 或 crimson_seastar_num_threads 这两个配置来设置 seastar 框架的并发 shard 数量，之后在 PRIMARY_CORE 初始化环境，并通过 seastar 的 invoke_on、invoke_on_others、invoke_on_all、seastar::smp::submit_to 等方法来给 shard 下发任务，从而实现 osd 中相互独立的 shard 任务模型。\n4.1、shard 相关任务seastar 提供的不同的下发任务的方法比较:\n\n\n\n接口\n目标 Shard\n是否依赖 sharded 容器\n典型用途\n\n\n\ninvoke_on\n指定单个 Shard\n是\n访问特定 Shard 上的对象\n\n\ninvoke_on_others\n除当前 Shard 外的所有\n是\n广播操作（排除当前 Shard）\n\n\ninvoke_on_all\n所有 Shard（包括当前）\n是\n全局初始化&#x2F;清理\n\n\nsmp::submit_to\n指定单个 Shard\n否\n任意跨 Shard 任务\n\n\ninvoke_on 的部分操作如下:\nc// 更新配置值并通知所有观察者container().invoke_on(...)// 在 0 号 shard 上停止 shardsthis-&gt;container().invoke_on(0, [](auto&amp; ss) &#123; ... &#125;)// 在 0 号 shard 上新增 pg 和 shard 的映射关系container().invoke_on(0, [pgid, core_expected, FNAME](auto&amp;// 在 0 号 shard 上移除 pg 和 shard 的映射关系container().invoke_on(0, [pgid, FNAME](auto&amp; primary_mapping) &#123; ... &#125;)// 转发请求给特定 shardshard_services.invoke_on(core, ... )\n\ninvoke_on_others 的部分操作如下:\nc// 更新 proxy 配置container().invoke_on_others(...)// 广播 pg shard 新增映射记录primary_mapping.container().invoke_on_others(...)// 广播 pg shard 移除映射记录primary_mapping.container().invoke_on_others(...)\n\ninvoke_on_all 的部分操作如下:\ncseastar::listenss.listener-&gt;accept()ss.listener-&gt;abort_accept()ss.listener.reset()local_store.mkfs()local_store.mount()local_store.umount()local_store.mount_managers()local_store.set_secondaries(...)local_store.mkfs_managers()local_device.do_shard_mount()local_device.shard_mount()local_device.shard_mkfs()local_service.local_state.stop_pgs()local_service.local_state.broadcast_map_to_pgs(local_service, epoch)local_service.local_state.osdmap_gate.got_map(epoch)local_service.local_state.set_up_epoch(e)local_service.local_state.update_shard_superblock(superblock)local.local_state.update_map(...)local.local_state.stop_registry()osd_state._set_active()osd_state._set_stopping()\n\nseastar::smp::submit_to 的部分操作如下:\nc// 在 shard 0 上处理 CEPH_MSG_OSD_MAP/MSG_COMMAND/MSG_OSD_MARK_ME_DOWN 消息seastar::smp::submit_to(PRIMARY_CORE, ... )\n\n4.2、线程示例当 crimson_seastar_num_threads 设置为 2 的时候，crimson osd 的线程情况:\nbash[root@bugwz.host build]# ps -T -p 270088    PID    SPID TTY          TIME CMD 270088  270088 pts/11   00:30:31 crimson-osd 270088  270130 pts/11   00:22:41 reactor-1 270088  270131 pts/11   00:00:00 syscall-0 270088  270132 pts/11   00:00:00 syscall-1 270088  270133 pts/11   00:00:00 crimson-osd 270088  270134 pts/11   00:00:00 reactor-1\n\n当 crimson_seastar_num_threads 设置为 8 的时候，crimson osd 的线程情况:\nbash[root@bugwz.host build]# ps -T -p 345103    PID    SPID TTY          TIME CMD 345103  345103 pts/15   00:00:04 crimson-osd 345103  345145 pts/15   00:00:02 reactor-1 345103  345146 pts/15   00:00:02 reactor-2 345103  345147 pts/15   00:00:02 reactor-3 345103  345148 pts/15   00:00:02 reactor-4 345103  345149 pts/15   00:00:02 reactor-5 345103  345150 pts/15   00:00:02 reactor-6 345103  345151 pts/15   00:00:02 reactor-7 345103  345152 pts/15   00:00:00 syscall-7 345103  345153 pts/15   00:00:00 syscall-0 345103  345154 pts/15   00:00:00 syscall-4 345103  345155 pts/15   00:00:00 syscall-3 345103  345156 pts/15   00:00:00 syscall-2 345103  345157 pts/15   00:00:00 syscall-5 345103  345158 pts/15   00:00:00 syscall-1 345103  345159 pts/15   00:00:00 syscall-6 345103  345160 pts/15   00:00:00 crimson-osd 345103  345161 pts/15   00:00:00 reactor-1 345103  345162 pts/15   00:00:00 reactor-4 345103  345163 pts/15   00:00:00 reactor-5 345103  345164 pts/15   00:00:00 reactor-6 345103  345165 pts/15   00:00:00 reactor-7 345103  345166 pts/15   00:00:00 reactor-2 345103  345167 pts/15   00:00:00 reactor-3\n\n五、存储模块设计5.1、后端对象存储类型main 函数中会通过 crimson::os::FuturizedStore::create 函数来创建 store 对象。根据 osd_objectstore 和 osd_data 参数来配置 store 对象。其中 osd_objectstore 参数指定了后端对象存储的类型，支持的参数有 alienstore/cyanstore/seastore ，默认为 alienstore （即后端存储为 bluestore ）。其中 osd_data 参数指定了数据存储目录（比如当使用 vstart.sh 部署集群时，对应的配置默认为 ./build/dev/osd$id ）。\n对象存储类型:\n\nalienstore: 是 seastar 线程中的一个代理，主要是与 bluestore 进行通信。由于 io 任务会与 bluestore 进行通信，因此无需针对多个 osd 分片进行特殊处理。BlueStore 中没有针对 crimson 的定制，因为 bluestore 依赖于第三方 RocksDB 项目，而该项目仍然采用线程化设计，因此无法真正将其扩展为无共享设计。然而，在 crimson 能够提供经过优化且足够稳定的原生存储后端 seastore 之前，使用合理的开销来换取完善的存储后端解决方案是可以接受的。\ncyanstore: crimson osd 中的 cyanstore 与 classic osd 中的 memstore 相对应。为了支持多分片，唯一的变化是每个分片创建独立的 cyanstore 实例。一个目标是确保虚拟 IO 操作能够在同一核心中完成，以帮助识别 osd 级别的可扩展性问题（如果有）。另一个目标是在 osd 级别与 Classic 进行直接性能比较，而不会受到 objectstore 的复杂影响。\nseastore: seastore 是 crimson osd 的原生 objectstore 解决方案，它使用 seastar 框架开发并采用相同的设计原则。\n\n在 seastore 初始化的时候，会根据 seastore_main_device_type 参数来初始化 seastore 主设备，该参数可选值为 SSD/RANDOM_BLOCK_SSD （代码中还实现了 HDD/ZBD ，但是目前并不支持） ，默认为 SSD 。 在调用 Device::make_device(root, d_type) 函数创建 device 的过程中，会针对不同的设备类型又做了一些区分。\nseastore 设备类型对比:\n\n\n\ndevice_type\nbackend_type\ncreate func\n\n\n\nHDD\nbackend_type_t::SEGMENTED\nSegmentManager::get_segment_manager\n\n\nSSD\nbackend_type_t::SEGMENTED\nSegmentManager::get_segment_manager\n\n\nZBD\nbackend_type_t::SEGMENTED\nSegmentManager::get_segment_manager\n\n\nRANDOM_BLOCK_SSD\nbackend_type_t::RANDOM_BLOCK\nget_rb_device\n\n\n5.2、段存储格式信息当使用 vstart.sh 脚本部署测试集群后会发现 build/dev/osd*/ 目录下会存在一个 block 文件，该文件对应的就是一个 osd 组件后端的对象存储，由于一个 osd 中可能会启用多个 seastar shard ，并且由于 shard 间数据的隔离，因此需要对这大块存储空间进行切割，使每个 shard 各负责一块空间，从而实现操作数据的隔离。\n后端存储的格式化规则:\n\n开始部分为 superblock 空间，存储这个该存储空间的规划及使用信息；\n剩余空间平均分配给每个 shard ，实现独立的操作空间；\n\n创建 superblock 及 shard 空间规划函数如下:\ncusing std::vector;static block_sm_superblock_t make_superblock(device_id_t device_id, device_config_t sm_config, const seastar::stat_data&amp; data)&#123;    LOG_PREFIX(block_make_superblock);    using crimson::common::get_conf;    // seastore_device_size 默认为 50G    auto config_size = get_conf&lt;Option::size_t&gt;(&quot;seastore_device_size&quot;);    size_t size = (data.size == 0) ? config_size : data.size;    // 单个 segment 的大小，默认为 64M    auto config_segment_size = get_conf&lt;Option::size_t&gt;(&quot;seastore_segment_size&quot;);    // 计算 segment 数量： 总大小除以单个 segment 的大小    size_t raw_segments = size / config_segment_size;    // 计算每个 shard 所需要的段状态跟踪器大小    // 默认为一个 data.block_size 大小，如果计算出的每个 shard 所管理的 segments 数量超过 data.block_size 大小，    // 则返回超过 segments 数量的 data.block_size 的倍数值。    //    // seastar::smp::count 为 crimson osd 启动时指定的 shard 数量    // data.block_size 默认为 4096    size_t shard_tracker_size = SegmentStateTracker::get_raw_size(raw_segments / seastar::smp::count, data.block_size);    // 计算全部 shard 的段状态跟踪器的总大小    size_t total_tracker_size = shard_tracker_size * seastar::smp::count;    // 初始的偏移应该从 superblock 之后开始    size_t tracker_off = data.block_size;    // 计算减去 superblock 及所有段状态跟踪器总大小之后的剩余空间可分配的 segments 数量    size_t segments = (size - tracker_off - total_tracker_size) / config_segment_size;    // 计算每个 shard 可分配的 segments 数量    size_t segments_per_shard = segments / seastar::smp::count;    // 初始化每个 shard 信息    vector&lt;block_shard_info_t&gt; shard_infos(seastar::smp::count);    for (unsigned int i = 0; i &lt; seastar::smp::count; i++) &#123;        // 每个 shard 管理的 segments 总大小        shard_infos[i].size = segments_per_shard * config_segment_size;        // 每个 shard 管理的 segments 数量        shard_infos[i].segments = segments_per_shard;        // 标记每个 shard 的段状态跟踪器的在全部空间中的偏移        shard_infos[i].tracker_offset = tracker_off + i * shard_tracker_size;        // 标记每个 shard 的 segment 数据起始位置在全部空间中的偏移        shard_infos[i].first_segment_offset = tracker_off + total_tracker_size + i * segments_per_shard * config_segment_size;    &#125;    // 输出日志信息    INFO(&quot;&#123;&#125; disk_size=&#123;&#125;, segment_size=&#123;&#125;, block_size=&#123;&#125;&quot;,         device_id_printer_t&#123;device_id&#125;,         size,         uint64_t(config_segment_size),         data.block_size);    for (unsigned int i = 0; i &lt; seastar::smp::count; i++) &#123;        INFO(&quot;shard &#123;&#125; infos:&quot;, i, shard_infos[i]);    &#125;    // 返回 superblock 全部信息    return block_sm_superblock_t&#123;seastar::smp::count, config_segment_size, data.block_size, shard_infos, std::move(sm_config)&#125;;&#125;\n\n六、客户端使用方式由于 crimson osd 只支持 message v2 协议，所以我们在挂载 cephfs&#x2F;cephrbd 等的时候需要使用 message v2 的方式。\n相关命令:\nbash# 挂载 cephrbd - kernel 方式rbd device map -t krbd rbdpool/rbdimg01 -o mount_timeout=5,ms_mode=crc# 挂载 cephrbd - nbd 方式rbd device map -t nbd rbdpool/rbdimg01# 取消挂载 cephrbdrbd device unmap rbdpool/rbdimg01 -t krbdrbd device unmap rbdpool/rbdimg01 -t nbd# 挂载 cephfs - kernel 方式mount -t ceph 10.10.10.1:3300:/ /mnt/kernel-cephfs -o name=admin,secret=AQBVokZoak+LJRAAqgeJr6j77v729bfvBl/Z3g==,ms_mode=crc,mount_timeout=5# 挂载 cephfs - fuse 方式ceph-fuse -c /etc/ceph/ceph.conf -n client.admin -m 10.10.10.1:3300 /mnt/fuse-cephfs --client_mountpoint /# 取消挂载 cephfsumount /mnt/kernel-cephfsfusermount -u /mnt/fuse-cephfs\n\n相关代码实现:\nc// 筛选监听地址entity_addrvec_t pick_addresses(int what)&#123;    LOG_PREFIX(osd.cc : pick_addresses);    entity_addrvec_t addrs;    crimson::common::CephContext cct;    // 仅筛选 message v2 的地址    const auto flags = what | CEPH_PICK_ADDRESS_MSGR2;    if (int r = ::pick_addresses(&amp;cct, flags, &amp;addrs, -1); r &lt; 0) &#123;        throw std::runtime_error(&quot;failed to pick address&quot;);    &#125;    for (auto addr : addrs.v) &#123;        INFO(&quot;picked address &#123;&#125;&quot;, addr);    &#125;    return addrs;&#125;// 接收请求seastar::future&lt;&gt; SocketMessenger::start(const dispatchers_t&amp; _dispatchers)&#123;    assert(seastar::this_shard_id() == sid);    dispatchers.assign(_dispatchers);    if (listener) &#123;        // 仅支持 message v2 的地址        ceph_assert(get_myaddr().is_msgr2());        ceph_assert(get_myaddr().get_port() &gt; 0);        // 接收端口请求        return listener-&gt;accept([this](SocketRef _socket, entity_addr_t peer_addr) &#123;            assert(get_myaddr().is_msgr2());            SocketFRef socket = seastar::make_foreign(std::move(_socket));            if (listener-&gt;is_fixed_shard_dispatching()) &#123;                return accept(std::move(socket), peer_addr);            &#125;            else &#123;                return seastar::smp::submit_to(sid, [this, peer_addr, socket = std::move(socket)]() mutable &#123;                    return accept(std::move(socket), peer_addr);                &#125;);            &#125;        &#125;);    &#125;    return seastar::now();&#125;\n\n七、其他特性实现7.1、冷热存储分离当使用 vstart.sh 脚本部署测试的时候，我们会发现 --seastore-secondary-devs 和 --seastore-secondary-devs-type 配置，如果指定了这两个参数，该脚本便会通过 dd 格式化对应盘，然后创建 ./dev/osd$id/block.$type.1 目录，之后执行 ln -s $device ./dev/osd$id/block.$type.1/block 创建一个软链文件。详细的代码可以查看: https://github.com/ceph/ceph/blob/v19.2.1/src/vstart.sh#L1194 。\n按照官方解释这两个参数是用来指定次要块设备的列表和类型，进一步分析 crimson 官方文档 我们发现这两个配置可用于实现 ceph 的冷热存储分离特性，即随着时间的推移逐步将较快设备（主设备）中的冷数据迁移到较慢的设备（次要设备）中，通常要求次要设备的速度不应该比主设备更快。我们能发现该特性与 Cache Tiering 特性比较相似，之后也会做一下对比分析。\n关于主设备剔除数据到次要设备的相关参数:\n\nseastore_multiple_tiers_stop_evict_ratio: 当主设备的使用率低于此值时，停止将冷数据逐出到冷层。默认值为 0.5 。\nseastore_multiple_tiers_default_evict_ratio: 当主设备的使用率达到此值时，开始将冷数据迁移到次要设备。默认值为 0.6 。\nseastore_multiple_tiers_fast_evict_ratio: 当主设备的使用率达到此值时，开始执行快速逐出。默认值为 0.7 。\n\n八、模块解析九、代码逻辑梳理main 函数中启动的 seastar::async 异步任务的关键逻辑如下:\n\n设置日志级别并打开日志文件；\n启动 prometheus api server ；\n创建 client/cluster/hb_front/hb_back 消息管理器 SocketMessenger ；\n创建 store 对象；\n创建、初始化、启动 crimson osd 对象；\n\n9.1、消息管理器创建逻辑通过调用 crimson::net::Messenger::create 函数来依次创建 client/cluster/hb_front/hb_back 消息管理器，最终创建的对象类型为 SocketMessenger 。\n其中创建 client/cluster 消息对象的时候 dispatch_only_on_this_shard 参数为 false ，意味着接收到的消息可能会交由其他的 shard 进行处理；创建 hb_front/hb_back 消息对象的时候 dispatch_only_on_this_shard 参数为 true ，意味着接收到的消息仅会由当前 shard 处理。\n9.2、store 对象创建逻辑通过调用 crimson::os::FuturizedStore::create 函数来创建 store 对象。根据 osd_objectstore 和 osd_data 参数来配置 store 对象。其中 osd_objectstore 参数指定了后端对象存储的类型，支持的参数有 alienstore/cyanstore/seastore ，默认为 alienstore （即后端存储为 bluestore ）。其中 osd_data 参数指定了数据存储目录（比如当使用 vstart.sh 部署集群时，对应的配置默认为 ./build/dev/osd$id ）。\ncrimson 支持以下三个 objectstore 后端:\n\nalienstore: 提供与早期版本的对象存储（即 BlueStore）的兼容性。\ncyanstore: 用于测试的模拟后端，由易失性内存实施。此对象存储在典型的 osd 中的 memstore 后建模。\nseastore: 为 crimson osd 设计的新对象存储。对多个分片支持的路径因后端的特定目标而异。\n\n9.3、crimson osd mkfs 逻辑由于在启动 osd 组件之前，我们需要初始化 osd 的文件系统环境，为此需要执行 OSD::mkfs 函数（相关操作顺序可以参考 vstart.sh 脚本中在启动 osd 组件的步骤，其中在启动 osd 之前需要先对其存储路径的环境执行 mkfs 操作。）\nOSD::mkfs 函数中关键逻辑为:\nc1. store.start()store.mkfs(osd_uuid) // 重点2. store.mount()3. open_or_create_meta_coll(store)4. _write_superblock(...)5. store.write_meta(...)6. store.umount()7. store.stop()\n\n\n1. store.start()\n\n由于 store 的类型存在三种： alienstore/cyanstore/seastore ， 所以对应的 start 逻辑也有三种。由于 alienstore 只是 bluestore 的代理，且实现比较简单，为此不做介绍；而 cyanstore 是作为一个内存存储模块而存在，仅作为开发测试使用，为此这里也不做介绍；所以以下仅介绍 seastore 的实现逻辑，对应的函数为 SeaStore::start 。\nSeaStore::start 函数中关联逻辑为:\nc1. Device::make_device(root, d_type)2. device-&gt;start()3. shard_stores.start(root, device.get(), is_test)\n\n1. Device::make_device(root, d_type) 逻辑解析:在 seastore 中有一个 seastore_main_device_type 参数，用于设置 seastore 主设备的类型，可选值为 SSD/RANDOM_BLOCK_SSD （代码中还实现了 HDD/ZBD ，但是目前并不支持） ，默认为 SSD 。\nDevice::make_device(root, d_type) 函数内部在创建 device 的过程中，会针对不同的设备类型又做了一些区分，详细的类别分类如下:\n\n\n\ndevice_type\nbackend_type\ncreate func\n\n\n\nHDD\nbackend_type_t::SEGMENTED\nSegmentManager::get_segment_manager\n\n\nSSD\nbackend_type_t::SEGMENTED\nSegmentManager::get_segment_manager\n\n\nZBD\nbackend_type_t::SEGMENTED\nSegmentManager::get_segment_manager\n\n\nRANDOM_BLOCK_SSD\nbackend_type_t::RANDOM_BLOCK\nget_rb_device\n\n\n由于 seastore_main_device_type 默认为 SSD ，所以会通过 SegmentManager::get_segment_manager 函数来来创建一个 segment_manager::block::BlockSegmentManager 对象。\n2. device-&gt;start() 逻辑解析:当执行 device-&gt;start() 的时候，调用的就是 BlockSegmentManager::start 方法，继而调用的是 shard_devices.start(device_path, superblock.config.spec.dtype) ，由于 shard_devices 的类型为 seastar::sharded , 所以这里相当于调用了 seastar::sharded::start 函数来初始化了 BlockSegmentManager 对象。\n3. shard_stores.start(root, device.get(), is_test) 逻辑解析:之后的 shard_stores.start(root, device.get(), is_test) 函数执行中，由于 shard_stores 也是一个 seastar::sharded 封装的对象，所以其内部相当于调用了 seastar::sharded::start 函数来初始化了 SeaStore::Shard 对象。\n\n2. store.mount()\n\nstore.mount() 函数对应的是 SeaStore::mount 函数。\nSeaStore::mount 函数中关键逻辑为:\ncdevice-&gt;mount()device-&gt;get_sharded_device().get_secondary_devices()Device::make_device(path, dtype)sec_dev-&gt;start()sec_dev-&gt;mount()set_secondaries()\n\ndevice-&gt;mount() 函数对应的是 BlockSegmentManager::mount 函数，这个之前解释过，其内部通过调用 shard_devices.invoke_on_all 来触发在每个 shard 中执行 local_device.shard_mount() 函数，因此每个 shard 中调用的函数其实是 BlockSegmentManager::shard_mount() ，该函数内部的执行逻辑主要包括打开 device ，读取 superblock 信息，校验 superblock 信息，更新 tracker 信息等。\n\n3. open_or_create_meta_coll(store)\n\nopen_or_create_meta_coll(store) 对应的函数是 OSD::open_or_create_meta_coll 。\nOSD::open_or_create_meta_coll 函数中关键逻辑为:\ncstore.get_sharded_store().open_collection(coll_t::meta())store.get_sharded_store().create_new_collection(coll_t::meta())OSDMeta(ch, store.get_sharded_store())\n\n\n4. _write_superblock(…)\n\n_write_superblock(...) 的完整调用为 _write_superblock(store, std::move(meta_coll), std::move(superblock)) ，其对应的函数是 OSD::_write_superblock 。其内部主要的逻辑为将 superblock 信息写入存储中。\nOSD::_write_superblock 函数中关键逻辑为:\ncmeta_coll.load_superblock()meta_coll.create(t)meta_coll.store_superblock(t, superblock)store.get_sharded_store().do_transaction(meta_coll.collection(), std::move(t))\n\n\n5. store.write_meta(…)\n\nstore.write_meta(…) 对应很多写元信息的操作，操作的元信息包括 ceph_fsid ，magic ，whoami ，osd_key ， osdspec_affinity ， ready 等字段。这些信息位于 osd 运行目录的各个配置对应的文件中。\n\n6. store.umount()\n\nstore.umount() 对应的函数为 SeaStore::umount ， 其内部会同通过调用 shard_stores.invoke_on_all 函数，让每个 shard 执行 local_store.umount() 函数。\n\n7. store.stop()\n\nstore.stop() 对应的函数为 SeaStore::stop 。\nSeaStore::stop 函数中关键逻辑为:\ncsec_dev-&gt;stop()secondaries.clear()device-&gt;stop()shard_stores.stop()\n\n9.3.1、store.mkfs(osd_uuid)SeaStore::mkfs 函数中关键逻辑为:\nc1. read_meta(&quot;mkfs_done&quot;)2. seastar::open_directory(root)        root_f-&gt;list_directory(...)            Device::make_device(path, dtype)            secondaries.emplace_back(std::move(sec_dev))            p_sec_dev-&gt;start()            p_sec_dev-&gt;mkfs()            set_secondaries()3. device-&gt;mkfs(...)4. device-&gt;mount()5. local_store.mkfs_managers() // shard_stores.invoke_on_all(...) // 重点6. prepare_meta(new_osd_fsid)7. umount()\n\n\n\nread_meta(“mkfs_done”)\n\n\nread_meta(&quot;mkfs_done&quot;) 用于校验之前是否已经执行过 mkfs 操作，监测方式为读取 store 目录中的 mkfs_done 文件中的内容。\n\n\nseastar::open_directory(root)\n\n\nseastar::open_directory(root) 的逻辑为检索 store 目录中的文件，筛选前缀名为 block. 的文件&#x2F;目录，通过解析该文件&#x2F;目录的后缀，从而尝试调用 Device::make_device(path, dtype) 函数来创建对应的 device ， 进而操作对应的 device 执行 start 和 mkfs 函数操作。\n\n\ndevice-&gt;mkfs(…)\n\n\ndevice-&gt;mkfs(...) 对应的完整函数为 device-&gt;mkfs(device_config_t::create_primary(new_osd_fsid, id, d_type, sds)) ， 由于 seastore_main_device_type 默认为 SSD ，所以这里的 device-&gt;mkfs 指的是 BlockSegmentManager::mkfs 函数。\nBlockSegmentManager::mkfs 函数中关键逻辑为:\ncshard_devices.local().primary_mkfs(sm_config)    check_create_device(device_path, size)    open_device(device_path)    make_superblock(get_device_id(), sm_config, stat)    write_superblock(get_device_id(), device, sb)    device.close()local_device.shard_mkfs() // shard_devices.invoke_on_all(...)    open_device(device_path)    read_superblock(device, sd)    sb.validate()    tracker.reset(new SegmentStateTracker(shard_info.segments, sb.block_size))    tracker-&gt;write_out(get_device_id(), device, shard_info.tracker_offset)    device.close()\n\n其中 shard_devices.local().primary_mkfs(sm_config) 对应的函数为 BlockSegmentManager::primary_mkfs 。其内部逻辑如下:\n\ncheck_create_device(device_path, size): 通过 seastar::open_file_dma 函数来打开对应的 block 文件，并通过 f.truncate 和 f.allocate(0, size) 函数来调整对应文件的大小，用于后续存储数据。该步骤中的 seastore_block_create 配置用于控制是否创建 block ， 该参数默认为 true ；seastore_device_size 配置用于控制 block 的文件大小，该参数默认为 50GB 。\nopen_device(device_path): 通过 seastar::open_file_dma 方法来打开对应的 block 文件，用于后续的数据操作。\nmake_superblock(get_device_id(), sm_config, stat): 初始化 superblock 信息。其内部根据 seastar::smp::count 的数量，seastore_segment_size 参数（用于控制单个 segment 的大小，默认为 64M ）等信息来初始化 superblock 信息。\nwrite_superblock(get_device_id(), device, sb): 将序列化后的 superblock 信息写入 block 的文件头部。\ndevice.close(): 关闭打开的 device 。\n\n之后通过调用 shard_devices.invoke_on_all(...) 函数，该函数是 Seastar 框架中使用的方法，用于在所有的 seastar shard 上执行给定的函数。之后每个 shard 上执行 local_device.shard_mkfs() 函数。其内部回依次打开 device ，读取 superblock 信息，校验 superblock 信息，更新 tracker 信息等；之后便关闭 device 。\n\n\ndevice-&gt;mount()\n\n\ndevice-&gt;mount() 对应的函数为 BlockSegmentManager::mount 。\nBlockSegmentManager::mount 函数中关键逻辑为:\nclocal_device.shard_mount() // shard_devices.invoke_on_all(...)\n\n这里也是通过调用 shard_devices.invoke_on_all 来触发在每个 shard 中执行 local_device.shard_mount() 函数，因此每个 shard 中调用的函数其实是 BlockSegmentManager::shard_mount() ，该函数内部的执行逻辑主要包括打开 device ，读取 superblock 信息，校验 superblock 信息，更新 tracker 信息等。\n\n\nlocal_store.mkfs_managers()\n\n\n接着又通过调用 shard_stores.invoke_on_all(...) 来触发在每个 shard 中执行 local_store.mkfs_managers() 操作，对应的函数为 SeaStore::Shard::mkfs_managers 。\nSeaStore::Shard::mkfs_managers 函数中关键逻辑为:\ncinit_managers()transaction_manager-&gt;mkfs()init_managers()transaction_manager-&gt;mount()repeat_eagain(...)    transaction_manager-&gt;with_transaction_intr(...)        onode_manager-&gt;mkfs(t)        collection_manager-&gt;mkfs(t)        transaction_manager-&gt;write_collection_root(t, coll_root)        transaction_manager-&gt;submit_transaction(t)\n\n其中 init_managers() 函数指的是 SeaStore::Shard::init_managers() 函数，其内部会初始化 transaction_manager ， collection_manager ， onode_manager 对象。\n\ntransaction_manager: 初始化函数为 TransactionManagerRef make_transaction_manager ，该对象显然用于管理存储设备上的事务。\ncollection_manager: 初始化函数为 FlatCollectionManager::FlatCollectionManager ；\nonode_manager: 初始化函数为 FLTreeOnodeManager::FLTreeOnodeManager ；\n\ntransaction_manager 相关执行逻辑:\n\ntransaction_manager-&gt;mkfs(): 对应 TransactionManager::mkfs 函数；\ntransaction_manager-&gt;mount(): 对应 TransactionManager::mount 函数；\ntransaction_manager-&gt;with_transaction_intr(...): 对应 ExtentCallbackInterface::with_transaction_intr 函数；\n\n其中 TransactionManager::mkfs 函数中关键逻辑为:\ncepm-&gt;mount()journal-&gt;open_for_mkfs()epm-&gt;open_for_write()with_transaction_intr(...)close()\n\n其中 TransactionManager::mount 函数中关键逻辑为:\nccache-&gt;init()epm-&gt;mount()journal-&gt;replay(...)journal-&gt;open_for_mount()journal-&gt;get_trimmer().set_journal_head(start_seq)with_transaction_weak(...)epm-&gt;open_for_write()epm-&gt;start_background()\n\nTODO:\nonode_manager 相关执行逻辑:\n相关操作为 onode_manager-&gt;mkfs(t) ， 对应的函数为 FLTreeOnodeManager::mkfs 函数。 之后继续调用 Btree::mkfs &#x3D;&gt; Node::mkfs\nTODO:\ncollection_manager 相关执行逻辑:\n相关操作为 collection_manager-&gt;mkfs(t)\nTODO:\n\n\nprepare_meta(new_osd_fsid)\n\n\nprepare_meta(new_osd_fsid) 函数对应的是 SeaStore::prepare_meta 函数，其内部主要是写入一些元信息到对应的数据目录的文件中，包括向 fsid 文件中写入集群 id 信息；向 type 文件中写入后后端存储类型（比如 seastore ） ； 往 mkfs_done 文件中写入 yes 。\n\n\numount()\n\n\numount() 函数对应的是 SeaStore::umount 函数，其内部会通过 shard_stores.invoke_on_all 函数通知所有的 shard 执行 local_store.umount() 操作。\n9.4、crimson osd start 逻辑当 osd 通过 mkfs 初始化之后才会被正式的启动，这时候就会调用 OSD::start 函数启动。需要注意该函数内部限制当前的 shard 为 PRIMARY_CORE 。其中 store.start() 和 store.mount() 的执行逻辑之前在 osd mkfs 的逻辑中已经描述过了，这里不再赘述。部分实现比较详细或逻辑接近，因此放在一块一起解释。\nOSD::start 函数中关键逻辑为:\ncstore.start()1. pg_to_shard_mappings.start(...)2. osd_singleton_state.start_single(...)3. osd_states.start()4. shard_services.start(...)5. heartbeat.reset(...)store.mount()6. local_service.report_stats() // shard_services.invoke_on_all(...)7. store.report_stats()8. stats_timer.arm_periodic(...)9. open_meta_coll()10. pg_shard_manager.get_meta_coll().load_superblock()11. pg_shard_manager.set_superblock(superblock)12. pg_shard_manager.get_local_map(superblock.current_epoch)13. pg_shard_manager.update_map(std::move(map))14. local_service.local_state.osdmap_gate.got_map(...) // shard_services.invoke_on_all(...)15. pg_shard_manager.load_pgs(store)16. cluster_msgr-&gt;bind(pick_addresses(CEPH_PICK_ADDRESS_CLUSTER))    cluster_msgr-&gt;start(dispatchers)    public_msgr-&gt;bind(pick_addresses(CEPH_PICK_ADDRESS_PUBLIC))    public_msgr-&gt;start(dispatchers)17. monc-&gt;start()    mgrc-&gt;start()18. _add_me_to_crush()19. monc-&gt;renew_subs()20. heartbeat-&gt;start(...)21. start_asok_admin()22. log_client.set_fsid(monc-&gt;get_fsid())23. start_boot()\n\n\n1. pg_to_shard_mappings.start(…)\n\npg_to_shard_mappings.start(...) 的原始调用信息为 pg_to_shard_mappings.start(0, seastar::smp::count) 。由于 pg_to_shard_mappings 的定义为 seastar::sharded pg_to_shard_mappings ，因此这里的 start 函数其实是调用 seastar::sharded::start 函数来初始化了 PGShardMapping 对象。在 PGShardMapping 对象初始化的过程中会向其内部的成员变量 std::map core_to_num_pgs 中添加 seastar::smp::count 个元素。\n\n2. osd_singleton_state.start_single(…)\n\nosd_singleton_state.start_single(...) 的原始调用信息为 osd_singleton_state.start_single(whoami, std::ref(*cluster_msgr), std::ref(*public_msgr), std::ref(*monc), std::ref(*mgrc)) 。由于 osd_singleton_state 的定义为 seastar::sharded osd_singleton_state ，因此这里的 start_single 函数其实是调用了 seastar::sharded::start_single 函数来创建了一个 OSDSingletonState 对象。在 OSDSingletonState 对象初始化的过程中会创建一些 perf 和 recoverystate_perf 对象指针。\n\n3. osd_states.start()\n\n由于 osd_states 的定义为 seastar::sharded osd_states ，因此这里的 start 函数其实是调用 seastar::sharded::start 函数来初始化了 OSDState 对象。\n\n4. shard_services.start(…)\n\nshard_services.start(...) 的原始调用信息为 shard_services.start(std::ref(osd_singleton_state), std::ref(pg_to_shard_mappings), whoami, startup_time, osd_singleton_state.local().perf, osd_singleton_state.local().recoverystate_perf, std::ref(store), std::ref(osd_states)) 。由于 shard_services 的定义为 seastar::sharded shard_services ，因此这里的 start 函数其实是调用 seastar::sharded::start 函数来初始化了 ShardServices 对象。\n\n5. heartbeat.reset(…)\n\n重置 heartbeat 对象。\n\n6. local_service.report_stats()\n\n该函数的调用被封装在 shard_services.invoke_on_all 内部，意味着这会让每个 shard 执行 local_service.report_stats() 函数。但是只有在 crimson_osd_stat_interval 配置了非零的情况下才会执行该逻辑。 crimson_osd_stat_interval 参数默认为 0 。\n\n7. store.report_stats()\n\nstore.report_stats() 对应的函数为 SeaStore::report_stats 。\nSeaStore::report_stats 函数中关键逻辑为:\nclocal_store.get_device_stats(report_detail) // shard_stores.invoke_on_alllocal_store.get_io_stats(report_detail) // shard_stores.invoke_on_allINFO(...);\n\n\n8. stats_timer.arm_periodic(…)\n\nstats_timer.arm_periodic(...) 对应的原始调用为 stats_timer.arm_periodic(std::chrono::seconds(stats_seconds)) 。用于设置一个周期性的定时器，该定时器的运行是由 Seastar 框架的事件循环管理的，与函数调用的生命周期无关。\n\n9. open_meta_coll\n\nopen_meta_coll 对应的函数为 OSD::open_meta_coll 。需要注意该逻辑仅限 PRIMARY_CORE 对应的 shard 执行。\nSeaStore::report_stats 函数中关键逻辑为:\ncstore.get_sharded_store().open_collection(coll_t::meta())pg_shard_manager.init_meta_coll(ch, store.get_sharded_store())\n\n\n10. pg_shard_manager.get_meta_coll().load_superblock()\n\n对应的函数为 OSDMeta::load_superblock 。用于从 store 存储中读取 superblock 信息。\n\n11. pg_shard_manager.set_superblock(superblock)\n\n对应的函数为 PGShardManager::set_superblock 。\nPGShardManager::set_superblock 函数中关键逻辑为:\ncget_osd_singleton_state().set_singleton_superblock(superblock)local_service.local_state.update_shard_superblock(superblock) // shard_services.invoke_on_all\n\n\n12. pg_shard_manager.get_local_map(superblock.current_epoch)\n\n对应的函数为 OSDSingletonState::get_local_map 。\n\n13. pg_shard_manager.update_map(std::move(map))\n\n对应的函数为 PGShardManager::update_map 。\nPGShardManager::update_map 函数中关键逻辑为:\ncget_osd_singleton_state().update_map(...)local.local_state.update_map(...) // shard_services.invoke_on_all\n\n\n14. local_service.local_state.osdmap_gate.got_map(…)\n\n原始的调用为 local_service.local_state.osdmap_gate.got_map(osdmap-&gt;get_epoch()) ， 该函数的调用被封装在 shard_services.invoke_on_all 内部，意味着这会让每个 shard 执行 local_service.local_state.osdmap_gate.got_map(osdmap-&gt;get_epoch()) 函数。\n\n15. pg_shard_manager.load_pgs(store)\n\n对应的函数为 PGShardManager::load_pgs 。\nPGShardManager::load_pgs 函数中关键逻辑为:\ncstore.list_collections()// seastar::parallel_for_eachget_pg_to_shard_mapping().get_or_create_pg_mapping(pgid, shard_core)shard_services.load_pg(pgid)per_shard_state.pg_map.pg_loaded(pgid, std::move(pg))\n\n\n16. cluster_msgr 和 public_msgr\n\n对应的批量的原始调用为:\nccluster_msgr-&gt;bind(pick_addresses(CEPH_PICK_ADDRESS_CLUSTER))cluster_msgr-&gt;start(dispatchers)public_msgr-&gt;bind(pick_addresses(CEPH_PICK_ADDRESS_PUBLIC))public_msgr-&gt;start(dispatchers)\n\npick_addresses 函数执行的时候，其内部仅会选择 message v2 的地址，因此从这里可以看出在 crimson osd 中不支持 message v1 。\nbind 函数对应的是 SocketMessenger::bind 。 start 函数对应的是 SocketMessenger::start 。\nSocketMessenger::bind 函数中关键逻辑为:\nctry_bind(addrs, local_conf()-&gt;ms_bind_port_min, local_conf()-&gt;ms_bind_port_max)do_listen(entity_addrvec_t&#123;to_bind&#125;)ShardedServerSocket::create(dispatch_only_on_sid)listener-&gt;listen(listen_addr)    seastar::listen(s_addr, lo) // this-&gt;container().invoke_on_all\n\n从上面中可以看出会让每个 shard 都监听相同的端口。\nSocketMessenger::start 函数中关键逻辑为:\nclistener-&gt;accept([this](SocketRef _socket, entity_addr_t peer_addr) &#123;    assert(get_myaddr().is_msgr2());    SocketFRef socket = seastar::make_foreign(std::move(_socket));    // 对于 client 和 cluster 的消息，这里的 fix 是 false     // 对于 heart beat 的消息，这里的 fix 是 true    if (listener-&gt;is_fixed_shard_dispatching()) &#123;        return accept(std::move(socket), peer_addr);    &#125;    else &#123;        // 转发请求到对应的 shard 中        return seastar::smp::submit_to(sid, [this, peer_addr, socket = std::move(socket)]() mutable &#123;            return accept(std::move(socket), peer_addr);        &#125;);    &#125;&#125;);\n\n\n17. monc 和 mgrc 的 start\n\n对应的批量的原始调用为:\ncmonc-&gt;start()mgrc-&gt;start()\n\n其中 monc-&gt;start() 对应的函数为 crimson::mon::Client::start 。 mgrc-&gt;start() 对应的函数为 crimson::mgr::Client::start 。\ncrimson::mon::Client::start 函数中关键逻辑为:\ncauth_registry.refresh_config()load_keyring()monmap.build_initial(crimson::common::local_conf(), false)authenticate()timer.arm_periodic(interval)\n\ncrimson::mgr::Client::start 函数中关键逻辑为:\ncseastar::now()\n\n\n18. _add_me_to_crush()\n\n该函数对应的是 OSD::_add_me_to_crush 。在该函数中，如果 osd_crush_update_on_start 配置为 true ，则会在 osd 启动时尝试将自己的信息添加到 crush map 中。\nOSD::_add_me_to_crush 函数中关键逻辑为:\nclocal_conf().get_val&lt;bool&gt;(&quot;osd_crush_update_on_start&quot;)local_conf().get_val&lt;double&gt;(&quot;osd_crush_initial_weight&quot;)store.stat()get_weight()loc.init_on_startup()monc-&gt;run_command(std::move(cmd), &#123;&#125;)\n\n\n19. monc-&gt;renew_subs()\n\n对应的函数为 crimson::mon::Client::renew_subs 。 内部逻辑为向 monitor 发送 CEPH_MSG_MON_SUBSCRIBE 消息，用于订阅 osd_pg_creates ， mgrmap ， osdmap 的变更消息。\n\n20. heartbeat-&gt;start(…)\n\n原始的调用为 heartbeat-&gt;start(pick_addresses(CEPH_PICK_ADDRESS_PUBLIC), pick_addresses(CEPH_PICK_ADDRESS_CLUSTER)) , 对应的函数为 Heartbeat::start 。\n\n21. start_asok_admin()\n\n对应的函数为 OSD::start_asok_admin 。 用于创建本地的 socket 文件，并注册可执行的命令。\n\n22. log_client.set_fsid(monc-&gt;get_fsid())\n\n设置日志记录中的 fsid 信息。\n\n23. start_boot()\n\n对应的函数为 OSD::start_boot 。\nOSD::start_boot 函数中关键逻辑为:\ncpg_shard_manager.set_preboot()monc-&gt;get_version(&quot;osdmap&quot;)_preboot(oldest, newest)\n\n十、相关资料\nhttps://ceph.io/en/news/crimson/\nhttps://ceph.io/en/news/blog/2023/crimson-multi-core-scalability/\nhttps://ceph.io/en/news/blog/2025/crimson-T-release/\nhttps://docs.ceph.com/en/latest/dev/crimson/crimson/\nhttps://docs.ceph.com/en/latest/cephadm/install/#bootstrap-a-new-cluster\nhttps://www.51cto.com/article/749735.html\nhttps://zhuanlan.zhihu.com/p/667949613\nhttps://docs.redhat.com/zh-cn/documentation/red_hat_ceph_storage/7/html/administration_guide/crimson\nhttps://ceph.io/en/news/blog/2023/crimson-multi-core-scalability/\nhttps://www.icviews.cn/semiCommunity/postDetail/6586\n\n","tags":["Crimson","Seastore","异步编程"]},{"url":"/2025/09/19/lru/","content":"title:线性表+哈希表&gt;&gt;LRU算法\n\n\n线性表+哈希表&gt;&gt;LRU算法方法：哈希表 + 双向链表算法LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。\n双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。\n哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。\n这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)O(1)O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：\nint LRU::get(int key)&#123;&#125;\n\n对于 get 操作，首先判断 key 是否存在：\n如果 key 不存在，则返回 −1；\n如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。\n对于 put 操作，首先判断 key 是否存在：\nvoid LRU::put(int key,int value)&#123;&#125;\n\n如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；\n如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。\n上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)时间内完成。\n小贴士在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。\n复杂度分析时间复杂度：对于 put 和 get 都是 O(1)。\n空间复杂度：O(capacity)O(\\text{capacity})O(capacity)，因为哈希表和双向链表最多存储 capacity+1\\text{capacity} + 1capacity+1 个元素。\n#include &lt;iostream&gt;#include&lt;list&gt;#include&lt;unordered_map&gt;using namespace std;using std::cout;using std::endl;class LRU&#123;public:    LRU(int cap)    :_capacity(cap)    &#123;        cout &lt;&lt; &quot;LRU(int cap)&quot; &lt;&lt; endl;            &#125;    int get(int key);    void put(int key,int value);private:    struct cacheNode    &#123;        cacheNode(int key,int v)        :_key(key)        ,_value(v)        &#123;            cout &lt;&lt; &quot;cacheNode(int key,int v)&quot; &lt;&lt; endl;        &#125;        int _key;        int _value;    &#125;;    list&lt;cacheNode&gt; _nodes;//双向链表存，    int _capacity;//缓存的大小    unordered_map&lt;int,list&lt;cacheNode&gt;::iterator &gt; _cache;//无序map ，    //存放的是 key值，和链表的迭代器&#125;;int LRU::get(int key)&#123;    //TODO 判断key值是否在map中，如果存在，直接把他    //更新在链表的头，并且返回他的value,不存在则返回-1；        auto it = _cache.find(key);//unordered_map 的 find 函数返回值为                            // 该key值所对应的迭代器    if(it!=_cache.end())    &#123;        _nodes.splice(_nodes.begin(),_nodes,it-&gt;second);        //链表的splice 函数可以将 _nodes链表中的 it-&gt;second所指向的元素        //转移到_nodes.begin()的前面        return it-&gt;second-&gt;_value;    &#125;    else    &#123;        return -1;    &#125;&#125;void LRU::put(int key,int value)&#123;    //TODO 判断key 是否存在，如果存在那么，直接放在链表表头    //如果不存在则判断链表是不是满的，如果满了删除末尾元素    //然后在链表头插入，并且插入到map中        auto it = _cache.find(key);     if(it!=_cache.end())    &#123;        it-&gt;second-&gt;_value= value;        _nodes.splice(_nodes.begin(),_nodes,it-&gt;second);    &#125;    else    &#123;        if((int)_nodes.size()==_capacity)        &#123;            auto &amp;deleteNode = _nodes.back();            _cache.erase(deleteNode._key);//unordered_map 的 earse操作                                        // size_type earse(const key_type&amp;key);            _nodes.pop_back();        &#125;        _nodes.push_front(cacheNode(key,value));        _cache.insert(std::make_pair(key,_nodes.begin()));    &#125;&#125;void test0()&#123;        LRU lru(2);    lru.put(1,88);    cout &lt;&lt; &quot;get(1)&quot; &lt;&lt; lru.get(1) &lt;&lt; endl;    lru.put(3,99);    lru.put(4,77);    cout &lt;&lt; &quot;get(1)&quot; &lt;&lt; lru.get(1) &lt;&lt; endl;&#125;int main(void)&#123;    test0();    return 0;&#125;\n\n"},{"title":"Mymap Myset","url":"/2025/09/19/mymap_myset/","content":"红黑树模拟实现map和set\n\n\n一、map和set模板set用value标识元素(value就是key，类型为T)，并且每个value必须唯一 。\ntemplate &lt; class Key&gt;//set\n\n\n\n在map中，键值key通常用于排序和惟一地标识元素，而值value中存储与此键值key关联的内容。键值key和值value的类型可能不同，并且在map的内部，key与value通过成员类型value_type绑定在一起，为其取别名称为pair：\ntypedef pair&lt;const Key, T&gt; value_type;template &lt; class Key, class T&gt;//map\n\n 用红黑树同时封装出set和map时，set传给value的是一个value，map传给value的是一个pair，set和map传给红黑树的value决定了这棵树里面存的节点值类型。上层容器不同，底层红黑树的Key和T也不同。\n\n在上层容器set中，K和T都代表Key，底层红黑树节点当中存储K和T都是一样的；map中，K代表键值Key，T代表由Key和Value构成的键值对，底层红黑树中只能存储T。所以红黑树为了满足同时支持set和map，节点当中存储T\n这就要对红黑树进行改动。\n二、红黑树节点定义1.红黑树节点定义由类模板template&lt;class K,class V&gt;\n\n修改为\ntemplate&lt;class T&gt;\n\n那么节点定义修改为:\n//红黑树节点定义template&lt;class T&gt;struct RBTreeNode&#123;\tRBTreeNode&lt;T&gt;* _left;//节点的左孩子\tRBTreeNode&lt;T&gt;* _right;//节点的右孩子\tRBTreeNode&lt;T&gt;* _parent;//节点的父亲 \tT _data;//节点的值，_data里面存的是K就传K，存的是pair就传pair\tColour _col;//节点颜色 \tRBTreeNode(const T&amp; x)\t\t:_left(nullptr)\t\t, _right(nullptr)\t\t, _parent(nullptr)\t\t, _data(x)\t\t, _col(RED)\t&#123;&#125;&#125;;\n\n由于红黑树不知道上层传的是K还是pair，这是由上层传递的模板参数T决定的，上层是封装我的map和set\n2.仿函数（1）节点比较大小时存在的问题红黑树插入节点时，需要比较节点的大小，kv需要改成_data:\n//插入pair&lt;Node*, bool&gt; Insert(const T&amp; data)&#123;\tif (_root == nullptr)\t&#123;\t\t_root = new Node(data);\t\t_root-&gt;_col = BLACK;\t\treturn make_pair(_root, true);\t&#125;\t//1.先看树中，kv是否存在\tNode* parent = nullptr;\tNode* cur = _root;\twhile (cur)\t&#123;\t\tif (cur-&gt;_data &lt; data)\t\t&#123;\t\t\t//kv比当前节点值大，向右走\t\t\tparent = cur;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (cur-&gt;_data &gt; data)\t\t&#123;\t\t\t//kv比当前节点值小，向左走\t\t\tparent = cur;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse\t\t&#123;\t\t\t//kv和当前节点值相等，已存在，插入失败\t\t\treturn make_pair(cur, false);\t\t&#125;\t&#125;\t//2.走到这里，说明kv在树中不存在，需要插入kv，并且cur已经为空，parent已经是叶子节点了\tNode* newNode = new Node(kv);\tnewNode-&gt;_col = RED;\tif (parent-&gt;_data &lt; data)\t&#123;\t\t//kv比parent值大，插入到parent的右边\t\tparent-&gt;_right = newNode;\t\tnewNode-&gt;_parent = parent;\t&#125;\telse\t&#123;\t\t//kv比parent值小，插入到parent的左边\t\tparent-&gt;_left = newNode;\t\tnewNode-&gt;_parent = parent;\t&#125;\tcur = newNode;\t       //如果父亲存在，且父亲颜色为红就要处理\twhile (parent &amp;&amp; parent-&gt;_col == RED)\t&#123;\t\t//情况一和情况二、三的区别关键看叔叔\t\tNode* grandfather = parent-&gt;_parent;//当父亲是红色时，根据规则（2）根节点一定是黑色，祖父一定存在\t\tif (parent == grandfather-&gt;_left)//父亲是祖父的左子树\t\t&#123;\t\t\tNode* uncle = grandfather-&gt;_right;\t\t\t//情况一：叔叔存在且为红\t\t\tif (uncle-&gt;_col == RED)\t\t\t&#123;\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t//继续向上调整\t\t\t\tcur = grandfather;\t\t\t\tparent = cur-&gt;_parent;\t\t\t&#125;\t\t\telse//情况二+情况三：叔叔不存在或叔叔存在且为黑\t\t\t&#123;\t\t\t\t//情况二：单旋\t\t\t\tif (cur == parent-&gt;_left)\t\t\t\t&#123;\t\t\t\t\tRotateR(grandfather);\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\telse//情况三：双旋\t\t\t\t&#123;\t\t\t\t\tRotateL(parent);\t\t\t\t\tRotateR(grandfather);\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\tbreak;//插入结束\t\t\t&#125;\t\t&#125;\t\telse//父亲是祖父的右子树\t\t&#123;\t\t\tNode* uncle = grandfather-&gt;_left;\t\t\t//情况一：叔叔存在且为红\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == RED)\t\t\t&#123;\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t//继续往上调整\t\t\t\tcur = grandfather;\t\t\t\tparent = grandfather-&gt;_parent;\t\t\t&#125;\t\t\telse//情况二+情况三：叔叔不存在或叔叔存在且为黑\t\t\t&#123;\t\t\t\t//情况二：单旋\t\t\t\tif (cur == parent-&gt;_right)\t\t\t\t&#123;\t\t\t\t\tRotateL(grandfather);\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\telse//情况三：双旋\t\t\t\t&#123;\t\t\t\t\tRotateR(parent);\t\t\t\t\tRotateL(grandfather);\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\tbreak;//插入结束\t\t\t&#125;\t\t&#125;\t&#125;\t_root-&gt;_col = BLACK;\treturn make_pair(newNode, true);&#125;\n\n但是以上代码在插入新节和查找节点时，当和当前节点比较大小时，Key可以比较，但是pair比较不了，也就是set可以比较，但是map比较不了。这就需要写一个仿函数，如果是map就取_data里面的first也就是Key进行比较，通过泛型解决红黑树里面存的是什么。所以上层容器map需要向底层的红黑树提供仿函数来获取T里面的Key，这样无论上层容器是set还是map，都可以用统一的方式进行比较了。\n(2) 仿函数仿函数让一个类的使用看上去像个函数。仿函数是在类中实现了一个operator( )，是一个类的对象，这个类就有了类似函数的行为，所以这个类就是一个仿函数类，目的是为了让函数拥有类的性质。\n这个类的对象即仿函数，可以当作一般函数去用，只不过仿函数的功能是在一个类中的运算符operator()中实现的，使用的时候把函数作为参进行传递即可。\nset有set的仿函数，map有map的仿函数，尽管set的仿函数看起来没有什么作用，但是，必须要把它传给底层红黑树，这样红黑树就能根据仿函数分别获取set的key和map的first。\n①：set的仿函数\nnamespace delia&#123;\ttemplate&lt;class K&gt;\tclass set\t&#123;\t\t//仿函数，获取set的key\t\tstruct SetKeyOfT\t\t&#123;\t\t\tconst K&amp; operator()(const K&amp; key)\t\t\t&#123;\t\t\t\treturn key;\t\t\t&#125;\t\t&#125;;        public:\t\tbool insert(const K&amp; k)\t\t&#123;\t\t\t_t.Insert(k);\t\t\treturn true;\t\t&#125; \tprivate:\t\tRBTree&lt;K, K,SetKeyOfT&gt; _t;\t&#125;;&#125;\n\n②map的仿函数\nnamespace delia&#123;\ttemplate&lt;class K,class V&gt;\tclass map\t&#123;\t\t//仿函数，获取map的first\t\tstruct MapKeyOfT\t\t&#123;\t\t\tconst K&amp; operator()(const pair&lt;const K, V&gt;&amp; kv)\t\t\t&#123;\t\t\t\treturn kv.first;\t\t\t&#125;\t\t&#125;;     public:        //插入\t\tbool insert(const pair&lt;const K, V&gt;&amp; kv)\t\t&#123;\t\t\t_t.Insert(kv);\t\t\treturn true;\t\t&#125;\tprivate:\t\tRBTree&lt;K, pair&lt;const K, V&gt;, MapKeyOfT&gt; _t;\t&#125;;&#125;\n\n有了仿函数红黑树的类在实现时，就要在模板参数中增加KeyOfT仿函数。\n（3）修改红黑树定义template&lt;class K, class T, class KeyOfT&gt;class RBTree&#123;\ttypedef RBTreeNode&lt;T&gt; Node;\tprivate:\tNode* _root;&#125;;\n\n（4）修改红黑树插入//插入pair&lt;Node*, bool&gt; Insert(const pair&lt;K, V&gt;&amp; kv)&#123;\tif (_root == nullptr)\t&#123;\t\t_root = new Node(kv);\t\t_root-&gt;_col = BLACK;\t\treturn make_pair(_root, true);\t&#125;\tKeyOfT kot;\t//1.先看树中，kv是否存在\tNode* parent = nullptr;\tNode* cur = _root;\twhile (cur)\t&#123;\t\tif (kot(cur-&gt;_data) &lt; kot(data))\t\t&#123;\t\t\t//kv比当前节点值大，向右走\t\t\tparent = cur;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (kot(cur-&gt;_data) &gt; kot(data))\t\t&#123;\t\t\t//kv比当前节点值小，向左走\t\t\tparent = cur;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse\t\t&#123;\t\t\t//kv和当前节点值相等，已存在，插入失败\t\t\treturn make_pair(cur, false);\t\t&#125;\t&#125;\t//2.走到这里，说明kv在树中不存在，需要插入kv，并且cur已经为空，parent已经是叶子节点了\tNode* newNode = new Node(kv);\tnewNode-&gt;_col = RED;\tif (kot(parent-&gt;_data) &lt; kot(data))\t&#123;\t\t//kv比parent值大，插入到parent的右边\t\tparent-&gt;_right = newNode;\t\tnewNode-&gt;_parent = parent;\t&#125;\telse\t&#123;\t\t//kv比parent值小，插入到parent的左边\t\tparent-&gt;_left = newNode;\t\tnewNode-&gt;_parent = parent;\t&#125;\tcur = newNode;\t//如果父亲存在，且父亲颜色为红就要处理\twhile (parent &amp;&amp; parent-&gt;_col == RED)\t&#123;\t\t//情况一和情况二、三的区别关键看叔叔\t\tNode* grandfather = parent-&gt;_parent;//当父亲是红色时，根据规则（2）根节点一定是黑色，祖父一定存在\t\tif (parent == grandfather-&gt;_left)//父亲是祖父的左子树\t\t&#123;\t\t\tNode* uncle = grandfather-&gt;_right;\t\t\t//情况一：叔叔存在且为红\t\t\tif (uncle-&gt;_col == RED)\t\t\t&#123;\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t//继续向上调整\t\t\t\tcur = grandfather;\t\t\t\tparent = cur-&gt;_parent;\t\t\t&#125;\t\t\telse//情况二+情况三：叔叔不存在或叔叔存在且为黑\t\t\t&#123;\t\t\t\t//情况二：单旋\t\t\t\tif (cur == parent-&gt;_left)\t\t\t\t&#123;\t\t\t\t\tRotateR(grandfather);\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\telse//情况三：双旋\t\t\t\t&#123;\t\t\t\t\tRotateL(parent);\t\t\t\t\tRotateR(grandfather);\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\tbreak;//插入结束\t\t\t&#125;\t\t&#125;\t\telse//父亲是祖父的右子树\t\t&#123;\t\t\tNode* uncle = grandfather-&gt;_left;\t\t\t//情况一：叔叔存在且为红\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == RED)\t\t\t&#123;\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t//继续往上调整\t\t\t\tcur = grandfather;\t\t\t\tparent = grandfather-&gt;_parent;\t\t\t&#125;\t\t\telse//情况二+情况三：叔叔不存在或叔叔存在且为黑\t\t\t&#123;\t\t\t\t//情况二：单旋\t\t\t\tif (cur == parent-&gt;_right)\t\t\t\t&#123;\t\t\t\t\tRotateL(grandfather);\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\telse//情况三：双旋\t\t\t\t&#123;\t\t\t\t\tRotateR(parent);\t\t\t\t\tRotateL(grandfather);\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t&#125;\t\t\t\tbreak;//插入结束\t\t\t&#125;\t\t&#125;\t&#125;\t_root-&gt;_col = BLACK;\treturn make_pair(newNode, true);&#125;void RotateR(Node* parent)&#123;\tNode* subL = parent-&gt;_left;\tNode* subLR = nullptr;\tif (subL)\t&#123;\t\tsubLR = subL-&gt;_right;\t&#125;\t//1.左子树的右子树变我的左子树\tparent-&gt;_left = subLR;\tif (subLR)\t&#123;\t\tsubLR-&gt;_parent = parent;\t&#125;\t//左子树变父亲\tsubL-&gt;_right = parent;\tNode* parentParent = parent-&gt;_parent;\tparent-&gt;_parent = subL;\tif (parent == _root)//parent是根\t&#123;\t\t_root = subL;\t\t_root-&gt;_parent = nullptr;\t&#125;\telse//parent不是根，是子树\t&#123;\t\tif (parentParent-&gt;_left == parent)\t\t&#123;\t\t\t//parent是自己父亲的左子树,将subL作为parent父亲的左孩子\t\t\tparentParent-&gt;_left = subL;\t\t&#125;\t\telse\t\t&#123;\t\t\t//parent是自己父亲的右子树,将subL作为parent父亲的右孩子\t\t\tparentParent-&gt;_right = subL;\t\t&#125;\t\t//subL的父亲就是parent的父亲\t\tsubL-&gt;_parent = parentParent;\t&#125;&#125;void RotateL(Node* parent)&#123;\tNode* subR = parent-&gt;_right;\tNode* subRL = nullptr;\tif (subR)\t&#123;\t\tsubRL = subR-&gt;_left;\t&#125;\t//1.右子树的左子树变我的右子树\tparent-&gt;_right = subRL;\tif (subRL)\t&#123;\t\tsubRL-&gt;_parent = parent;\t&#125;\t//2.右子树变父亲\tsubR-&gt;_left = parent;\tNode* parentParent = parent-&gt;_parent;\tparent-&gt;_parent = subR;\tif (parent == _root)//parent是根\t&#123;\t\t_root = parent;\t\t_root-&gt;_parent = nullptr;\t&#125;\telse//parent不是根，是子树\t&#123;\t\tif (parentParent-&gt;_left == parent)\t\t&#123;\t\t\t//parent是自己父亲的左子树,将subR作为parent父亲的左孩子\t\t\tparentParent-&gt;_left = subR;\t\t&#125;\t\telse\t\t&#123;\t\t\t//parent是自己父亲的右子树,将subR作为parent父亲的右孩子\t\t\tparentParent-&gt;_right = subR;\t\t&#125;\t\t//subR的父亲就是parent的父亲\t\tsubR-&gt;_parent = parentParent;\t&#125;&#125;\n\n（5）修改红黑树查找//查找Node* Find(const K&amp; key)&#123;\tKeyOfT kot;\tNode* cur = _root;\twhile (cur)\t&#123;\t\tif (kot(cur-&gt;_data) &lt; key)\t\t&#123;\t\t\tcur = cur-&gt;_right;\t\t&#125;\t\telse if (kot(cur-&gt;_data) &gt; key)\t\t&#123;\t\t\tcur = cur-&gt;_left;\t\t&#125;\t\telse\t\t&#123;\t\t\treturn cur;\t\t&#125;\t&#125;\treturn nullptr;//空树，直接返回&#125;\n\n三、红黑树迭代器map和set的迭代器的实现其实本质上是红黑树迭代器的实现，迭代器的实现需要定义模板类型、模板类型引用、模板类型指针。 \n1.红黑树中迭代器重命名 在红黑树中重命名模板类型、模板类型引用、模板类型指针，定义为public，外部就能使用iterator了：\ntemplate&lt;class K, class T, class KeyOfT&gt;class RBTree&#123;\ttypedef RBTreeNode&lt;T&gt; Node; public:\ttypedef __TreeIterator&lt;T, T&amp;, T*&gt; iterator;//模板类型、模板类型引用、模板类型指针        //红黑树函数...    private:\tNode* _root;&#125;;\n\n2.正向迭代器定义红黑树的迭代器的本质是对节点指针进行封装，所以迭代器中只有封装红黑树节点指针这一个成员变量 。正向迭代器：\ntemplate&lt;class T,class Ref,class ptr&gt;struct __TreeIterator&#123;\ttypedef RBTreeNode&lt;T&gt; Node;\ttypedef __TreeIterator&lt;T, Ref, ptr&gt; Self;      \tNode* _node;//成员变量\t&#125;;\n\n3.迭代器构造用节点指针构造正向迭代器：\n//构造函数__TreeIterator(Node* node)\t:_node(node)&#123;&#125;\n\n4.正向迭代器重载*Ref对正向迭代器解引用，返回节点数据引用\n//* 解引用，返回节点数据Ref Operator*()&#123;\treturn _node-&gt;_data;&#125;\n\n5.正向迭代器重载-&gt;Ptr对正向迭代器使用-&gt;，返回节点数据指针：\n//-&gt; 返回节点数据地址Ptr Operator-&gt;()&#123;\treturn &amp;_node-&gt;_data;&#125;\n\n6.正向迭代器重载&#x3D;&#x3D;判断节点是否相同\n//判断两个迭代器是否相同bool operator==(const Self&amp; s)&#123;\treturn _node == s._node;//判断节点是否相同&#125;\n\n7.正向迭代器重载！&#x3D;判断节点是否不同\n//判断两个迭代器是否不同bool operator!=(const Self&amp; s)&#123;\treturn _node != s._node;//判断节点是否不同&#125;\n\n8.正向迭代器++①当节点的右子树不为空时，++就要走到右子树的最左节点\n ②当节点的右子树为空时，++就要走到节点的父亲\n\t//红黑树迭代器的++也就是红黑树的++\tSelf operator++()\t&#123;\t\t//1.右子树不为空\t\tif (_node-&gt;_right)\t\t&#123;\t\t\t//下一个访问的是右树的中序第一个节点（即右子树最左节点）。\t\t\tNode* left = _node-&gt;_right; \t\t\t//找最左节点\t\t\twhile (left-&gt;_left)\t\t\t&#123;\t\t\t\tleft = left-&gt;_left;\t\t\t&#125;\t\t\t_node = left;\t\t&#125;\t\telse//2.右子树为空，下一个访问的就是当前节点的父亲\t\t&#123;\t\t\tNode* cur = _node;\t\t\tNode* parent = cur-&gt;_parent;\t\t\twhile (parent &amp;&amp; cur == parent-&gt;_right)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_parent;\t\t\t\tparent = parent-&gt;_parent;\t\t\t&#125;\t\t\t_node = parent;\t\t&#125; \t\treturn *this;\t&#125;&#125;;\n\n9.正向迭代器– ①当节点的左子树不为空时，++就要走到左子树的最右节点\n ②当节点的左子树为空时，++就要走到节点的父亲\n//红黑树迭代器的--也就是红黑树的--Self operator--()&#123;\t//1.左子树不为空\tif (_node-&gt;_left)\t&#123;\t\t//下一个访问的是左树的中序左后节点（即做子树最右节点）。\t\tNode* right = _node-&gt;_left;\t\t//找最右节点\t\twhile (right-&gt;_right)\t\t&#123;\t\t\tright = right-&gt;_right;\t\t&#125;\t\t_node = right;\t&#125;\telse//2.左子树为空，下一个访问的就是当前节点的父亲\t&#123;\t\tNode* cur = _node;\t\tNode* parent = cur-&gt;_parent;\t\twhile (parent &amp;&amp; cur == parent-&gt;_left)\t\t&#123;\t\t\tcur = cur-&gt;_parent;\t\t\tparent = parent-&gt;_parent;\t\t&#125;\t\t_node = parent;\t&#125;\treturn *this;&#125;\n\n10.红黑树中实现迭代器实现begin( )找最左节点，end( )最后一个节点的下一个位置\ntemplate&lt;class K, class T, class KeyOfT&gt;class RBTree&#123;\ttypedef RBTreeNode&lt;T&gt; Node; public:\ttypedef __TreeIterator&lt;T, T&amp;, T*&gt; iterator;//模板类型、模板类型引用、模板类型指针        //找最左节点\titerator begin()\t&#123;\t\tNode* left = _root;\t\twhile (left &amp;&amp; left-&gt;_left)\t\t&#123;\t\t\tleft = left-&gt;_left;\t\t&#125; \t\treturn iterator(left)//返回最左节点的正向迭代器\t&#125; \t//结束\titerator end()\t&#123;\t\treturn iterator(nullptr);\t&#125;    private:\tNode* _root;&#125;;\n\n四、set模拟实现调用红黑树对应接口实现set，插入和查找函数返回值当中的节点指针改为迭代器:\n#pragma once#include &quot;RBTree.h&quot;namespace delia&#123;\ttemplate&lt;class K&gt;\tclass set\t&#123;\t\t//仿函数，获取set的key\t\tstruct SetKeyOfT\t\t&#123;\t\t\tconst K&amp; operator()(const K&amp; key)\t\t\t&#123;\t\t\t\treturn key;\t\t\t&#125;\t\t&#125;;\tpublic:\t\ttypedef typename RBTree&lt;K, K, SetKeyOfT&gt;::iterator iterator;\t\t\t\t//迭代器开始\t\titerator begin()\t\t&#123;\t\t\treturn _t.begin();\t\t&#125; \t\t//迭代器结束\t\titerator end()\t\t&#123;\t\t\treturn _t.end();\t\t&#125; \t\t//插入函数\t\tpair&lt;iterator,bool&gt; insert(const K&amp; key)\t\t&#123;\t\t\t\t\t\treturn _t.Insert(key);\t\t&#125; \t\t//查找\t\titerator find(const K&amp; key)\t\t&#123;\t\t\treturn _t.find(key);\t\t&#125;\tprivate:\t\tRBTree&lt;K, K, SetKeyOfT&gt; _t;\t&#125;;&#125;\n\n五、map模拟实现调用红黑树对应接口实现map，插入和查找函数返回值当中的节点指针改为迭代器，增加operator[ ]的重载:\n#pragma once#include &quot;RBTree.h&quot;namespace delia&#123;\ttemplate&lt;class K, class V&gt;\tclass map\t&#123;\t\t//仿函数，获取map的first\t\tstruct MapKeyOfT\t\t&#123;\t\t\tconst K&amp; operator()(const pair&lt;const K, V&gt;&amp; kv)\t\t\t&#123;\t\t\t\treturn kv.first;\t\t\t&#125;\t\t&#125;;\tpublic:\t\ttypedef typename RBTree&lt;K, K, MapKeyOfT&gt;::iterator iterator; \t\t//迭代器开始\t\titerator begin()\t\t&#123;\t\t\treturn _t.begin();\t\t&#125; \t\t//迭代器结束\t\titerator end()\t\t&#123;\t\t\treturn _t.end();\t\t&#125; \t\t//插入\t\tpair&lt;iterator, bool&gt; insert(const pair&lt;const K, V&gt;&amp; kv)\t\t&#123;\t\t\treturn _t.Insert(kv);\t\t&#125; \t\t//重载operator[]\t\tV&amp; operator[](const K&amp; key)\t\t&#123;\t\t\tpair&lt;iterator, bool&gt; ret = insert(make_pair(key, V()));\t\t\titerator it = ret.first;\t\t\treturn it-&gt;second;\t\t&#125; \t\t//查找\t\titerator find(const K&amp; key)\t\t&#123;\t\t\treturn _t.find(key);\t\t&#125; \tprivate:\t\tRBTree&lt;K, pair&lt;const K, V&gt;, MapKeyOfT&gt; _t;\t&#125;;&#125;\n\n六、红黑树完整代码段#pragma once#include&lt;iostream&gt;using namespace std;  //节点颜色enum Colour&#123;\tRED,\tBLACK,&#125;; //红黑树节点定义template&lt;class T&gt;struct RBTreeNode&#123;\tRBTreeNode&lt;T&gt;* _left;//节点的左孩子\tRBTreeNode&lt;T&gt;* _right;//节点的右孩子\tRBTreeNode&lt;T&gt;* _parent;//节点的父亲 \tT _data;//节点的值\tColour _col;//节点颜色 \tRBTreeNode(const T&amp; x)\t\t:_left(nullptr)\t\t, _right(nullptr)\t\t, _parent(nullptr)\t\t, _data(x)\t\t, _col(RED)\t&#123;&#125;&#125;;  template&lt;class T,class Ref,class ptr&gt;struct __TreeIterator&#123;\ttypedef RBTreeNode&lt;T&gt; Node;\ttypedef __TreeIterator&lt;T, Ref, ptr&gt; Self; \tNode* _node; \t//构造函数\t__TreeIterator(Node* node)\t\t:_node(node)\t&#123;&#125;\t\t//* 解引用，返回节点数据\tRef operator*()\t&#123;\t\treturn _node-&gt;_data;\t&#125; \t//-&gt; 返回节点数据地址\t//Ptr operator-&gt;()\t//&#123;\t//\treturn &amp;_node-&gt;_data;\t//&#125; \t//判断两个迭代器是否相同\tbool operator==(const Self&amp; s)\t&#123;\t\treturn _node == s._node;\t&#125; \t//判断两个迭代器是否不同\tbool operator!=(const Self&amp; s)\t&#123;\t\treturn _node != s._node;\t&#125; \t//红黑树迭代器的++也就是红黑树的++\tSelf operator++()\t&#123;\t\t//1.右子树不为空\t\tif (_node-&gt;_right)\t\t&#123;\t\t\t//下一个访问的是右树的中序第一个节点（即右子树最左节点）。\t\t\tNode* left = _node-&gt;_right; \t\t\t//找最左节点\t\t\twhile (left-&gt;_left)\t\t\t&#123;\t\t\t\tleft = left-&gt;_left;\t\t\t&#125;\t\t\t_node = left;\t\t&#125;\t\telse//2.右子树为空，下一个访问的就是当前节点的父亲\t\t&#123;\t\t\tNode* cur = _node;\t\t\tNode* parent = cur-&gt;_parent;\t\t\twhile (parent &amp;&amp; cur == parent-&gt;_right)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_parent;\t\t\t\tparent = parent-&gt;_parent;\t\t\t&#125;\t\t\t_node = parent;\t\t&#125; \t\treturn *this;\t&#125; \t//红黑树迭代器的--也就是红黑树的--\tSelf operator--()\t&#123;\t\t//1.左子树不为空\t\tif (_node-&gt;_left)\t\t&#123;\t\t\t//下一个访问的是左树的中序左后节点（即做子树最右节点）。\t\t\tNode* right = _node-&gt;_left; \t\t\t//找最右节点\t\t\twhile (right-&gt;_right)\t\t\t&#123;\t\t\t\tright = right-&gt;_right;\t\t\t&#125;\t\t\t_node = right;\t\t&#125;\t\telse//2.左子树为空，下一个访问的就是当前节点的父亲\t\t&#123;\t\t\tNode* cur = _node;\t\t\tNode* parent = cur-&gt;_parent;\t\t\twhile (parent &amp;&amp; cur == parent-&gt;_left)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_parent;\t\t\t\tparent = parent-&gt;_parent;\t\t\t&#125;\t\t\t_node = parent;\t\t&#125; \t\treturn *this;\t&#125;  &#125;; //插入节点颜色是红色好，还是黑色好，红色//因为插入红色节点，可能破坏规则3，影响不大//插入黑色节点，一定破坏规则4 ，并且影响其他路径，影响很大 template&lt;class K, class T, class KeyOfT&gt;class RBTree&#123;\ttypedef RBTreeNode&lt;T&gt; Node;public:\ttypedef __TreeIterator&lt;T, T&amp;, T*&gt; iterator;//模板类型、模板类型引用、模板类型指针 \t//构造函数\tRBTree()\t\t:_root(nullpte)\t&#123;&#125; \t//析构\t~RBTree()\t&#123;\t\t_Destroy(_root);\t\t_root = nullptr;\t&#125; \tvoid _Destroy(Node* root)\t&#123;\t\tif (root == nullptr)\t\t&#123;\t\t\treturn;\t\t&#125;\t\t_Destroy(root-&gt;_left);\t\t_Destroy(root-&gt;_right);\t\tdelete root;\t&#125; \t//找最左节点\titerator begin()\t&#123;\t\tNode* left = _root;\t\twhile (left &amp;&amp; left-&gt;_left)\t\t&#123;\t\t\tleft = left-&gt;_left;\t\t&#125; \t\treturn iterator(left);//返回最左节点的正向迭代器\t&#125; \t//结束\titerator end()\t&#123;\t\treturn iterator(nullptr);\t&#125; \t//构造函数\tRBTree()\t\t:_root(nullptr)\t&#123;&#125; \tvoid Destroy(Node* root)\t&#123;\t\tif (root == nullptr)\t\t&#123;\t\t\treturn;\t\t&#125; \t\tDestroy(root-&gt;_left);\t\tDestroy(root-&gt;_right);\t&#125;\t~RBTree()\t&#123;\t\tDestroy(_root);\t\t_root = nullptr;\t&#125; \t//插入\tpair&lt;Node*, bool&gt; Insert(const T&amp; data)\t&#123;\t\tif (_root == nullptr)\t\t&#123;\t\t\t_root = new Node(data);\t\t\t_root-&gt;_col = BLACK;\t\t\treturn make_pair(_root, true);\t\t&#125; \t\tKeyOfT kot; \t\t//1.先看树中，kv是否存在\t\tNode* parent = nullptr;\t\tNode* cur = _root;\t\twhile (cur)\t\t&#123;\t\t\tif (kot(cur-&gt;_data) &lt; kot(data))\t\t\t&#123;\t\t\t\t//kv比当前节点值大，向右走\t\t\t\tparent = cur;\t\t\t\tcur = cur-&gt;_right;\t\t\t&#125;\t\t\telse if (kot(cur-&gt;_data) &gt; kot(data))\t\t\t&#123;\t\t\t\t//kv比当前节点值小，向左走\t\t\t\tparent = cur;\t\t\t\tcur = cur-&gt;_left;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//kv和当前节点值相等，已存在，插入失败\t\t\t\treturn make_pair(cur, false);\t\t\t&#125;\t\t&#125; \t\t//2.走到这里，说明kv在树中不存在，需要插入kv，并且cur已经为空，parent已经是叶子节点了\t\tNode* newNode = new Node(data);\t\tnewNode-&gt;_col = RED;\t\tif (kot(parent-&gt;_data) &lt; kot(data))\t\t&#123;\t\t\t//kv比parent值大，插入到parent的右边\t\t\tparent-&gt;_right = newNode;\t\t\tnewNode-&gt;_parent = parent;\t\t&#125;\t\telse\t\t&#123;\t\t\t//kv比parent值小，插入到parent的左边\t\t\tparent-&gt;_left = newNode;\t\t\tnewNode-&gt;_parent = parent;\t\t&#125;\t\tcur = newNode; \t\t//如果父亲存在，且父亲颜色为红就要处理\t\twhile (parent &amp;&amp; parent-&gt;_col == RED)\t\t&#123;\t\t\t//情况一和情况二、三的区别关键看叔叔\t\t\tNode* grandfather = parent-&gt;_parent;//当父亲是红色时，根据规则（2）根节点一定是黑色，祖父一定存在\t\t\tif (parent == grandfather-&gt;_left)//父亲是祖父的左子树\t\t\t&#123;\t\t\t\tNode* uncle = grandfather-&gt;_right;\t\t\t\t//情况一：叔叔存在且为红\t\t\t\tif (uncle-&gt;_col == RED)\t\t\t\t&#123;\t\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED; \t\t\t\t\t//继续向上调整\t\t\t\t\tcur = grandfather;\t\t\t\t\tparent = cur-&gt;_parent;\t\t\t\t&#125;\t\t\t\telse//情况二+情况三：叔叔不存在或叔叔存在且为黑\t\t\t\t&#123;\t\t\t\t\t//情况二：单旋\t\t\t\t\tif (cur == parent-&gt;_left)\t\t\t\t\t&#123;\t\t\t\t\t\tRotateR(grandfather);\t\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t\t&#125;\t\t\t\t\telse//情况三：双旋\t\t\t\t\t&#123;\t\t\t\t\t\tRotateL(parent);\t\t\t\t\t\tRotateR(grandfather);\t\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t\t&#125;\t\t\t\t\tbreak;//插入结束\t\t\t\t&#125;\t\t\t&#125;\t\t\telse//父亲是祖父的右子树\t\t\t&#123;\t\t\t\tNode* uncle = grandfather-&gt;_left;\t\t\t\t//情况一：叔叔存在且为红\t\t\t\tif (uncle &amp;&amp; uncle-&gt;_col == RED)\t\t\t\t&#123;\t\t\t\t\tparent-&gt;_col = uncle-&gt;_col = BLACK;\t\t\t\t\tgrandfather-&gt;_col = RED; \t\t\t\t\t//继续往上调整\t\t\t\t\tcur = grandfather;\t\t\t\t\tparent = grandfather-&gt;_parent;\t\t\t\t&#125;\t\t\t\telse//情况二+情况三：叔叔不存在或叔叔存在且为黑\t\t\t\t&#123;\t\t\t\t\t//情况二：单旋\t\t\t\t\tif (cur == parent-&gt;_right)\t\t\t\t\t&#123;\t\t\t\t\t\tRotateL(grandfather);\t\t\t\t\t\tparent-&gt;_col = BLACK;\t\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t\t&#125;\t\t\t\t\telse//情况三：双旋\t\t\t\t\t&#123;\t\t\t\t\t\tRotateR(parent);\t\t\t\t\t\tRotateL(grandfather);\t\t\t\t\t\tcur-&gt;_col = BLACK;\t\t\t\t\t\tgrandfather-&gt;_col = RED;\t\t\t\t\t&#125;\t\t\t\t\tbreak;//插入结束\t\t\t\t&#125;\t\t\t&#125; \t\t&#125;\t\t_root-&gt;_col = BLACK; \t\treturn make_pair(newNode, true);\t&#125; \tvoid RotateR(Node* parent)\t&#123;\t\tNode* subL = parent-&gt;_left;\t\tNode* subLR = nullptr; \t\tif (subL)\t\t&#123;\t\t\tsubLR = subL-&gt;_right;\t\t&#125;\t\t//1.左子树的右子树变我的左子树\t\tparent-&gt;_left = subLR; \t\tif (subLR)\t\t&#123;\t\t\tsubLR-&gt;_parent = parent;\t\t&#125; \t\t//左子树变父亲\t\tsubL-&gt;_right = parent;\t\tNode* parentParent = parent-&gt;_parent;\t\tparent-&gt;_parent = subL;  \t\tif (parent == _root)//parent是根\t\t&#123;\t\t\t_root = subL;\t\t\t_root-&gt;_parent = nullptr;\t\t&#125;\t\telse//parent不是根，是子树\t\t&#123;\t\t\tif (parentParent-&gt;_left == parent)\t\t\t&#123;\t\t\t\t//parent是自己父亲的左子树,将subL作为parent父亲的左孩子\t\t\t\tparentParent-&gt;_left = subL;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//parent是自己父亲的右子树,将subL作为parent父亲的右孩子\t\t\t\tparentParent-&gt;_right = subL;\t\t\t&#125; \t\t\t//subL的父亲就是parent的父亲\t\t\tsubL-&gt;_parent = parentParent;\t\t&#125;\t&#125; \tvoid RotateL(Node* parent)\t&#123;\t\tNode* subR = parent-&gt;_right;\t\tNode* subRL = nullptr; \t\tif (subR)\t\t&#123;\t\t\tsubRL = subR-&gt;_left;\t\t&#125; \t\t//1.右子树的左子树变我的右子树\t\tparent-&gt;_right = subRL; \t\tif (subRL)\t\t&#123;\t\t\tsubRL-&gt;_parent = parent;\t\t&#125; \t\t//2.右子树变父亲\t\tsubR-&gt;_left = parent;\t\tNode* parentParent = parent-&gt;_parent;\t\tparent-&gt;_parent = subR; \t\tif (parent == _root)//parent是根\t\t&#123;\t\t\t_root = parent;\t\t\t_root-&gt;_parent = nullptr;\t\t&#125;\t\telse//parent不是根，是子树\t\t&#123;\t\t\tif (parentParent-&gt;_left == parent)\t\t\t&#123;\t\t\t\t//parent是自己父亲的左子树,将subR作为parent父亲的左孩子\t\t\t\tparentParent-&gt;_left = subR;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\t//parent是自己父亲的右子树,将subR作为parent父亲的右孩子\t\t\t\tparentParent-&gt;_right = subR;\t\t\t&#125; \t\t\t//subR的父亲就是parent的父亲\t\t\tsubR-&gt;_parent = parentParent;\t\t&#125;\t&#125; \t//查找\tNode* Find(const K&amp; key)\t&#123;\t\tKeyOfT kot;\t\tNode* cur = _root;\t\twhile (cur)\t\t&#123;\t\t\tif (kot(cur-&gt;_data) &lt; key)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_right;\t\t\t&#125;\t\t\telse if (kot(cur-&gt;_data) &gt; key)\t\t\t&#123;\t\t\t\tcur = cur-&gt;_left;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\treturn cur;\t\t\t&#125;\t\t&#125;\t\treturn nullptr;//空树，直接返回\t&#125; \tbool _CheckBalance(Node* root, int blackNum, int count)\t&#123;\t\tif (root == nullptr)\t\t&#123;\t\t\tif (count != blackNum)\t\t\t&#123;\t\t\t\tcout &lt;&lt; &quot;黑色节点数量不相等&quot; &lt;&lt; endl;\t\t\t\treturn false;\t\t\t&#125;\t\t\treturn true;\t\t&#125; \t\tif (root-&gt;_col == RED &amp;&amp; root-&gt;_parent-&gt;_col == RED)\t\t&#123;\t\t\tcout &lt;&lt; &quot;存在连续红色节点&quot; &lt;&lt; endl;\t\t\treturn false;\t\t&#125; \t\tif (root-&gt;_col == BLACK)\t\t&#123;\t\t\tcount++;\t\t&#125; \t\treturn _CheckBalance(root-&gt;_left, blackNum, count)\t\t\t&amp;&amp; _CheckBalance(root-&gt;_right, blackNum, count);\t&#125; \t//检查是否平衡\tbool CheckBalance()\t&#123;\t\tif (_root == nullptr)\t\t&#123;\t\t\treturn true;\t\t&#125; \t\tif (_root-&gt;_col == RED)\t\t&#123;\t\t\tcout &lt;&lt; &quot;根节点为红色&quot; &lt;&lt; endl;\t\t\treturn false;\t\t&#125; \t\t//找最左路径做黑色节点数量参考值\t\tint blackNum = 0;\t\tNode* left = _root;\t\twhile (left)\t\t&#123;\t\t\tif (left-&gt;_col == BLACK)\t\t\t&#123;\t\t\t\tblackNum++;\t\t\t&#125;\t\t\tleft = left-&gt;_left;\t\t&#125; \t\tint count = 0;\t\treturn _CheckBalance(_root, blackNum, count);\t&#125;  \t//遍历\tvoid _InOrder(Node* root)\t&#123;\t\tif (root == nullptr)\t\t&#123;\t\t\treturn;\t\t&#125; \t\t_InOrder(root-&gt;_left);\t\tcout &lt;&lt; root-&gt;_kv.first &lt;&lt; &quot;:&quot; &lt;&lt; root-&gt;_kv.second &lt;&lt; endl;\t\t_InOrder(root-&gt;_right);\t&#125; \tvoid InOrder()\t&#123;\t\t_InOrder(_root);\t\tcout &lt;&lt; endl;\t&#125;private:\tNode* _root;&#125;;\n\n七、验证代码#pragma once#include &quot;RBTree.h&quot;#include &lt;vector&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &quot;Map.h&quot;#include &quot;Set.h&quot; int main()&#123;\tdelia::map&lt;int, int&gt; m;\tm.insert(make_pair(1, 1));\tm.insert(make_pair(3, 3));\tm.insert(make_pair(0, 0));\tm.insert(make_pair(9, 9));  \tdelia::set&lt;int&gt; s;\ts.insert(1);\ts.insert(5);\ts.insert(2);\ts.insert(1);\ts.insert(13);\ts.insert(0);\ts.insert(15);\ts.insert(18);  \tdelia::set&lt;int&gt;::iterator sit = s.begin();\twhile (sit != s.end())\t&#123;\t\tcout &lt;&lt; *sit &lt;&lt; &quot; &quot;;\t\t++sit;\t&#125;\tcout &lt;&lt; endl;  \treturn 0;&#125;\n\n"},{"title":"约瑟夫环问题","url":"/2025/09/19/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/","content":"约瑟夫环问题的三种解决方法\n什么是约瑟夫环问题：约瑟夫环问题在不同平台被”优化”描述的不一样，例如在牛客剑指offer叫孩子们的游戏，还有叫杀人游戏，点名……最直接的感觉还是力扣上剑指offer62的描述：圆圈中最后剩下的数字问题描述：0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n列表循环模拟：这个问题最本质其实就是循环链表的问题，围成一个圈之后，就没有结尾这就是一个典型的循环链表嘛！一个一个顺序报数，那不就是链表的遍历枚举嘛！数到对应数字的出列，这不就是循环链表的删除嘛！\n并且这里还有非常方便的地方：\n循环链表的向下枚举不需要考虑头尾问题，直接node&#x3D;node.next向下循环聊表的删除也不需要考虑头尾问题，直接node.next&#x3D;node.next.next删除当然也有一些需要注意的地方\n形成环形链表很简单，只需要将普通链表的最后一个节点的next指向第一个节点即可\n循环链表中只有一个节点的时候停止返回，即node.next&#x3D;node的时候\n删除，需要找到待删除的前面节点，所以我们删除计数的时候要少即一位，利用前面的那个节点直接删除后面节点即可\n这样，思路明确，直接开撸代码：\nclass Solution &#123;    class node//链表节点    &#123;        int val;        public node(int value) &#123;            this.val=value;        &#125;        node next;    &#125;    public int lastRemaining(int n, int m) &#123;        if(m==1)return n-1;//一次一个直接返回最后一个即可        node head=new node(0);        node team=head;//创建一个链表        for(int i=1;i&lt;n;i++)        &#123;            team.next=new node(i);            team=team.next;        &#125;        team.next=head;//使形成环        int index=0;//从0开始计数        while (head.next!=head) &#123;//当剩余节点不止一个的时候            //如果index=m-2 那就说明下个节点(m-1)该删除了            if(index==m-2)            &#123;                head.next=head.next.next;                index=0;            &#125;            else &#123;                index++;            &#125;            head=head.next;        &#125;        return head.val;    &#125;&#125;\n当然，这种算法太复杂了，大部分的OJ你提交上去是无法AC的，因为超时太严重了，具体的我们可以下面分析。\n有序集合模拟上面使用链表直接模拟游戏过程会造成非常严重非常严重的超时，n个数字，数到第m个出列。因为m如果非常大远远大于m，那么将进行很多次转圈圈。所以我们可以利用求余的方法判断等价最低的枚举次数，然后将其删除即可，在这里你可以继续使用自建链表去模拟，上面的while循环以及上面只需添加一个记录长度的每次求余算圈数即可：\nint len=n;while (head.next!=head) &#123;  if(index==(m-2)%len)  &#123;    head.next=head.next.next;    index=0;    len--;  &#125;  else &#123;    index++;  &#125;  head=head.next;&#125;\n但我们很多时候不会手动去写一个链表模拟，我们会借助ArrayList和LinkedList去模拟，如果使用LinkedList其底层也是链表，使用ArrayList的话其底层数据结构是数组。不过在使用List其代码方法一致。\nList可以直接知道长度，也可删除元素，使用List的难点是一个顺序表怎们模拟成循环链表？\n咱们仔细思考：假设当前长度为n，数到第m个(通过上面分析可以求余让这个有效的m不大于n)删除，在index位置删除。那么删除后剩下的就是n-1长度，index位置就是表示第一个计数的位置，我们可以通过求余得知走下一个删除需要多少步，那么下个位置怎么确定呢？你可以分类讨论看看走的次数是否越界，但这里有更巧妙的方法，可以直接求的下一次具体的位置，公式就是为：\nindex=(index+m-1)%(list.size());\n因为index是从1计数，如果是循环的再往前m-1个就是真正的位置，但是这里可以先假设先将这个有序集合的长度扩大若干倍，然后从index计数开始找到假设不循环的位置index2，最后我们将这个位置index2%(集合长度)即为真正的长度。使用这个公式一举几得，既能把上面m过大循环过多的情况解决，又能找到真实的位置，就是将这个环先假设成线性的然后再去找到真的位置，如果不理解的话可以再看看这个图：这种情况的话大部分的OJ是可以勉强过关的，面试官的层面也大概率差不多的，具体代码为：\nclass Solution &#123;    public int lastRemaining(int n, int m) &#123;        if(m==1)            return n-1;        List&lt;Integer&gt;list=new ArrayList&lt;&gt;();        for(int i=0;i&lt;n;i++)        &#123;            list.add(i);        &#125;        int index=0;        while (list.size()&gt;1)        &#123;            index=(index+m-1)%(list.size());            list.remove(index);        &#125;        return list.get(0);    &#125;&#125;\n递归公式解决我们回顾上面的优化过程，上面用求余可以解决m比n大很多很多的情况(即理论上需要转很多很多圈的情况)。但是还可能存在n本身就很大的情况，无论是顺序表ArrayList还是链表LinkedList去频繁查询、删除都是很低效的。\n所以聪明的人就开始从数据找一些规律或者关系。\n先抛出公式：\nf(n,m)=(f(n-1,m)+m)%nf(n,m)指n个人，报第m个编号出列最终编号\n下面要认真看一下我的分析过程：\n我们举个例子，有0 1 2 3 4 5 6 7 8 9十个数字，假设m为3,最后结果可以先记成f(10,3)，即使我们不知道它是多少。\n当进行第一次时候，找到元素2 删除，此时还剩9个元素，但起始位置已经变成元素3。等价成3 4 5 6 7 8 9 0 1这9个数字重写开始找。\n此时这个序列最终剩下的一个值即为f(10,3)，这个序列的值和f(9,3)不同，但是都是9个数且m等于3，所以其删除位置是相同的，即算法大体流程是一致的，只是各位置上的数字不一样。所以我们需要做的事情是找找这个序列上和f(9,3)值上有没有什么联系。\n寻找过程中别忘记两点，首先可通过**%符号**对数字有效扩充，即我们可以将3 4 5 6 7 8 9 0 1这个序列看成(3,4,5,6,7,8,9,10,11)%10.这里的10即为此时的n数值。\n另外数值如果是连续的，那么最终一个结果的话是可以找到联系的(差值为一个定制)。所以我们可以就找到f(10,3)和f(9,3)值之间结果的关系，可以看下图：所以f(10,3)的结果就可以转化为f(9,3)的表达,后面也是同理：\nf(10,3)=(f(9,3)+3)%10f(9,3)=(f(8,3)+3)%9……f(2,3)=(f(1,3)+3)%2f(1,3)=0\n这样，我们就不用模拟操作，可以直接从数值的关系找到递推的关系，可以轻轻松松的写下代码：\nclass Solution &#123;    int index=0;    public int lastRemaining(int n, int m) &#123;         if(n==1)            return 0;              return (lastRemaining(n-1,m)+m)%n;    &#125;&#125;\n但是递归效率因为有个来回的规程，效率相比直接迭代差一些，也可从前往后迭代：\nclass Solution &#123;    public int lastRemaining(int n, int m) &#123;        int value=0;            for(int i=1;i&lt;=n;i++)            &#123;                value=(value+m)%i;            &#125;            return  value;    &#125;&#125;\n结语我想，通过本篇文章你应该掌握和理解了约瑟夫环问题，这种裸的约瑟夫环问题出现的概率很大，考察很频繁，链表模拟是根本思想，有序集合模拟链表是提升，而公式递推才是最有学习价值的地方，如果你刚开始接触不理解可以多看几遍。如果能用公式递推给面试官说两句，讲讲原理，那一定会让面试官眼前一亮的\n"}]