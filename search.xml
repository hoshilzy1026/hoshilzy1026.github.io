<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2023/06/24/#%20%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6%20session/</url>
    <content><![CDATA[<h1 id="身份验证机制-session"><a href="#身份验证机制-session" class="headerlink" title="# 身份验证机制 session"></a># 身份验证机制 session</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/25/B%E6%A0%91%20b+%E6%A0%91/</url>
    <content><![CDATA[<h1 id="B树-b-树"><a href="#B树-b-树" class="headerlink" title="B树 b+树"></a>B树 b+树</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/07/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>C++智能指针的底层实现原理</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/18/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><span id="more"></span>

<h2 id="需求：高性能网络服务器"><a href="#需求：高性能网络服务器" class="headerlink" title="需求：高性能网络服务器"></a>需求：高性能网络服务器</h2><p>设计一个高性能的网络服务器，提供多个客户端同时连接，并处理客户端的处理请求。</p>
<h2 id="1-第一印象"><a href="#1-第一印象" class="headerlink" title="1.第一印象"></a>1.第一印象</h2><p>   当我们知道这个需求后，我们第一印象为了应对并发，可以基于多线程，写一个多线程的程序，但是多线程会有一些弊端就是需要cpu上下文切换，这样就会导致处理操作句柄，代价大。那多线程不够好的话，我们就把目光放在了单线程，用单线程处理大量客户端的连接，先抛出一个问题：加入有多个客户端连接，在处理A用户发过来的消息的同时，B用户也发来了小心，会不会导致B的消息丢失，答案是不会的，原因是处理IO时，处理IO操作时，接收B传过来消息的并不是CPU，而是DMA控制器，不会造成数据的丢失，为数据的不丢失性，提供了保障。</p>
<p>  那我们知道每一个网络连接再内核中都已一个文件描述符来表示，我们可以用单线程程序写一个网络服务器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(fdx <span class="built_in">in</span> (fdA~FdB))</span><br><span class="line">	&#123;</span><br><span class="line"><span class="keyword">if</span>(Fdx 有数据)</span><br><span class="line">		&#123;</span><br><span class="line">读Fdx,处理数据</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果这样写一个网络服务器，他的性能也不够低，但是不够好，原因时判断有数据到来是程序在判断，效率不够好。那么我们看一下Select 是怎么做的？</p>
<h2 id="2-Select"><a href="#2-Select" class="headerlink" title="2.Select"></a>2.Select</h2><p>我们先看select的有关的函数：</p>
<p>①:nfds：最大的文件描述符+1，fd_set *readfds：读文件描述符集合，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">                 fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>②：从fd_set 移除一个文件描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>③：判断fd是否在fd_set集合中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>④：向fd_set 加入一个文件描述符，<strong>当面向网络服务器设计中，这里加入的使tcp协议中三次握手中的accept返回的文件描述符</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>⑤：初始化一个fd_set</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>其中最核心的是fd_set</strong>,他是一个bitmap(位图)，</p>
<p>1.调用selsct提前的准备工作：</p>
<p>2.首先要创建一个fd_set 类型的变量，（监听集合）</p>
<p>3.调用FD_ZERO,初始化这个监听集合，</p>
<p>4.按需求调用FD_SET增加监听，</p>
<p>5.调用select函数，使调用的进程陷入阻塞，操作系统轮询监听集合，</p>
<p>那么select函数底层做了什么操作呢？</p>
<p>select函数会将用户态空间的fd_set拷贝到内核态，由内核态来判断是否有数据到来，如果没有数据到来，那么select函数就会阻塞，当有数据到来的时候select函数会将fd_set中标识有数据到来的fd标记，select会返回，然后程序再遍历文件描述符，遍历出就绪的文件描述符并做出相应的数据处理。</p>
<p>那么，这样做的<strong>优点</strong>就是，判断文件描述符有数据到来变为了由内核来判断，提高了效率，也不会大量再内核态和用户态切换，</p>
<p>缺点：</p>
<p>①：fd_set 位图限制了数量，该数量需要重新编译内核</p>
<p>②：数据仍然有大量的内核态和用户态之间的拷贝</p>
<p>③：监听集合和就绪集合耦合</p>
<p>④：再海量监听，少量就绪的情况下，大部分时间会浪费再FD_ISSET()中，原因使并不知道就绪的是哪一个！</p>
<p>那么pool函数又做了哪些优化呢？简单说一下。</p>
<h2 id="3-Poll"><a href="#3-Poll" class="headerlink" title="3.Poll"></a>3.Poll</h2><p>直接说结果，Poll函数中将select 中的bitmap 改为了结构体，那么就解决了位图数量限制的问题，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">// fds 是一个链表的指针，链表的节点是一个pollfd 的结构体，nfds 是节点的个数，</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">               <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">               <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">               <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">           &#125;;</span><br><span class="line"><span class="comment">//其中fd，依然是文件描述符，</span></span><br><span class="line"><span class="comment">//events 标识的是，这个文件描述符在意的事件，当是这个事件来临的时候，poll函数会将pollfd.revects置位</span></span><br><span class="line"><span class="comment">//来表征这个文件描述已经就绪</span></span><br><span class="line"><span class="comment">//pollfd.revents 可以用来每次处理完就绪的文件描述否后，再置为0；</span></span><br><span class="line"><span class="comment">//虽然并没有完全解决就序集合与遍历集合耦合的问题，但是poolfds 是可以重用的；select中的fd_set不可以重用！</span></span><br></pre></td></tr></table></figure>

<p>这样的优化，解决了部分问题，但是仍然不够完美，那么epoll又是怎样优化的：</p>
<h2 id="4-epoll"><a href="#4-epoll" class="headerlink" title="4.epoll"></a>4.epoll</h2><p>epoll 不支持跨平台，linux下独有的，不属于posxi规范，</p>
<p>epoll相对于select 和 poll来说就比较复杂一点了</p>
<p>我们先看相关的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">//创建一个epoll的文件对象，size值没有意义，只要是一个大于0的数值即可，</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用epoll_create 时，内核除了我们在epoll文件系统里建了个file结点，再内核cache（缓冲区）里建了一个红黑树 用于存储以后epoll_ctl 传来的socket外还会建立一个list链表，用于存储准备就绪的事件。当就绪以后，会将就绪集合拷贝到用户。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span>  epfd,  <span class="type">int</span>  op,  <span class="type">int</span>  fd,  <span class="keyword">struct</span>  epoll_event *event)</span>;</span><br><span class="line"><span class="comment">// epfd是epoll_create 创建的epoll的文件对象，</span></span><br><span class="line"><span class="comment">//op的选项：</span></span><br><span class="line"><span class="comment">//EPOLL_CTL_ADD 向epfd中加入一个文件描述符  </span></span><br><span class="line"><span class="comment">//EPOLL_CTL_MOD 向epfd更改与目标文件关联的事件事件描述符fd</span></span><br><span class="line"><span class="comment">//EPOLL_CTL_DEL 向epfd中删除一个文件描述符</span></span><br><span class="line"><span class="comment">//event 是一个指向结构体 epoll_event 的指针，</span></span><br><span class="line"><span class="comment">//而 epoll_event 中的 events 描述的是事件的属性，读阻塞/写阻塞，data是携带的额外的信息，</span></span><br><span class="line"><span class="comment">//epoll_data_t 是一个联合体一般是fd。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">               <span class="type">void</span>        *ptr;</span><br><span class="line">               <span class="type">int</span>          fd;<span class="comment">//一般是这个</span></span><br><span class="line">               <span class="type">uint32_t</span>     u32;</span><br><span class="line">               <span class="type">uint64_t</span>     u64;</span><br><span class="line">           &#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">               <span class="type">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">               <span class="type">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>

<p>所以我们可以得出结论，epoll_ctl()函数中的event 所指向的结构体相比较poll中的结构体是去掉了revent。</p>
<p><strong>在这里我们不仅将fd 经过op操作可以加入epfd中，同时我们还传入一个携带同样fd的event结构体，所以，传入两份相同的数据确实会对空间造成影响，但是结构体中的fd，可以使我们再epoll_wait 函数中能够遍历这个数组</strong></p>
<p><strong>用来遍历就绪集合，达到一个空间换时间的功能。他同时也处理了select 的就绪集合和监听集合耦合的问题</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,<span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">//如果 timeout 的值为负数，epoll_wait 函数会一直阻塞，直到有事件发生。</span></span><br><span class="line"><span class="comment">//如果 timeout 的值为零，epoll_wait 函数会立即返回，无论是否有事件发生。这相当于在非阻塞模式下调用 epoll_wait。</span></span><br><span class="line"><span class="comment">//如果 timeout 的值为正数，epoll_wait 函数将等待指定的时间，直到有事件发生或者超时。如果在超时之前有事件发生，epoll_wait 函数将立即返回，并将事件存储到 events 数组中。如果超时时间到达而没有事件发生，epoll_wait 函数也会返回，此时返回值为 0，表示没有事件发生。</span></span><br><span class="line"><span class="comment">//struct epoll_event *events 是一个传入传出参数，events 是一个元素类型为struct epoll_event，长度为maxevents，他们将用来保存就绪集合，</span></span><br><span class="line"><span class="comment">// return value 是就序集合的长度，再event.data.fd中找到就绪文件描述符。</span></span><br></pre></td></tr></table></figure>

<p>接下来我们看一个 实现epoll的一个示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line">           <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">           <span class="type">int</span> listen_sock, conn_sock, nfds, epollfd;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Code to set up listening socket, &#x27;listen_sock&#x27;,</span></span><br><span class="line"><span class="comment">              (socket(), bind(), listen()) omitted */</span></span><br><span class="line"></span><br><span class="line">           epollfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">           <span class="keyword">if</span> (epollfd == <span class="number">-1</span>) &#123;</span><br><span class="line">               perror(<span class="string">&quot;epoll_create1&quot;</span>);</span><br><span class="line">               <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           ev.events = EPOLLIN;</span><br><span class="line">           ev.data.fd = listen_sock;</span><br><span class="line">           <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">               perror(<span class="string">&quot;epoll_ctl: listen_sock&quot;</span>);</span><br><span class="line">               <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               nfds = epoll_wait(epollfd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">               <span class="keyword">if</span> (nfds == <span class="number">-1</span>) &#123;</span><br><span class="line">                   perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">                   <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; nfds; ++n) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (events[n].data.fd == listen_sock) &#123;</span><br><span class="line">                       conn_sock = accept(listen_sock,</span><br><span class="line">                                     (<span class="keyword">struct</span> sockaddr *) &amp;addr, &amp;addrlen);</span><br><span class="line">                       <span class="keyword">if</span> (conn_sock == <span class="number">-1</span>) &#123;</span><br><span class="line">                           perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                           <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                       &#125;</span><br><span class="line">                       setnonblocking(conn_sock);</span><br><span class="line">                       ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                       ev.data.fd = conn_sock;</span><br><span class="line">                       <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,</span><br><span class="line">                                   &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">                           perror(<span class="string">&quot;epoll_ctl: conn_sock&quot;</span>);</span><br><span class="line">                           <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       do_use_fd(events[n].data.fd);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>epoll 的边缘触发，水平触发，以及海量监听下性能也很好  scales well to </p>
<p>redis 是用的epoll 。njinx javaNIO (linux 下)</p>
<p>问题：既然fd_set 运用了bitmap select之前是标识监听的文件描述符，select 会把就绪的集合置为，所以底层怎么技既能标识监听又能表示就绪的？</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/25/STL/</url>
    <content><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1>]]></content>
  </entry>
  <entry>
    <title>Mymap Myset</title>
    <url>/2023/07/30/STL%E4%B9%8B%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0map%E5%92%8Cset/</url>
    <content><![CDATA[<p>红黑树模拟实现map和set</p>
<span id="more"></span>

<h2 id="一、map和set模板"><a href="#一、map和set模板" class="headerlink" title="一、map和set模板"></a>一、map和set模板</h2><p>set用value标识元素(value就是key，类型为T)，并且每个value必须唯一 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>&gt;<span class="comment">//set</span></span><br></pre></td></tr></table></figure>



<p>在map中，键值key通常用于排序和惟一地标识元素，而值value中存储与此键值key关联的内容。键值key和值value的类型可能不同，并且在map的内部，key与value通过成员类型value_type绑定在一起，为其取别名称为pair：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">const</span> Key, T&gt; value_type;</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//map</span></span><br></pre></td></tr></table></figure>

<p> 用<a href="https://so.csdn.net/so/search?q=%E7%BA%A2%E9%BB%91%E6%A0%91&spm=1001.2101.3001.7020">红黑树</a>同时封装出set和map时，set传给value的是一个value，map传给value的是一个pair，set和map传给红黑树的value决定了这棵树里面存的节点值类型。上层容器不同，底层红黑树的Key和T也不同。</p>
<p><img src="D:\Blog\host_source\image-20230730170956974.png"></p>
<p>在上层容器set中，K和T都代表Key，底层红黑树节点当中存储K和T都是一样的；map中，K代表键值Key，T代表由Key和Value构成的键值对，底层红黑树中只能存储T。所以红黑树为了满足同时支持set和map，节点当中存储T</p>
<p>这就要对红黑树进行改动。</p>
<h2 id="二、红黑树节点定义"><a href="#二、红黑树节点定义" class="headerlink" title="二、红黑树节点定义"></a>二、红黑树节点定义</h2><h3 id="1-红黑树节点定义由类模板"><a href="#1-红黑树节点定义由类模板" class="headerlink" title="1.红黑树节点定义由类模板"></a>1.红黑树节点定义由类模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br></pre></td></tr></table></figure>

<p>那么节点定义修改为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//红黑树节点定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">	RBTreeNode&lt;T&gt;* _left;<span class="comment">//节点的左孩子</span></span><br><span class="line">	RBTreeNode&lt;T&gt;* _right;<span class="comment">//节点的右孩子</span></span><br><span class="line">	RBTreeNode&lt;T&gt;* _parent;<span class="comment">//节点的父亲</span></span><br><span class="line"> </span><br><span class="line">	T _data;<span class="comment">//节点的值，_data里面存的是K就传K，存的是pair就传pair</span></span><br><span class="line">	Colour _col;<span class="comment">//节点颜色</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">RBTreeNode</span>(<span class="type">const</span> T&amp; x)</span><br><span class="line">		:_left(<span class="literal">nullptr</span>)</span><br><span class="line">		, _right(<span class="literal">nullptr</span>)</span><br><span class="line">		, _parent(<span class="literal">nullptr</span>)</span><br><span class="line">		, _data(x)</span><br><span class="line">		, _col(RED)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于红黑树不知道上层传的是K还是pair，这是由上层传递的模板参数T决定的，上层是封装我的map和set</p>
<h3 id="2-仿函数"><a href="#2-仿函数" class="headerlink" title="2.仿函数"></a>2.仿函数</h3><h4 id="（1）节点比较大小时存在的问题"><a href="#（1）节点比较大小时存在的问题" class="headerlink" title="（1）节点比较大小时存在的问题"></a>（1）节点比较大小时存在的问题</h4><p>红黑树插入节点时，需要比较节点的大小，kv需要改成_data:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function">pair&lt;Node*, <span class="type">bool</span>&gt; <span class="title">Insert</span><span class="params">(<span class="type">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_root = <span class="keyword">new</span> <span class="built_in">Node</span>(data);</span><br><span class="line">		_root-&gt;_col = BLACK;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">make_pair</span>(_root, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.先看树中，kv是否存在</span></span><br><span class="line">	Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">	Node* cur = _root;</span><br><span class="line">	<span class="keyword">while</span> (cur)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;_data &lt; data)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//kv比当前节点值大，向右走</span></span><br><span class="line">			parent = cur;</span><br><span class="line">			cur = cur-&gt;_right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_data &gt; data)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//kv比当前节点值小，向左走</span></span><br><span class="line">			parent = cur;</span><br><span class="line">			cur = cur-&gt;_left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//kv和当前节点值相等，已存在，插入失败</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">make_pair</span>(cur, <span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.走到这里，说明kv在树中不存在，需要插入kv，并且cur已经为空，parent已经是叶子节点了</span></span><br><span class="line">	Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line">	newNode-&gt;_col = RED;</span><br><span class="line">	<span class="keyword">if</span> (parent-&gt;_data &lt; data)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//kv比parent值大，插入到parent的右边</span></span><br><span class="line">		parent-&gt;_right = newNode;</span><br><span class="line">		newNode-&gt;_parent = parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//kv比parent值小，插入到parent的左边</span></span><br><span class="line">		parent-&gt;_left = newNode;</span><br><span class="line">		newNode-&gt;_parent = parent;</span><br><span class="line">	&#125;</span><br><span class="line">	cur = newNode;</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//如果父亲存在，且父亲颜色为红就要处理</span></span><br><span class="line">	<span class="keyword">while</span> (parent &amp;&amp; parent-&gt;_col == RED)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//情况一和情况二、三的区别关键看叔叔</span></span><br><span class="line">		Node* grandfather = parent-&gt;_parent;<span class="comment">//当父亲是红色时，根据规则（2）根节点一定是黑色，祖父一定存在</span></span><br><span class="line">		<span class="keyword">if</span> (parent == grandfather-&gt;_left)<span class="comment">//父亲是祖父的左子树</span></span><br><span class="line">		&#123;</span><br><span class="line">			Node* uncle = grandfather-&gt;_right;</span><br><span class="line">			<span class="comment">//情况一：叔叔存在且为红</span></span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;_col == RED)</span><br><span class="line">			&#123;</span><br><span class="line">				parent-&gt;_col = uncle-&gt;_col = BLACK;</span><br><span class="line">				grandfather-&gt;_col = RED;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//继续向上调整</span></span><br><span class="line">				cur = grandfather;</span><br><span class="line">				parent = cur-&gt;_parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//情况二+情况三：叔叔不存在或叔叔存在且为黑</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//情况二：单旋</span></span><br><span class="line">				<span class="keyword">if</span> (cur == parent-&gt;_left)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">RotateR</span>(grandfather);</span><br><span class="line">					parent-&gt;_col = BLACK;</span><br><span class="line">					grandfather-&gt;_col = RED;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//情况三：双旋</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">RotateL</span>(parent);</span><br><span class="line">					<span class="built_in">RotateR</span>(grandfather);</span><br><span class="line">					cur-&gt;_col = BLACK;</span><br><span class="line">					grandfather-&gt;_col = RED;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//插入结束</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//父亲是祖父的右子树</span></span><br><span class="line">		&#123;</span><br><span class="line">			Node* uncle = grandfather-&gt;_left;</span><br><span class="line">			<span class="comment">//情况一：叔叔存在且为红</span></span><br><span class="line">			<span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == RED)</span><br><span class="line">			&#123;</span><br><span class="line">				parent-&gt;_col = uncle-&gt;_col = BLACK;</span><br><span class="line">				grandfather-&gt;_col = RED;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//继续往上调整</span></span><br><span class="line">				cur = grandfather;</span><br><span class="line">				parent = grandfather-&gt;_parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//情况二+情况三：叔叔不存在或叔叔存在且为黑</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//情况二：单旋</span></span><br><span class="line">				<span class="keyword">if</span> (cur == parent-&gt;_right)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">RotateL</span>(grandfather);</span><br><span class="line">					parent-&gt;_col = BLACK;</span><br><span class="line">					grandfather-&gt;_col = RED;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//情况三：双旋</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">RotateR</span>(parent);</span><br><span class="line">					<span class="built_in">RotateL</span>(grandfather);</span><br><span class="line">					cur-&gt;_col = BLACK;</span><br><span class="line">					grandfather-&gt;_col = RED;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//插入结束</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	_root-&gt;_col = BLACK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make_pair</span>(newNode, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是以上代码在插入新节和查找节点时，当和当前节点比较大小时，Key可以比较，但是pair比较不了，也就是set可以比较，但是map比较不了。这就需要写一个仿函数，如果是map就取_data里面的first也就是Key进行比较，通过泛型解决红黑树里面存的是什么。所以上层容器map需要向底层的红黑树提供仿函数来获取T里面的Key，这样无论上层容器是set还是map，都可以用统一的方式进行比较了。</p>
<h4 id="2-仿函数-1"><a href="#2-仿函数-1" class="headerlink" title="(2) 仿函数"></a>(2) 仿函数</h4><p>仿函数让一个类的使用看上去像个函数。仿函数是在类中实现了一个operator( )，是一个类的对象，这个类就有了类似函数的行为，所以这个类就是一个仿函数类，目的是为了让函数拥有类的性质。</p>
<p>这个类的对象即仿函数，可以当作一般函数去用，只不过仿函数的功能是在一个类中的运算符operator()中实现的，使用的时候把函数作为参进行传递即可。</p>
<p>set有set的仿函数，map有map的仿函数，尽管set的仿函数看起来没有什么作用，但是，必须要把它传给底层红黑树，这样红黑树就能根据仿函数分别获取set的key和map的first。</p>
<p>①：set的仿函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> delia</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">set</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//仿函数，获取set的key</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">SetKeyOfT</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> key;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; k)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">_t</span>.<span class="built_in">Insert</span>(k);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		RBTree&lt;K, K,SetKeyOfT&gt; <span class="type">_t</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②map的仿函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> delia</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>,<span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">map</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//仿函数，获取map的first</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">MapKeyOfT</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">const</span> K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> kv.first;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//插入</span></span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">const</span> K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">_t</span>.<span class="built_in">Insert</span>(kv);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		RBTree&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt; <span class="type">_t</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了仿函数红黑树的类在实现时，就要在模板参数中增加KeyOfT仿函数。</p>
<h4 id="（3）修改红黑树定义"><a href="#（3）修改红黑树定义" class="headerlink" title="（3）修改红黑树定义"></a>（3）修改红黑树定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">KeyOfT</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBTree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> RBTreeNode&lt;T&gt; Node;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node* _root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="（4）修改红黑树插入"><a href="#（4）修改红黑树插入" class="headerlink" title="（4）修改红黑树插入"></a>（4）修改红黑树插入</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function">pair&lt;Node*, <span class="type">bool</span>&gt; <span class="title">Insert</span><span class="params">(<span class="type">const</span> pair&lt;K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		_root = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line">		_root-&gt;_col = BLACK;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">make_pair</span>(_root, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	KeyOfT kot;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.先看树中，kv是否存在</span></span><br><span class="line">	Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">	Node* cur = _root;</span><br><span class="line">	<span class="keyword">while</span> (cur)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &lt; <span class="built_in">kot</span>(data))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//kv比当前节点值大，向右走</span></span><br><span class="line">			parent = cur;</span><br><span class="line">			cur = cur-&gt;_right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &gt; <span class="built_in">kot</span>(data))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//kv比当前节点值小，向左走</span></span><br><span class="line">			parent = cur;</span><br><span class="line">			cur = cur-&gt;_left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//kv和当前节点值相等，已存在，插入失败</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">make_pair</span>(cur, <span class="literal">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.走到这里，说明kv在树中不存在，需要插入kv，并且cur已经为空，parent已经是叶子节点了</span></span><br><span class="line">	Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(kv);</span><br><span class="line">	newNode-&gt;_col = RED;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">kot</span>(parent-&gt;_data) &lt; <span class="built_in">kot</span>(data))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//kv比parent值大，插入到parent的右边</span></span><br><span class="line">		parent-&gt;_right = newNode;</span><br><span class="line">		newNode-&gt;_parent = parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//kv比parent值小，插入到parent的左边</span></span><br><span class="line">		parent-&gt;_left = newNode;</span><br><span class="line">		newNode-&gt;_parent = parent;</span><br><span class="line">	&#125;</span><br><span class="line">	cur = newNode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果父亲存在，且父亲颜色为红就要处理</span></span><br><span class="line">	<span class="keyword">while</span> (parent &amp;&amp; parent-&gt;_col == RED)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//情况一和情况二、三的区别关键看叔叔</span></span><br><span class="line">		Node* grandfather = parent-&gt;_parent;<span class="comment">//当父亲是红色时，根据规则（2）根节点一定是黑色，祖父一定存在</span></span><br><span class="line">		<span class="keyword">if</span> (parent == grandfather-&gt;_left)<span class="comment">//父亲是祖父的左子树</span></span><br><span class="line">		&#123;</span><br><span class="line">			Node* uncle = grandfather-&gt;_right;</span><br><span class="line">			<span class="comment">//情况一：叔叔存在且为红</span></span><br><span class="line">			<span class="keyword">if</span> (uncle-&gt;_col == RED)</span><br><span class="line">			&#123;</span><br><span class="line">				parent-&gt;_col = uncle-&gt;_col = BLACK;</span><br><span class="line">				grandfather-&gt;_col = RED;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//继续向上调整</span></span><br><span class="line">				cur = grandfather;</span><br><span class="line">				parent = cur-&gt;_parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//情况二+情况三：叔叔不存在或叔叔存在且为黑</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//情况二：单旋</span></span><br><span class="line">				<span class="keyword">if</span> (cur == parent-&gt;_left)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">RotateR</span>(grandfather);</span><br><span class="line">					parent-&gt;_col = BLACK;</span><br><span class="line">					grandfather-&gt;_col = RED;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//情况三：双旋</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">RotateL</span>(parent);</span><br><span class="line">					<span class="built_in">RotateR</span>(grandfather);</span><br><span class="line">					cur-&gt;_col = BLACK;</span><br><span class="line">					grandfather-&gt;_col = RED;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//插入结束</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//父亲是祖父的右子树</span></span><br><span class="line">		&#123;</span><br><span class="line">			Node* uncle = grandfather-&gt;_left;</span><br><span class="line">			<span class="comment">//情况一：叔叔存在且为红</span></span><br><span class="line">			<span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == RED)</span><br><span class="line">			&#123;</span><br><span class="line">				parent-&gt;_col = uncle-&gt;_col = BLACK;</span><br><span class="line">				grandfather-&gt;_col = RED;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//继续往上调整</span></span><br><span class="line">				cur = grandfather;</span><br><span class="line">				parent = grandfather-&gt;_parent;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//情况二+情况三：叔叔不存在或叔叔存在且为黑</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//情况二：单旋</span></span><br><span class="line">				<span class="keyword">if</span> (cur == parent-&gt;_right)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">RotateL</span>(grandfather);</span><br><span class="line">					parent-&gt;_col = BLACK;</span><br><span class="line">					grandfather-&gt;_col = RED;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//情况三：双旋</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">RotateR</span>(parent);</span><br><span class="line">					<span class="built_in">RotateL</span>(grandfather);</span><br><span class="line">					cur-&gt;_col = BLACK;</span><br><span class="line">					grandfather-&gt;_col = RED;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//插入结束</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	_root-&gt;_col = BLACK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make_pair</span>(newNode, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node* subL = parent-&gt;_left;</span><br><span class="line">	Node* subLR = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subL)</span><br><span class="line">	&#123;</span><br><span class="line">		subLR = subL-&gt;_right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//1.左子树的右子树变我的左子树</span></span><br><span class="line">	parent-&gt;_left = subLR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subLR)</span><br><span class="line">	&#123;</span><br><span class="line">		subLR-&gt;_parent = parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//左子树变父亲</span></span><br><span class="line">	subL-&gt;_right = parent;</span><br><span class="line">	Node* parentParent = parent-&gt;_parent;</span><br><span class="line">	parent-&gt;_parent = subL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent == _root)<span class="comment">//parent是根</span></span><br><span class="line">	&#123;</span><br><span class="line">		_root = subL;</span><br><span class="line">		_root-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//parent不是根，是子树</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (parentParent-&gt;_left == parent)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//parent是自己父亲的左子树,将subL作为parent父亲的左孩子</span></span><br><span class="line">			parentParent-&gt;_left = subL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//parent是自己父亲的右子树,将subL作为parent父亲的右孩子</span></span><br><span class="line">			parentParent-&gt;_right = subL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//subL的父亲就是parent的父亲</span></span><br><span class="line">		subL-&gt;_parent = parentParent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node* subR = parent-&gt;_right;</span><br><span class="line">	Node* subRL = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subR)</span><br><span class="line">	&#123;</span><br><span class="line">		subRL = subR-&gt;_left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.右子树的左子树变我的右子树</span></span><br><span class="line">	parent-&gt;_right = subRL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (subRL)</span><br><span class="line">	&#123;</span><br><span class="line">		subRL-&gt;_parent = parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.右子树变父亲</span></span><br><span class="line">	subR-&gt;_left = parent;</span><br><span class="line">	Node* parentParent = parent-&gt;_parent;</span><br><span class="line">	parent-&gt;_parent = subR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent == _root)<span class="comment">//parent是根</span></span><br><span class="line">	&#123;</span><br><span class="line">		_root = parent;</span><br><span class="line">		_root-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//parent不是根，是子树</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (parentParent-&gt;_left == parent)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//parent是自己父亲的左子树,将subR作为parent父亲的左孩子</span></span><br><span class="line">			parentParent-&gt;_left = subR;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//parent是自己父亲的右子树,将subR作为parent父亲的右孩子</span></span><br><span class="line">			parentParent-&gt;_right = subR;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//subR的父亲就是parent的父亲</span></span><br><span class="line">		subR-&gt;_parent = parentParent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（5）修改红黑树查找"><a href="#（5）修改红黑树查找" class="headerlink" title="（5）修改红黑树查找"></a>（5）修改红黑树查找</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function">Node* <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	KeyOfT kot;</span><br><span class="line">	Node* cur = _root;</span><br><span class="line">	<span class="keyword">while</span> (cur)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &lt; key)</span><br><span class="line">		&#123;</span><br><span class="line">			cur = cur-&gt;_right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &gt; key)</span><br><span class="line">		&#123;</span><br><span class="line">			cur = cur-&gt;_left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> cur;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">//空树，直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、红黑树迭代器"><a href="#三、红黑树迭代器" class="headerlink" title="三、红黑树迭代器"></a>三、红黑树迭代器</h2><p>map和set的迭代器的实现其实本质上是红黑树迭代器的实现，迭代器的实现需要定义模板类型、模板类型引用、模板类型指针。 </p>
<h3 id="1-红黑树中迭代器重命名"><a href="#1-红黑树中迭代器重命名" class="headerlink" title="1.红黑树中迭代器重命名"></a>1.红黑树中迭代器重命名</h3><p> 在红黑树中重命名模板类型、模板类型引用、模板类型指针，定义为public，外部就能使用iterator了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">KeyOfT</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBTree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> RBTreeNode&lt;T&gt; Node;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __TreeIterator&lt;T, T&amp;, T*&gt; iterator;<span class="comment">//模板类型、模板类型引用、模板类型指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//红黑树函数...</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node* _root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-正向迭代器定义"><a href="#2-正向迭代器定义" class="headerlink" title="2.正向迭代器定义"></a>2.正向迭代器定义</h3><p>红黑树的迭代器的本质是对节点指针进行封装，所以迭代器中只有封装红黑树节点指针这一个成员变量 。正向迭代器：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">template&lt;<span class="keyword">class</span> <span class="symbol">T,<span class="symbol">class</span></span> <span class="symbol">Ref,<span class="symbol">class</span></span> <span class="symbol">ptr</span>&gt;</span><br><span class="line"><span class="symbol">struct</span> <span class="symbol">__TreeIterator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> RBTreeNode&lt;T&gt; Node;</span><br><span class="line">	<span class="keyword">typedef</span> __TreeIterator&lt;T, Ref, ptr&gt; Self;</span><br><span class="line">      </span><br><span class="line">	Node* _node;<span class="comment">//成员变量</span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-迭代器构造"><a href="#3-迭代器构造" class="headerlink" title="3.迭代器构造"></a>3.迭代器构造</h3><p>用节点指针构造正向迭代器：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">//构造函数</span><br><span class="line">__TreeIterator(<span class="keyword">Node</span><span class="title">* node</span>)</span><br><span class="line">	:_node(<span class="keyword">node</span><span class="title">)</span></span><br><span class="line"><span class="title">&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-正向迭代器重载"><a href="#4-正向迭代器重载" class="headerlink" title="4.正向迭代器重载*"></a>4.正向迭代器重载*</h3><p>Ref对正向迭代器解引用，返回节点数据引用</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//* 解引用，返回节点数据</span></span><br><span class="line">Ref Operator*()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="title">return</span> _node-&gt;</span>_<span class="keyword">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-正向迭代器重载-gt"><a href="#5-正向迭代器重载-gt" class="headerlink" title="5.正向迭代器重载-&gt;"></a>5.正向迭代器重载-&gt;</h3><p>Ptr对正向迭代器使用-&gt;，返回节点数据指针：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-&gt; 返回节点数据地址</span></span><br><span class="line">P<span class="function"><span class="title">tr</span> Operator-&gt;</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="title">return</span> &amp;_node-&gt;</span>_<span class="keyword">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-正向迭代器重载-x3D-x3D"><a href="#6-正向迭代器重载-x3D-x3D" class="headerlink" title="6.正向迭代器重载&#x3D;&#x3D;"></a>6.正向迭代器重载&#x3D;&#x3D;</h3><p>判断节点是否相同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断两个迭代器是否相同</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Self&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _node == s._node;<span class="comment">//判断节点是否相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-正向迭代器重载！-x3D"><a href="#7-正向迭代器重载！-x3D" class="headerlink" title="7.正向迭代器重载！&#x3D;"></a>7.正向迭代器重载！&#x3D;</h3><p>判断节点是否不同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断两个迭代器是否不同</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _node != s._node;<span class="comment">//判断节点是否不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-正向迭代器"><a href="#8-正向迭代器" class="headerlink" title="8.正向迭代器++"></a>8.正向迭代器++</h3><p>①当节点的右子树不为空时，++就要走到右子树的最左节点</p>
<p> ②当节点的右子树为空时，++就要走到节点的父亲</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//红黑树迭代器的++也就是红黑树的++</span></span><br><span class="line">	Self <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1.右子树不为空</span></span><br><span class="line">		<span class="keyword">if</span> (_node-&gt;_right)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//下一个访问的是右树的中序第一个节点（即右子树最左节点）。</span></span><br><span class="line">			Node* left = _node-&gt;_right;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//找最左节点</span></span><br><span class="line">			<span class="keyword">while</span> (left-&gt;_left)</span><br><span class="line">			&#123;</span><br><span class="line">				left = left-&gt;_left;</span><br><span class="line">			&#125;</span><br><span class="line">			_node = left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//2.右子树为空，下一个访问的就是当前节点的父亲</span></span><br><span class="line">		&#123;</span><br><span class="line">			Node* cur = _node;</span><br><span class="line">			Node* parent = cur-&gt;_parent;</span><br><span class="line">			<span class="keyword">while</span> (parent &amp;&amp; cur == parent-&gt;_right)</span><br><span class="line">			&#123;</span><br><span class="line">				cur = cur-&gt;_parent;</span><br><span class="line">				parent = parent-&gt;_parent;</span><br><span class="line">			&#125;</span><br><span class="line">			_node = parent;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-正向迭代器–"><a href="#9-正向迭代器–" class="headerlink" title="9.正向迭代器–"></a>9.正向迭代器–</h3><p> ①当节点的左子树不为空时，++就要走到左子树的最右节点</p>
<p> ②当节点的左子树为空时，++就要走到节点的父亲</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//红黑树迭代器的--也就是红黑树的--</span></span><br><span class="line">Self <span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//1.左子树不为空</span></span><br><span class="line">	<span class="keyword">if</span> (_node-&gt;_left)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//下一个访问的是左树的中序左后节点（即做子树最右节点）。</span></span><br><span class="line">		Node* right = _node-&gt;_left;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//找最右节点</span></span><br><span class="line">		<span class="keyword">while</span> (right-&gt;_right)</span><br><span class="line">		&#123;</span><br><span class="line">			right = right-&gt;_right;</span><br><span class="line">		&#125;</span><br><span class="line">		_node = right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//2.左子树为空，下一个访问的就是当前节点的父亲</span></span><br><span class="line">	&#123;</span><br><span class="line">		Node* cur = _node;</span><br><span class="line">		Node* parent = cur-&gt;_parent;</span><br><span class="line">		<span class="keyword">while</span> (parent &amp;&amp; cur == parent-&gt;_left)</span><br><span class="line">		&#123;</span><br><span class="line">			cur = cur-&gt;_parent;</span><br><span class="line">			parent = parent-&gt;_parent;</span><br><span class="line">		&#125;</span><br><span class="line">		_node = parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-红黑树中实现迭代器"><a href="#10-红黑树中实现迭代器" class="headerlink" title="10.红黑树中实现迭代器"></a>10.红黑树中实现迭代器</h3><p>实现begin( )找最左节点，end( )最后一个节点的下一个位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">KeyOfT</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBTree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> RBTreeNode&lt;T&gt; Node;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __TreeIterator&lt;T, T&amp;, T*&gt; iterator;<span class="comment">//模板类型、模板类型引用、模板类型指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找最左节点</span></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* left = _root;</span><br><span class="line">		<span class="keyword">while</span> (left &amp;&amp; left-&gt;_left)</span><br><span class="line">		&#123;</span><br><span class="line">			left = left-&gt;_left;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">iterator</span>(left)<span class="comment">//返回最左节点的正向迭代器</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//结束</span></span><br><span class="line">	iterator <span class="built_in">end</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node* _root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="四、set模拟实现"><a href="#四、set模拟实现" class="headerlink" title="四、set模拟实现"></a>四、set模拟实现</h2><p>调用红黑树对应接口实现set，插入和查找函数返回值当中的节点指针改为迭代器:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RBTree.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> delia</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">set</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//仿函数，获取set的key</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">SetKeyOfT</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> key;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, K, SetKeyOfT&gt;::iterator iterator;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//迭代器开始</span></span><br><span class="line">		<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">begin</span>();</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//迭代器结束</span></span><br><span class="line">		<span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">end</span>();</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//插入函数</span></span><br><span class="line">		<span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">Insert</span>(key);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//查找</span></span><br><span class="line">		<span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">find</span>(key);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		RBTree&lt;K, K, SetKeyOfT&gt; <span class="type">_t</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、map模拟实现"><a href="#五、map模拟实现" class="headerlink" title="五、map模拟实现"></a>五、map模拟实现</h2><p>调用红黑树对应接口实现map，插入和查找函数返回值当中的节点指针改为迭代器，增加operator[ ]的重载:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RBTree.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> delia</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">map</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//仿函数，获取map的first</span></span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">MapKeyOfT</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="type">const</span> K&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">const</span> K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function">			</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> kv.first;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> RBTree&lt;K, K, MapKeyOfT&gt;::iterator iterator;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//迭代器开始</span></span><br><span class="line">		<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">begin</span>();</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//迭代器结束</span></span><br><span class="line">		<span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">end</span>();</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//插入</span></span><br><span class="line">		<span class="function">pair&lt;iterator, <span class="type">bool</span>&gt; <span class="title">insert</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">const</span> K, V&gt;&amp; kv)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">Insert</span>(kv);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//重载operator[]</span></span><br><span class="line">		V&amp; <span class="keyword">operator</span>[](<span class="type">const</span> K&amp; key)</span><br><span class="line">		&#123;</span><br><span class="line">			pair&lt;iterator, <span class="type">bool</span>&gt; ret = <span class="built_in">insert</span>(<span class="built_in">make_pair</span>(key, <span class="built_in">V</span>()));</span><br><span class="line">			iterator it = ret.first;</span><br><span class="line">			<span class="keyword">return</span> it-&gt;second;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//查找</span></span><br><span class="line">		<span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="type">_t</span>.<span class="built_in">find</span>(key);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		RBTree&lt;K, pair&lt;<span class="type">const</span> K, V&gt;, MapKeyOfT&gt; <span class="type">_t</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、红黑树完整代码段"><a href="#六、红黑树完整代码段" class="headerlink" title="六、红黑树完整代码段"></a>六、红黑树完整代码段</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//节点颜色</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Colour</span></span><br><span class="line">&#123;</span><br><span class="line">	RED,</span><br><span class="line">	BLACK,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//红黑树节点定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">	RBTreeNode&lt;T&gt;* _left;<span class="comment">//节点的左孩子</span></span><br><span class="line">	RBTreeNode&lt;T&gt;* _right;<span class="comment">//节点的右孩子</span></span><br><span class="line">	RBTreeNode&lt;T&gt;* _parent;<span class="comment">//节点的父亲</span></span><br><span class="line"> </span><br><span class="line">	T _data;<span class="comment">//节点的值</span></span><br><span class="line">	Colour _col;<span class="comment">//节点颜色</span></span><br><span class="line"> </span><br><span class="line">	<span class="built_in">RBTreeNode</span>(<span class="type">const</span> T&amp; x)</span><br><span class="line">		:_left(<span class="literal">nullptr</span>)</span><br><span class="line">		, _right(<span class="literal">nullptr</span>)</span><br><span class="line">		, _parent(<span class="literal">nullptr</span>)</span><br><span class="line">		, _data(x)</span><br><span class="line">		, _col(RED)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">Ref</span>,<span class="keyword">class</span> <span class="title class_">ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__TreeIterator</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> RBTreeNode&lt;T&gt; Node;</span><br><span class="line">	<span class="keyword">typedef</span> __TreeIterator&lt;T, Ref, ptr&gt; Self;</span><br><span class="line"> </span><br><span class="line">	Node* _node;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	__TreeIterator(Node* node)</span><br><span class="line">		:_node(node)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//* 解引用，返回节点数据</span></span><br><span class="line">	Ref <span class="keyword">operator</span>*()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _node-&gt;_data;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//-&gt; 返回节点数据地址</span></span><br><span class="line">	<span class="comment">//Ptr operator-&gt;()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	return &amp;_node-&gt;_data;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//判断两个迭代器是否相同</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Self&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _node == s._node;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//判断两个迭代器是否不同</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Self&amp; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _node != s._node;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//红黑树迭代器的++也就是红黑树的++</span></span><br><span class="line">	Self <span class="keyword">operator</span>++()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1.右子树不为空</span></span><br><span class="line">		<span class="keyword">if</span> (_node-&gt;_right)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//下一个访问的是右树的中序第一个节点（即右子树最左节点）。</span></span><br><span class="line">			Node* left = _node-&gt;_right;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//找最左节点</span></span><br><span class="line">			<span class="keyword">while</span> (left-&gt;_left)</span><br><span class="line">			&#123;</span><br><span class="line">				left = left-&gt;_left;</span><br><span class="line">			&#125;</span><br><span class="line">			_node = left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//2.右子树为空，下一个访问的就是当前节点的父亲</span></span><br><span class="line">		&#123;</span><br><span class="line">			Node* cur = _node;</span><br><span class="line">			Node* parent = cur-&gt;_parent;</span><br><span class="line">			<span class="keyword">while</span> (parent &amp;&amp; cur == parent-&gt;_right)</span><br><span class="line">			&#123;</span><br><span class="line">				cur = cur-&gt;_parent;</span><br><span class="line">				parent = parent-&gt;_parent;</span><br><span class="line">			&#125;</span><br><span class="line">			_node = parent;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//红黑树迭代器的--也就是红黑树的--</span></span><br><span class="line">	Self <span class="keyword">operator</span>--()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1.左子树不为空</span></span><br><span class="line">		<span class="keyword">if</span> (_node-&gt;_left)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//下一个访问的是左树的中序左后节点（即做子树最右节点）。</span></span><br><span class="line">			Node* right = _node-&gt;_left;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//找最右节点</span></span><br><span class="line">			<span class="keyword">while</span> (right-&gt;_right)</span><br><span class="line">			&#123;</span><br><span class="line">				right = right-&gt;_right;</span><br><span class="line">			&#125;</span><br><span class="line">			_node = right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//2.左子树为空，下一个访问的就是当前节点的父亲</span></span><br><span class="line">		&#123;</span><br><span class="line">			Node* cur = _node;</span><br><span class="line">			Node* parent = cur-&gt;_parent;</span><br><span class="line">			<span class="keyword">while</span> (parent &amp;&amp; cur == parent-&gt;_left)</span><br><span class="line">			&#123;</span><br><span class="line">				cur = cur-&gt;_parent;</span><br><span class="line">				parent = parent-&gt;_parent;</span><br><span class="line">			&#125;</span><br><span class="line">			_node = parent;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//插入节点颜色是红色好，还是黑色好，红色</span></span><br><span class="line"><span class="comment">//因为插入红色节点，可能破坏规则3，影响不大</span></span><br><span class="line"><span class="comment">//插入黑色节点，一定破坏规则4 ，并且影响其他路径，影响很大</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">K</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">KeyOfT</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBTree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">typedef</span> RBTreeNode&lt;T&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> __TreeIterator&lt;T, T&amp;, T*&gt; iterator;<span class="comment">//模板类型、模板类型引用、模板类型指针</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">RBTree</span>()</span><br><span class="line">		:_root(nullpte)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//析构</span></span><br><span class="line">	~<span class="built_in">RBTree</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		_Destroy(_root);</span><br><span class="line">		_root = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="type">void</span> _Destroy(Node* root)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		_Destroy(root-&gt;_left);</span><br><span class="line">		_Destroy(root-&gt;_right);</span><br><span class="line">		<span class="keyword">delete</span> root;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//找最左节点</span></span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* left = _root;</span><br><span class="line">		<span class="keyword">while</span> (left &amp;&amp; left-&gt;_left)</span><br><span class="line">		&#123;</span><br><span class="line">			left = left-&gt;_left;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">iterator</span>(left);<span class="comment">//返回最左节点的正向迭代器</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//结束</span></span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">RBTree</span>()</span><br><span class="line">		:_root(<span class="literal">nullptr</span>)</span><br><span class="line">	&#123;&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">Destroy</span>(root-&gt;_left);</span><br><span class="line">		<span class="built_in">Destroy</span>(root-&gt;_right);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">RBTree</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Destroy</span>(_root);</span><br><span class="line">		_root = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//插入</span></span><br><span class="line">	<span class="function">pair&lt;Node*, <span class="type">bool</span>&gt; <span class="title">Insert</span><span class="params">(<span class="type">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			_root = <span class="keyword">new</span> <span class="built_in">Node</span>(data);</span><br><span class="line">			_root-&gt;_col = BLACK;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">make_pair</span>(_root, <span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		KeyOfT kot;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//1.先看树中，kv是否存在</span></span><br><span class="line">		Node* parent = <span class="literal">nullptr</span>;</span><br><span class="line">		Node* cur = _root;</span><br><span class="line">		<span class="keyword">while</span> (cur)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &lt; <span class="built_in">kot</span>(data))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//kv比当前节点值大，向右走</span></span><br><span class="line">				parent = cur;</span><br><span class="line">				cur = cur-&gt;_right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &gt; <span class="built_in">kot</span>(data))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//kv比当前节点值小，向左走</span></span><br><span class="line">				parent = cur;</span><br><span class="line">				cur = cur-&gt;_left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//kv和当前节点值相等，已存在，插入失败</span></span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">make_pair</span>(cur, <span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//2.走到这里，说明kv在树中不存在，需要插入kv，并且cur已经为空，parent已经是叶子节点了</span></span><br><span class="line">		Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(data);</span><br><span class="line">		newNode-&gt;_col = RED;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">kot</span>(parent-&gt;_data) &lt; <span class="built_in">kot</span>(data))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//kv比parent值大，插入到parent的右边</span></span><br><span class="line">			parent-&gt;_right = newNode;</span><br><span class="line">			newNode-&gt;_parent = parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//kv比parent值小，插入到parent的左边</span></span><br><span class="line">			parent-&gt;_left = newNode;</span><br><span class="line">			newNode-&gt;_parent = parent;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = newNode;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//如果父亲存在，且父亲颜色为红就要处理</span></span><br><span class="line">		<span class="keyword">while</span> (parent &amp;&amp; parent-&gt;_col == RED)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//情况一和情况二、三的区别关键看叔叔</span></span><br><span class="line">			Node* grandfather = parent-&gt;_parent;<span class="comment">//当父亲是红色时，根据规则（2）根节点一定是黑色，祖父一定存在</span></span><br><span class="line">			<span class="keyword">if</span> (parent == grandfather-&gt;_left)<span class="comment">//父亲是祖父的左子树</span></span><br><span class="line">			&#123;</span><br><span class="line">				Node* uncle = grandfather-&gt;_right;</span><br><span class="line">				<span class="comment">//情况一：叔叔存在且为红</span></span><br><span class="line">				<span class="keyword">if</span> (uncle-&gt;_col == RED)</span><br><span class="line">				&#123;</span><br><span class="line">					parent-&gt;_col = uncle-&gt;_col = BLACK;</span><br><span class="line">					grandfather-&gt;_col = RED;</span><br><span class="line"> </span><br><span class="line">					<span class="comment">//继续向上调整</span></span><br><span class="line">					cur = grandfather;</span><br><span class="line">					parent = cur-&gt;_parent;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//情况二+情况三：叔叔不存在或叔叔存在且为黑</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//情况二：单旋</span></span><br><span class="line">					<span class="keyword">if</span> (cur == parent-&gt;_left)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">RotateR</span>(grandfather);</span><br><span class="line">						parent-&gt;_col = BLACK;</span><br><span class="line">						grandfather-&gt;_col = RED;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span><span class="comment">//情况三：双旋</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">RotateL</span>(parent);</span><br><span class="line">						<span class="built_in">RotateR</span>(grandfather);</span><br><span class="line">						cur-&gt;_col = BLACK;</span><br><span class="line">						grandfather-&gt;_col = RED;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//插入结束</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span><span class="comment">//父亲是祖父的右子树</span></span><br><span class="line">			&#123;</span><br><span class="line">				Node* uncle = grandfather-&gt;_left;</span><br><span class="line">				<span class="comment">//情况一：叔叔存在且为红</span></span><br><span class="line">				<span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;_col == RED)</span><br><span class="line">				&#123;</span><br><span class="line">					parent-&gt;_col = uncle-&gt;_col = BLACK;</span><br><span class="line">					grandfather-&gt;_col = RED;</span><br><span class="line"> </span><br><span class="line">					<span class="comment">//继续往上调整</span></span><br><span class="line">					cur = grandfather;</span><br><span class="line">					parent = grandfather-&gt;_parent;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//情况二+情况三：叔叔不存在或叔叔存在且为黑</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//情况二：单旋</span></span><br><span class="line">					<span class="keyword">if</span> (cur == parent-&gt;_right)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">RotateL</span>(grandfather);</span><br><span class="line">						parent-&gt;_col = BLACK;</span><br><span class="line">						grandfather-&gt;_col = RED;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span><span class="comment">//情况三：双旋</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">RotateR</span>(parent);</span><br><span class="line">						<span class="built_in">RotateL</span>(grandfather);</span><br><span class="line">						cur-&gt;_col = BLACK;</span><br><span class="line">						grandfather-&gt;_col = RED;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//插入结束</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line">		_root-&gt;_col = BLACK;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">make_pair</span>(newNode, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RotateR</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* subL = parent-&gt;_left;</span><br><span class="line">		Node* subLR = <span class="literal">nullptr</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (subL)</span><br><span class="line">		&#123;</span><br><span class="line">			subLR = subL-&gt;_right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//1.左子树的右子树变我的左子树</span></span><br><span class="line">		parent-&gt;_left = subLR;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (subLR)</span><br><span class="line">		&#123;</span><br><span class="line">			subLR-&gt;_parent = parent;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//左子树变父亲</span></span><br><span class="line">		subL-&gt;_right = parent;</span><br><span class="line">		Node* parentParent = parent-&gt;_parent;</span><br><span class="line">		parent-&gt;_parent = subL;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (parent == _root)<span class="comment">//parent是根</span></span><br><span class="line">		&#123;</span><br><span class="line">			_root = subL;</span><br><span class="line">			_root-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//parent不是根，是子树</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (parentParent-&gt;_left == parent)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//parent是自己父亲的左子树,将subL作为parent父亲的左孩子</span></span><br><span class="line">				parentParent-&gt;_left = subL;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//parent是自己父亲的右子树,将subL作为parent父亲的右孩子</span></span><br><span class="line">				parentParent-&gt;_right = subL;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//subL的父亲就是parent的父亲</span></span><br><span class="line">			subL-&gt;_parent = parentParent;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">RotateL</span><span class="params">(Node* parent)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Node* subR = parent-&gt;_right;</span><br><span class="line">		Node* subRL = <span class="literal">nullptr</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (subR)</span><br><span class="line">		&#123;</span><br><span class="line">			subRL = subR-&gt;_left;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//1.右子树的左子树变我的右子树</span></span><br><span class="line">		parent-&gt;_right = subRL;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (subRL)</span><br><span class="line">		&#123;</span><br><span class="line">			subRL-&gt;_parent = parent;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//2.右子树变父亲</span></span><br><span class="line">		subR-&gt;_left = parent;</span><br><span class="line">		Node* parentParent = parent-&gt;_parent;</span><br><span class="line">		parent-&gt;_parent = subR;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (parent == _root)<span class="comment">//parent是根</span></span><br><span class="line">		&#123;</span><br><span class="line">			_root = parent;</span><br><span class="line">			_root-&gt;_parent = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//parent不是根，是子树</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (parentParent-&gt;_left == parent)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//parent是自己父亲的左子树,将subR作为parent父亲的左孩子</span></span><br><span class="line">				parentParent-&gt;_left = subR;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//parent是自己父亲的右子树,将subR作为parent父亲的右孩子</span></span><br><span class="line">				parentParent-&gt;_right = subR;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//subR的父亲就是parent的父亲</span></span><br><span class="line">			subR-&gt;_parent = parentParent;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//查找</span></span><br><span class="line">	<span class="function">Node* <span class="title">Find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		KeyOfT kot;</span><br><span class="line">		Node* cur = _root;</span><br><span class="line">		<span class="keyword">while</span> (cur)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &lt; key)</span><br><span class="line">			&#123;</span><br><span class="line">				cur = cur-&gt;_right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">kot</span>(cur-&gt;_data) &gt; key)</span><br><span class="line">			&#123;</span><br><span class="line">				cur = cur-&gt;_left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> cur;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">//空树，直接返回</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="type">bool</span> _CheckBalance(Node* root, <span class="type">int</span> blackNum, <span class="type">int</span> count)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (count != blackNum)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;黑色节点数量不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (root-&gt;_col == RED &amp;&amp; root-&gt;_parent-&gt;_col == RED)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;存在连续红色节点&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (root-&gt;_col == BLACK)</span><br><span class="line">		&#123;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">return</span> _CheckBalance(root-&gt;_left, blackNum, count)</span><br><span class="line">			&amp;&amp; _CheckBalance(root-&gt;_right, blackNum, count);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//检查是否平衡</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">CheckBalance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (_root-&gt;_col == RED)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;根节点为红色&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//找最左路径做黑色节点数量参考值</span></span><br><span class="line">		<span class="type">int</span> blackNum = <span class="number">0</span>;</span><br><span class="line">		Node* left = _root;</span><br><span class="line">		<span class="keyword">while</span> (left)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (left-&gt;_col == BLACK)</span><br><span class="line">			&#123;</span><br><span class="line">				blackNum++;</span><br><span class="line">			&#125;</span><br><span class="line">			left = left-&gt;_left;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> _CheckBalance(_root, blackNum, count);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	<span class="type">void</span> _InOrder(Node* root)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		_InOrder(root-&gt;_left);</span><br><span class="line">		cout &lt;&lt; root-&gt;_kv.first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; root-&gt;_kv.second &lt;&lt; endl;</span><br><span class="line">		_InOrder(root-&gt;_right);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_InOrder(_root);</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node* _root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="七、验证代码"><a href="#七、验证代码" class="headerlink" title="七、验证代码"></a>七、验证代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RBTree.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Set.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delia::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">3</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">9</span>, <span class="number">9</span>));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	delia::set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">13</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">18</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	delia::set&lt;<span class="type">int</span>&gt;::iterator sit = s.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span> (sit != s.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *sit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		++sit;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/13/TcpIP%E5%8D%8F%E8%AE%AE%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/</url>
    <content><![CDATA[<h1 id="Tcp-x2F-IP协议三次握手的必要性"><a href="#Tcp-x2F-IP协议三次握手的必要性" class="headerlink" title="Tcp&#x2F;IP协议三次握手的必要性"></a>Tcp&#x2F;IP协议三次握手的必要性</h1><span id="more"></span>

<p>TCP&#x2F;IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接，如下图所示。</p>
<p><img src="D:\Blog\host_source\Snipaste_2023-06-13_21-54-38.png"></p>
<p>主机A为客户机，主机B为服务器</p>
<p>确认号：其数值等于发送方的发送序号 +1(即接收方期望接收的下一个序列号)。</p>
<p>说明：</p>
<p>（1）第一次握手：建立连接时，客户端A发送SYN包（SYN&#x3D;j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。</p>
<p>（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK&#x3D;j+1），同时自己也发送一个SYN包（SYN&#x3D;k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。</p>
<p>（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK&#x3D;k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</p>
<p>必要性：</p>
<p>这两天一直在考虑一个问题，就是两者为何要三次握手呢，一次或者两次不行吗</p>
<p>考虑一次的问题，首先tcp是面向连接，一次握手肯定建立不了连接，因为客户机给服务器发出请求信息却没有得到回应，客户机是没法判定是否发送成功然后建立连接的。</p>
<p>再看两次，假设只有两次握手，比如图中的1，2步，当A想要建立连接时发送一个SYN，然后等待ACK，结果这个SYN因为网络问题没有及时到达B，所以A在一段时间内没收到ACK后，再发送一个SYN，这次B顺利收到，接着A也收到ACK，这时A发送的第一个SYN终于到了B，对于B来说这是一个新连接请求，然后B又为这个连接申请资源，返回ACK，然而这个SYN是个无效的请求，A收到这个SYN的ACK后也并不会理会它，而B却不知道，B会一直为这个连接维持着资源，造成资源的浪费。</p>
<p>三次连接就没毛病了？？是的</p>
<p>两次握手的问题在于服务器端不知道一个SYN是否是无效的，而三次握手机制因为客户端会给服务器回复第二次握手，也意味着服务器会等待客户端的第三次握手，如果第三次握手迟迟不来，服务器便会认为这个SYN是无效的，释放相关资源。但这时有个问题就是客户端完成第二次握手便认为连接已建立，而第三次握手可能在传输中丢失，服务端会认为连接是无效的，这时如果Client端向Server写数据，Server端将以RST包响应，这时便感知到Server的错误。</p>
<p>总之，三次握手可以保证任何一次握手的失败都是可感知的，不会浪费资源</p>
<p>三次握手出现错误时的应对措施<br>     第一次握手A发送SYN传输失败，A,B都不会申请资源，连接失败。如果一段时间内发出多个SYN连接请求，那么A只会接受它最后发送的那个SYN的SYN+ACK回应，忽略其他回应全部回应，B中多申请的资源也会释放</p>
<p> 第二次握手B发送SYN+ACK传输失败，A不会申请资源，B申请了资源，但收不到A的ACK，过一段时间释放资源。如果是收到了多个A的SYN请求，B都会回复SYN+ACK，但A只会承认其中它最早发送的那个SYN的回应，并回复最后一次握手的ACK</p>
<p> 第三次握手ACK传输失败，B没有收到ACK，释放资源，对于后序的A的传输数据返回RST。实际上B会因为没有收到A的ACK会多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到A的ACK，则释放资源，对A的数据传输返回RST</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/07/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>一篇文章彻底搞懂回调函数</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/30/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%EF%BC%9A/</url>
    <content><![CDATA[<h1 id="函数对象的初步了解："><a href="#函数对象的初步了解：" class="headerlink" title="函数对象的初步了解："></a>函数对象的初步了解：</h1><span id="more"></span>

<h2 id="第一："><a href="#第一：" class="headerlink" title="第一："></a>第一：</h2><p>list 的sort 函数直接调用， 可以把list 从小到大进行一个排序，</p>
<p>如果我们现在的需求是将list 从大到小进行一个排序</p>
<p>看源码我们知道 sort 函数的参数是一个Compare comp，是一个对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::list &lt;T,Allocator&gt;::<span class="function">sort</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Compare</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>Compare  本质是把两个数进行了比较，是一个类型，</strong></p>
<p><strong>comp 是一个对象，</strong></p>
<p><img src="C:\Users\15183\AppData\Roaming\Typora\typora-user-images\image-20230730154149527.png" alt="image-20230730154149527"></p>
<p>而且在set 中也会从小到大的顺序进行排序</p>
<p>看set 的源码，我们知道了class Compare 的本质。</p>
<p><img src="C:\Users\15183\AppData\Roaming\Typora\typora-user-images\image-20230730154320927.png" alt="image-20230730154320927"></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Compare</span> = <span class="symbol">std::<span class="symbol">less</span></span>&lt;<span class="symbol">key</span>&gt;</span><br></pre></td></tr></table></figure>

<p>然而std::less<key> 是一个struct 是一个类，</p>
<ul>
<li><input disabled="" type="checkbox"> <a href=""><strong>这个类重载了函数调用运算符（），那么重载了函数调用运算符的类 与小括号进行结合 ，可以体现函数的特性，称为函数对象</strong></a>！！！！！</li>
</ul>
<p><img src="C:\Users\15183\AppData\Roaming\Typora\typora-user-images\image-20230730154518867.png" alt="image-20230730154518867"></p>
<p>那么就表明</p>
<p>sort 底层就是可能调用的是std::less</p>
<p>sort函数的参数</p>
<p>void sort （Compare comp）Compare是一个类型，但是comp是一个对象，</p>
<p>并且没有添加引用，</p>
<p>list.sort(<strong>std::less<int>(</strong>));</p>
<p><strong>std::less<int>(),是一个函数对象</strong></p>
<p>如果我们要满足刚开始的需求</p>
<p>我么只需要 list.sort（std::greater<int>()）即可。</p>
<p>自己实现Compare：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> CompareList</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="built_in">int</span> &amp;lhs,<span class="keyword">const</span> <span class="built_in">int</span> &amp;rhs) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs &lt;rhs;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/25/%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h1>]]></content>
  </entry>
  <entry>
    <title>宏定义函数</title>
    <url>/2023/05/27/%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="宏定义函数是什么"><a href="#宏定义函数是什么" class="headerlink" title="# 宏定义函数是什么"></a># 宏定义函数是什么</h1><span id="more"></span>
<h2 id="为什么要使用宏定义函数"><a href="#为什么要使用宏定义函数" class="headerlink" title="## 为什么要使用宏定义函数"></a>## 为什么要使用宏定义函数</h2><p>在C程序中，可以用宏代码提高执行效率。宏代码本身不是函数，但使用起来象函数。<br>预处理器用复制宏代码的方式代替函数调用，省去了参数压栈、生成汇编语言的CALL调用、<br>返回参数、执行return等过程，从而提高了速度。 （避免函数调用，提高程序效率）<br>使用宏代码最大的缺点是容易出错，预处理器在复制宏代码时常常产生意想不到的边际效应。</p>
<h2 id="什么是宏"><a href="#什么是宏" class="headerlink" title="## 什么是宏"></a>## 什么是宏</h2><p>它是一种预处理器指令，在预编译阶段将宏名替换为后面的替换体 </p>
<h2 id="如何使用宏"><a href="#如何使用宏" class="headerlink" title="## 如何使用宏"></a>## 如何使用宏</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>       MAx             960</span></span><br><span class="line">预处理指令		宏名       	替换体(多行可用 \ 延续) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="不带参数的宏"><a href="#不带参数的宏" class="headerlink" title="## 不带参数的宏"></a>## 不带参数的宏</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _width 1024 <span class="comment">//宏命名规则同变量名 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDR <span class="string">&quot;中华人民共和国河南省&quot;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;width: %d\n&quot;</span>, _width); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;我的祖籍： %s\n&quot;</span>, ADDR);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">width: <span class="number">1024</span></span><br><span class="line">我的祖籍： 中华人民共和国河南省</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="带参数的宏（不是真正的参数）"><a href="#带参数的宏（不是真正的参数）" class="headerlink" title="## 带参数的宏（不是真正的参数）"></a>## 带参数的宏（不是真正的参数）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) x*x  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> j = SQUARE(i); <span class="comment">// 宏展开 j = i*i;</span></span><br><span class="line">	<span class="type">int</span> k = SQUARE(<span class="number">8</span> + <span class="number">2</span>); <span class="comment">// 宏展开 8+2*8+2</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;j: %d\n&quot;</span>, j);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;k: %d\n&quot;</span>, k);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">j: <span class="number">100</span></span><br><span class="line">k: <span class="number">26</span></span><br></pre></td></tr></table></figure>
<p>毋庸置疑，j &#x3D; 100；但 k &#x3D; 26，为啥？<br>宏只是一个替换，不会自动加括号，非常死板！<br>解决方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x)*(x))  </span></span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="## 原理"></a>## 原理</h2><p>这里可以知道，使用宏比调用函数更加高效。因为，使用宏就像使用头文件一样，就比如使用&lt;string.h&gt;，使用头文件&lt;string.h&gt;进行预编译之后，直接可以使用字符串进行定义使用；宏也是如此，在定义宏之后，编译器直接进行了预编译，这时候调用它，就是直接进行替换。</p>
<p>而调用其他函数时，要给他在内存中单独分配空间，普通变量分布在栈区，动态内存分布在堆区，静态变量在全局数据区（全局数据区也包括全局变量），字符常量在常量区，二进制指令（也就是函数体）分布在代码区。执行这个函数时，要获取被调用函数指定的地址（被调用函数的地址有一个范围，起始地址就是函数的入口地址，被调用函数从起始地址开始一步步往下执行），之后程序会跳转到被调函数的第一条语句，一步步往下依次执行被调函数中的语句，直到函数执行结束。</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="## Tips"></a>## Tips</h2><p>如果宏函数与函数名称相同，优先使用宏定义函数<br>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// div function prototype</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">div</span><span class="params">(<span class="type">float</span>, <span class="type">float</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> div(x, y) x / y</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// use of macro div</span></span><br><span class="line"><span class="comment">// Note: %0.2f for taking two decimal value after point</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%0.2f&quot;</span>, div(<span class="number">10.0</span>, <span class="number">5.0</span>));</span><br><span class="line"><span class="comment">// removing defined macro div</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> div</span></span><br><span class="line"><span class="comment">// function div is called as macro definition is removed</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n%0.2f&quot;</span>, div(<span class="number">10.0</span>, <span class="number">5.0</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// div function definition</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">div</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span> &#123; <span class="keyword">return</span> y / x; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2.00</span></span><br><span class="line"><span class="number">0.50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/29/%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9A/</url>
    <content><![CDATA[<p>引用和指针的联系和区别：</p>
<p>new&#x2F;delete 和mallco&#x2F;free的区别：</p>
<p>const常量和宏定义常量有什么区别：</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/07/%E6%89%8B%E5%86%99%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>手写单例模式</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/08/06/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/07/25/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h1 id="空间配置器源码剖析"><a href="#空间配置器源码剖析" class="headerlink" title="空间配置器源码剖析"></a>空间配置器源码剖析</h1>]]></content>
  </entry>
  <entry>
    <title>约瑟夫环问题</title>
    <url>/2023/05/27/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="约瑟夫环问题的三种解决方法"><a href="#约瑟夫环问题的三种解决方法" class="headerlink" title="约瑟夫环问题的三种解决方法"></a>约瑟夫环问题的三种解决方法</h1><span id="more"></span>
<h2 id="什么是约瑟夫环问题："><a href="#什么是约瑟夫环问题：" class="headerlink" title="什么是约瑟夫环问题："></a>什么是约瑟夫环问题：</h2><p>约瑟夫环问题在不同平台被”优化”描述的不一样，例如在牛客剑指offer叫孩子们的游戏，还有叫杀人游戏，点名……最直接的感觉还是力扣上剑指offer62的描述：<a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">圆圈中最后剩下的数字</a><br>问题描述：<br><em>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。<br>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</em></p>
<h2 id="列表循环模拟："><a href="#列表循环模拟：" class="headerlink" title="列表循环模拟："></a>列表循环模拟：</h2><p>这个问题最本质其实就是循环链表的问题，围成一个圈之后，就没有结尾这就是一个典型的循环链表嘛！一个一个顺序报数，那不就是链表的遍历枚举嘛！数到对应数字的出列，这不就是循环链表的删除嘛！</p>
<p><img src="https://img-blog.csdnimg.cn/b2ac040659104763b4dbf006bf0733a6.jpeg#pic_center" alt="在这里插入图片描述"><br>并且这里还有非常方便的地方：</p>
<p>循环链表的向下枚举不需要考虑头尾问题，直接node&#x3D;node.next向下<br>循环聊表的删除也不需要考虑头尾问题，直接node.next&#x3D;node.next.next删除<br>当然也有一些需要注意的地方</p>
<p>形成环形链表很简单，只需要将普通链表的最后一个节点的next指向第一个节点即可</p>
<p>循环链表中只有一个节点的时候停止返回，即node.next&#x3D;node的时候</p>
<p>删除，需要找到待删除的前面节点，所以我们删除计数的时候要少即一位，利用前面的那个节点直接删除后面节点即可</p>
<p>这样，思路明确，直接开撸代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">node</span>//链表节点</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        public <span class="title function_">node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            this.val=value;</span><br><span class="line">        &#125;</span><br><span class="line">        node next;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>)<span class="keyword">return</span> n<span class="number">-1</span>;<span class="comment">//一次一个直接返回最后一个即可</span></span><br><span class="line">        node head=new node(<span class="number">0</span>);</span><br><span class="line">        node team=head;<span class="comment">//创建一个链表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            team.next=new node(i);</span><br><span class="line">            team=team.next;</span><br><span class="line">        &#125;</span><br><span class="line">        team.next=head;<span class="comment">//使形成环</span></span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;<span class="comment">//从0开始计数</span></span><br><span class="line">        <span class="keyword">while</span> (head.next!=head) &#123;<span class="comment">//当剩余节点不止一个的时候</span></span><br><span class="line">            <span class="comment">//如果index=m-2 那就说明下个节点(m-1)该删除了</span></span><br><span class="line">            <span class="keyword">if</span>(index==m<span class="number">-2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                head.next=head.next.next;</span><br><span class="line">                index=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>当然，这种算法太复杂了，大部分的OJ你提交上去是无法AC的，因为超时太严重了，具体的我们可以下面分析。</em></p>
<p>有序集合模拟<br>上面使用链表直接模拟游戏过程会造成非常严重非常严重的超时，n个数字，数到第m个出列。因为m如果非常大远远大于m，那么将进行很多次转圈圈。<br><img src="https://img-blog.csdnimg.cn/791ba2974e314ff789200f4f9cd74a9b.jpeg#pic_center" alt="在这里插入图片描述"><br>所以我们可以利用求余的方法判断等价最低的枚举次数，然后将其删除即可，在这里你可以继续使用自建链表去模拟，上面的while循环以及上面只需添加一个记录长度的每次求余算圈数即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> len=n;</span><br><span class="line"><span class="keyword">while</span> (head.next!=head) &#123;</span><br><span class="line">  <span class="keyword">if</span>(index==(m<span class="number">-2</span>)%len)</span><br><span class="line">  &#123;</span><br><span class="line">    head.next=head.next.next;</span><br><span class="line">    index=<span class="number">0</span>;</span><br><span class="line">    len--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  head=head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但我们很多时候不会手动去写一个链表模拟，我们会借助ArrayList和LinkedList去模拟，如果使用LinkedList其底层也是链表，使用ArrayList的话其底层数据结构是数组。不过在使用List其代码方法一致。</p>
<p>List可以直接知道长度，也可删除元素，<strong>使用List的难点是一个顺序表怎们模拟成循环链表</strong>？</p>
<p>咱们仔细思考：假设当前长度为n，数到第m个(通过上面分析可以求余让这个有效的m不大于n)删除，在index位置删除。那么删除后剩下的就是n-1长度，index位置就是表示第一个计数的位置，我们可以通过求余得知走下一个删除需要多少步，那么下个位置怎么确定呢？<br><img src="https://img-blog.csdnimg.cn/f6138318abf54b05840cd303aa20fdc0.png#pic_center" alt="在这里插入图片描述"><br>你可以分类讨论看看走的次数是否越界，但这里有更巧妙的方法，可以直接求的下一次具体的位置，公式就是为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">index=(index+m<span class="number">-1</span>)%(<span class="built_in">list</span>.size());</span><br></pre></td></tr></table></figure>
<p>因为index是从1计数，如果是循环的再往前m-1个就是真正的位置，但是这里可以先假设先将这个有序集合的长度扩大若干倍，然后从index计数开始找到假设不循环的位置index2，最后我们将这个位置index2%(集合长度)即为真正的长度。<br><img src="https://img-blog.csdnimg.cn/673d28e52163462fa09d9f675ddecf62.png#pic_center" alt="在这里插入图片描述"><br>使用这个公式一举几得，既能把上面m过大循环过多的情况解决，又能找到真实的位置，就是将这个环先假设成线性的然后再去找到真的位置，如果不理解的话可以再看看这个图：<br><img src="https://img-blog.csdnimg.cn/213423c21fa54ef6b1d6e3d19bce7834.png#pic_center" alt="在这里插入图片描述"><br>这种情况的话大部分的OJ是可以勉强过关的，面试官的层面也大概率差不多的，具体代码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    public <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">        List&lt;Integer&gt;<span class="built_in">list</span>=new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">list</span>.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">list</span>.size()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index=(index+m<span class="number">-1</span>)%(<span class="built_in">list</span>.size());</span><br><span class="line">            <span class="built_in">list</span>.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="递归公式解决"><a href="#递归公式解决" class="headerlink" title="递归公式解决"></a>递归公式解决</h2><p>我们回顾上面的优化过程，上面用求余可以解决m比n大很多很多的情况(即理论上需要转很多很多圈的情况)。但是还可能存在n本身就很大的情况，无论是顺序表ArrayList还是链表LinkedList去频繁查询、删除都是很低效的。</p>
<p>所以聪明的人就开始从数据找一些规律或者关系。</p>
<p>先抛出公式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f(n,m)=(f(n<span class="number">-1</span>,m)+m)%n</span><br><span class="line">f(n,m)指n个人，报第m个编号出列最终编号</span><br></pre></td></tr></table></figure>
<p>下面要认真看一下我的分析过程：</p>
<p>我们举个例子，有0 1 2 3 4 5 6 7 8 9十个数字，假设m为3,最后结果可以先记成f(10,3)，即使我们不知道它是多少。</p>
<p>当进行第一次时候，找到元素2 删除，此时还剩9个元素，但起始位置已经变成元素3。等价成3 4 5 6 7 8 9 0 1这9个数字重写开始找。<br><img src="https://img-blog.csdnimg.cn/f84f057489844f3d82f7bc45bcb67d62.png#pic_center" alt="在这里插入图片描述"></p>
<p>此时这个序列最终剩下的一个值即为f(10,3)，这个序列的值和f(9,3)不同，但是都是9个数且m等于3，所以其删除位置是相同的，即算法大体流程是一致的，只是各位置上的数字不一样。所以我们需要做的事情是找找这个序列上和f(9,3)值上有没有什么联系。</p>
<p>寻找过程中别忘记两点，首先可通过**%符号**对数字有效扩充，即我们可以将3 4 5 6 7 8 9 0 1这个序列看成(3,4,5,6,7,8,9,10,11)%10.这里的10即为此时的n数值。</p>
<p>另外数值如果是连续的，那么最终一个结果的话是可以找到联系的(差值为一个定制)。所以我们可以就找到f(10,3)和f(9,3)值之间结果的关系，可以看下图：<br><img src="https://img-blog.csdnimg.cn/fd5c2d8029aa44849d3f908571635ae0.png#pic_center" alt="在这里插入图片描述"><br>所以f(10,3)的结果就可以转化为f(9,3)的表达,后面也是同理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f(<span class="number">10</span>,<span class="number">3</span>)=(f(<span class="number">9</span>,<span class="number">3</span>)+<span class="number">3</span>)%<span class="number">10</span></span><br><span class="line">f(<span class="number">9</span>,<span class="number">3</span>)=(f(<span class="number">8</span>,<span class="number">3</span>)+<span class="number">3</span>)%<span class="number">9</span></span><br><span class="line">……</span><br><span class="line">f(<span class="number">2</span>,<span class="number">3</span>)=(f(<span class="number">1</span>,<span class="number">3</span>)+<span class="number">3</span>)%<span class="number">2</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">3</span>)=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这样，我们就不用模拟操作，可以直接从数值的关系找到递推的关系，可以轻轻松松的写下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    public <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;      </span><br><span class="line">        <span class="keyword">return</span> (lastRemaining(n<span class="number">-1</span>,m)+m)%n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是递归效率因为有个来回的规程，效率相比直接迭代差一些，也可从前往后迭代：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    public <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> value=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                value=(value+m)%i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>我想，通过本篇文章你应该掌握和理解了约瑟夫环问题，这种裸的约瑟夫环问题出现的概率很大，考察很频繁，链表模拟是根本思想，有序集合模拟链表是提升，而公式递推才是最有学习价值的地方，如果你刚开始接触不理解可以多看几遍。如果能用公式递推给面试官说两句，讲讲原理，那一定会让面试官眼前一亮的</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/18/%E7%BA%BF%E6%80%A7%E8%A1%A8+%E5%93%88%E5%B8%8C%E8%A1%A8LRU%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>title:线性表+哈希表&gt;&gt;LRU算法</p>
<span id="more"></span>

<h1 id="线性表-哈希表-gt-gt-LRU算法"><a href="#线性表-哈希表-gt-gt-LRU算法" class="headerlink" title="线性表+哈希表&gt;&gt;LRU算法"></a>线性表+哈希表&gt;&gt;LRU算法</h1><h2 id="方法：哈希表-双向链表"><a href="#方法：哈希表-双向链表" class="headerlink" title="方法：哈希表 + 双向链表"></a>方法：哈希表 + 双向链表</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p>
<p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p>
<p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p>
<p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)O(1)O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LRU::get</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 get 操作，首先判断 key 是否存在：</p>
<p>如果 key 不存在，则返回 −1；</p>
<p>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p>
<p>对于 put 操作，首先判断 key 是否存在：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRU::put</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</p>
<p>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</p>
<p>上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)时间内完成。</p>
<h3 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h3><p>在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：对于 put 和 get 都是 O(1)。</p>
<p>空间复杂度：O(capacity)O(\text{capacity})O(capacity)，因为哈希表和双向链表最多存储 capacity+1\text{capacity} + 1capacity+1 个元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRU</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRU</span>(<span class="type">int</span> cap)</span><br><span class="line">    :_capacity(cap)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;LRU(int cap)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cacheNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cacheNode</span>(<span class="type">int</span> key,<span class="type">int</span> v)</span><br><span class="line">        :_key(key)</span><br><span class="line">        ,_value(v)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;cacheNode(int key,int v)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> _key;</span><br><span class="line">        <span class="type">int</span> _value;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    list&lt;cacheNode&gt; _nodes;<span class="comment">//双向链表存，</span></span><br><span class="line">    <span class="type">int</span> _capacity;<span class="comment">//缓存的大小</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,list&lt;cacheNode&gt;::iterator &gt; _cache;<span class="comment">//无序map ，</span></span><br><span class="line">    <span class="comment">//存放的是 key值，和链表的迭代器</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LRU::get</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO 判断key值是否在map中，如果存在，直接把他</span></span><br><span class="line">    <span class="comment">//更新在链表的头，并且返回他的value,不存在则返回-1；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> it = _cache.<span class="built_in">find</span>(key);<span class="comment">//unordered_map 的 find 函数返回值为</span></span><br><span class="line">                            <span class="comment">// 该key值所对应的迭代器</span></span><br><span class="line">    <span class="keyword">if</span>(it!=_cache.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        _nodes.<span class="built_in">splice</span>(_nodes.<span class="built_in">begin</span>(),_nodes,it-&gt;second);</span><br><span class="line">        <span class="comment">//链表的splice 函数可以将 _nodes链表中的 it-&gt;second所指向的元素</span></span><br><span class="line">        <span class="comment">//转移到_nodes.begin()的前面</span></span><br><span class="line">        <span class="keyword">return</span> it-&gt;second-&gt;_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRU::put</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//TODO 判断key 是否存在，如果存在那么，直接放在链表表头</span></span><br><span class="line">    <span class="comment">//如果不存在则判断链表是不是满的，如果满了删除末尾元素</span></span><br><span class="line">    <span class="comment">//然后在链表头插入，并且插入到map中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> it = _cache.<span class="built_in">find</span>(key); </span><br><span class="line">    <span class="keyword">if</span>(it!=_cache.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        it-&gt;second-&gt;_value= value;</span><br><span class="line">        _nodes.<span class="built_in">splice</span>(_nodes.<span class="built_in">begin</span>(),_nodes,it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="type">int</span>)_nodes.<span class="built_in">size</span>()==_capacity)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;deleteNode = _nodes.<span class="built_in">back</span>();</span><br><span class="line">            _cache.<span class="built_in">erase</span>(deleteNode._key);<span class="comment">//unordered_map 的 earse操作</span></span><br><span class="line">                                        <span class="comment">// size_type earse(const key_type&amp;key);</span></span><br><span class="line">            _nodes.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _nodes.<span class="built_in">push_front</span>(<span class="built_in">cacheNode</span>(key,value));</span><br><span class="line">        _cache.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(key,_nodes.<span class="built_in">begin</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test0</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function">LRU <span class="title">lru</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    lru.<span class="built_in">put</span>(<span class="number">1</span>,<span class="number">88</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get(1)&quot;</span> &lt;&lt; lru.<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    lru.<span class="built_in">put</span>(<span class="number">3</span>,<span class="number">99</span>);</span><br><span class="line">    lru.<span class="built_in">put</span>(<span class="number">4</span>,<span class="number">77</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get(1)&quot;</span> &lt;&lt; lru.<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">test0</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Struct</title>
    <url>/2023/05/25/%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p> 结构体(struct)是由一系列具有相同类型或不同类型的数据构成的数据集合，也叫结构。</p>
<span id="more"></span>
<p>结构体和其他类型基础数据类型一样，例如int类型，char类型只不过结构体可以做成你想要的数据类型。以方便日后的使用。</p>
<p>在实际项目中，结构体是大量存在的。研发人员常使用结构体来封装一些属性来组成新的类型。由于C语言无法操作数据库，所以在项目中通过对结构体内部变量的操作将大量的数据存储在内存中，以完成对数据的存储和操作。在实际问题中有时候我们需要几种数据类型一起来修饰某个变量。例如一个学生的信息就需要学号（字符串），姓名（字符串），年龄（整形）等等。这些数据类型都不同但是他们又是表示一个整体，要存在联系，那么我们就需要一个新的数据类型。——结构体，它就将不同类型的数据存放在一起，作为一个整体进行处理。结构体在函数中的作用不是简便，其最主要的作用就是封装。封装的好处就是可以再次利用。让使用者不必关心这个是什么，只要根据定义使用就可以了。结构体的大小不是结构体元素单纯相加就行的，因为我们现在主流的计算机使用的都是32Bit字长的CPU，对这类型的CPU取4个字节的数要比取一个字节要高效，也更方便。所以在结构体中每个成员的首地址都是4的整数倍的话，取数据元素时就会相对更高效，这就是内存对齐的由来。每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。程序员可以通过预编译命令#pragmapack(n)，n&#x3D;1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。</p>
<p><strong>规则</strong></p>
<p>1、数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragmapack指定的数值和这个数据成员自身长度中，比较小的那个进行。</p>
<p>2、结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragmapack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。</p>
<p>3、结合1、2可推断：当#pragmapack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。</p>
<p>在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private。</p>
<p><strong>结构体的声明：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stu</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//结构体成员</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">10</span>];</span><br><span class="line">	<span class="type">char</span> tele[<span class="number">12</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这个声明描述了一个由三个字符数组和一个int变量组成的结构体。但是注意，它并没有创建一个实际的数据对象，而是描述了一个组成这类对象的元素。因此，我们有时候也将结构体声明叫做模板，因为它勾勒出数据该如何存储，并没有实例化数据对象。</p>
<p>下面介绍一下上面的结构体声明：</p>
<p>1、首先使用关键字struct，它表示接下来是一个结构体。</p>
<p>2、后面是一个可选的标志（book），它是用来引用该结构体的快速标记。因此我们以后就可以这样创建数据对象</p>
<p>struct book library；&#x2F;&#x2F;把library设为一个可以使用book结构体的结构体变量，则library这个变量就包含了其book结构体中的所有元素</p>
<p>3、接下来就是一个花括号，括起了结构体成员列表，及每个成员变量，使用的都是其自己的声明方式来描述，用分号来结束描述；</p>
<p>例如：char name[20];字符数组就是这样声明的，用分号结束；</p>
<p>注意：其中每个成员可以使用任何一种C数据结构甚至是其他的结构体，也是可以的；</p>
<p>4、在结束花括号后的分号表示结构体设计定义的结束。</p>
<p>关于其struct声明的位置，也就是这段代码要放到哪里。同样这也是具有作用域的。</p>
<p>这种声明如果放在任何函数的外面，那么则可选标记可以在本文件中，该声明的后面的所有函数都可以使用。</p>
<p>如果这种声明在某个函数的内部，则它的标记只能在内部使用，并且在其声明之后；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个结构体，值得注意的是如果main函数在结构体前面会报错，这个可以自己试一下！1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stu</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//结构体成员</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> sex[<span class="number">10</span>];</span><br><span class="line">	<span class="type">char</span> tele[<span class="number">12</span>];</span><br><span class="line">&#125;;<span class="comment">//分号不能少这相当于一条语句</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Stu</span> s = &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>, <span class="string">&quot;nan&quot;</span>, <span class="string">&quot;18338064521&quot;</span> &#125;;<span class="comment">//对结构体初始化</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s %d %s %s\n&quot;</span>, s.name, s.age,s.sex, s.tele);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>C语言结构体定义的三种方式</p>
<p>1、最标准的方式:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> <span class="comment">//结构体类型的说明与定义分开。声明</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> age;  <span class="comment">/*年龄*/</span></span><br><span class="line"><span class="type">float</span> score; <span class="comment">/*分数*/</span></span><br><span class="line"><span class="type">char</span> sex;   <span class="comment">/*性别*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> a=&#123; <span class="number">20</span>,<span class="number">79</span>,<span class="string">&#x27;f&#x27;</span>&#125;; <span class="comment">//定义</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;年龄：%d 分数：%.2f 性别：%c\n&quot;</span>, a.age, a.score, a.sex );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>2、不环保的方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> <span class="comment">/*声明时直接定义*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> age;  <span class="comment">/*年龄*/</span></span><br><span class="line"><span class="type">float</span> score;  <span class="comment">/*分数*/</span></span><br><span class="line"><span class="type">char</span> sex;   <span class="comment">/*性别*/</span></span><br><span class="line"><span class="comment">/*这种方式不环保，只能用一次*/</span></span><br><span class="line">&#125; a=&#123;<span class="number">21</span>,<span class="number">80</span>,<span class="string">&#x27;n&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;年龄：%d 分数：%.2f 性别：%c\n&quot;</span>, a.age, a.score, a.sex );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>3、最奈何人的方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span>   <span class="comment">//直接定义结构体变量，没有结构体类型名。这种方式最烂</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">float</span> score;</span><br><span class="line"><span class="type">char</span> sex;</span><br><span class="line">&#125; t=&#123;<span class="number">21</span>,<span class="number">79</span>,<span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;年龄：%d 分数：%f 性别：%c\n&quot;</span>, t.age, t.score, t.sex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>定义结构体变量</strong></p>
<p>之前我们结构体类型的定义（结构体的声明）只是告诉编译器该如何表示数据，但是它没有让计算机为其分配空间。</p>
<p>我们要使用结构体，那么就需要创建变量，也就是结构体变量；</p>
<p>创建一个结构体变量；</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> book library；</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>看到这条指令，编译器才会创建一个结构体变量library，此时编译器才会按照book模板为该变量分配内存空间，并且这里存储空间都是以这个变量结合在一起的。</p>
<p>这也是后面访问结构体变量成员的时候，我们就要用到结构体变量名来访问。</p>
<p>struct book的作用：</p>
<p>在结构体声明中，struct book所起到的作用就像int，，，，等基础数据类型名作用一样。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> book s1，s2，*ss；</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>定义两个struct book结构体类型的结构体变量，还定义了一个指向该结构体的指针，其ss指针可以指向s1，s2，或者任何其他的book结构体变量。</p>
<p>其实；</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> book library；</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>等效于；</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> book&#123; <span class="built_in">char</span> … …. ….. &#125;librar；</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这两种是等效的，只是第一种可以减少代码的编写量；</p>
<p>其一；</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123; <span class="built_in">char</span> title[MAXTITL]; <span class="built_in">char</span> author[MAXAUTL];<span class="built_in">float</span> <span class="keyword">value</span>；&#125;library;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>&#x2F;&#x2F;注意这里不再是定义声明结构体类型，而是直接创建结构体变量了，这个编译器会分配内存的；</p>
<p>&#x2F;&#x2F;这样的确可以省略标识符也就是结构体名，但是只能使用一次；因为这是；声明结构体的过程和定义结构体变量的过程和在了一起；并且个成员变量没有初始化的；</p>
<p>&#x2F;&#x2F;如果你想多次使用一个结构体模块，这样子是行不通的；</p>
<p>其二；</p>
<p>用typedef定义新类型名来代替已有类型名，即给已有类型重新命名；</p>
<p>一般格式为；typedef 已有类型 新类型名；</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">typedef <span class="built_in">int</span> Elem; typedef <span class="keyword">struct</span>&#123; <span class="built_in">int</span> date; ..... .....&#125;STUDENT;STUDENT stu1,stu2;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="https://img-blog.csdnimg.cn/11bfe77039374543b18a69240005e904.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p>
<p><strong>总结一下关于结构体变量的定义；</strong></p>
<p>1、先定义结构体类型后再定义结构体变量；</p>
<p>格式为；struct 结构体名 变量名列表；</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> book s1，s2，*ss；<span class="comment">//注意这种之前要先定义结构体类型后再定义变量；</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>2、在定义结构体类型的同时定义结构体变量；</p>
<p>格式为；</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名&#123;成员列表；&#125;变量名列表；<span class="comment">//这里结构体名是可以省的，但尽量别省；struct book&#123;char title[MAXTITL];//一个字符串表示的titile 题目 ；char author[MAXAUTL];//一个字符串表示的author作者 ；float value;//一个浮点型表示的value价格；&#125;s1，s2</span></span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>直接定义结构体类型变量，就是第二种中省略结构体名的情况；</p>
<p>这种方式不能指明结构体类型名而是直接定义结构体变量，并且在值定义一次结构体变量时适用，无结构体名的结构体类型是无法重复使用的。</p>
<p>也就是说，后面程序不能再定义此类型变量了，除非再写一次重复的struct。</p>
]]></content>
  </entry>
  <entry>
    <title>最大公约数</title>
    <url>/2023/05/27/%EF%BC%88gcd)%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
    <content><![CDATA[<p>#（gcd)最大公约数的三种求法</p>
<span id="more"></span>
<h2 id="第一种求法："><a href="#第一种求法：" class="headerlink" title="第一种求法："></a>第一种求法：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a == b)</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">if</span> (a &gt; b)</span><br><span class="line">		<span class="keyword">return</span> gcd(a, a - b);</span><br><span class="line">	<span class="keyword">if</span> (a &lt; b)</span><br><span class="line">		<span class="keyword">return</span> gcd(b, b - a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二种求法："><a href="#第二种求法：" class="headerlink" title="第二种求法："></a>第二种求法：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;<span class="comment">//默认a&gt;b!</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其实第二种方法的过程就是："><a href="#其实第二种方法的过程就是：" class="headerlink" title="其实第二种方法的过程就是："></a>其实第二种方法的过程就是：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">​```c</span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">		swao(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> r = a % b;</span><br><span class="line">		a = b;</span><br><span class="line">		b = r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
