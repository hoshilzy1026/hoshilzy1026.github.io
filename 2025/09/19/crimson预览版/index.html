<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-m.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-m.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hoshilzy1026.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="Crimson 是 Crimson OSD 的代码名称，它是下一代用于多核心可扩展性的 OSD 。它通过快速网络和存储设备提高性能，采用包括 DPDK 和 SPDK 的顶级技术。BlueStore 继续支持 HDD 和 SSD。Crimson 旨在与早期版本的 OSD 守护进程与类 Ceph OSD 兼容。 Crimson 基于 SeaStar C++ 框架构建，是核心 Ceph 对象存储守护进程">
<meta property="og:type" content="article">
<meta property="og:title" content="crmson预览版.md">
<meta property="og:url" content="https://hoshilzy1026.github.io/2025/09/19/crimson%E9%A2%84%E8%A7%88%E7%89%88/index.html">
<meta property="og:site_name" content="Hoshi">
<meta property="og:description" content="Crimson 是 Crimson OSD 的代码名称，它是下一代用于多核心可扩展性的 OSD 。它通过快速网络和存储设备提高性能，采用包括 DPDK 和 SPDK 的顶级技术。BlueStore 继续支持 HDD 和 SSD。Crimson 旨在与早期版本的 OSD 守护进程与类 Ceph OSD 兼容。 Crimson 基于 SeaStar C++ 框架构建，是核心 Ceph 对象存储守护进程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bugwz.com/assets/images/ceph-crimson-old-arch.png">
<meta property="og:image" content="https://bugwz.com/assets/images/ceph-crimson-new-arch.png">
<meta property="og:image" content="https://bugwz.com/assets/images/ceph-crimson-osd-pg-shard.png">
<meta property="article:published_time" content="2025-09-19T07:18:34.000Z">
<meta property="article:modified_time" content="2025-09-20T08:34:05.658Z">
<meta property="article:author" content="lzy">
<meta property="article:tag" content="Crimson">
<meta property="article:tag" content="Seastore">
<meta property="article:tag" content="异步编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bugwz.com/assets/images/ceph-crimson-old-arch.png">

<link rel="canonical" href="https://hoshilzy1026.github.io/2025/09/19/crimson%E9%A2%84%E8%A7%88%E7%89%88/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>crmson预览版.md | Hoshi</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y6XQ2TRE3Y"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-Y6XQ2TRE3Y');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hoshi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hoshilzy1026.github.io/2025/09/19/crimson%E9%A2%84%E8%A7%88%E7%89%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="lzy">
      <meta itemprop="description" content="选择有时候比努力更重要">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hoshi">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          crmson预览版.md
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-19 15:18:34" itemprop="dateCreated datePublished" datetime="2025-09-19T15:18:34+08:00">2025-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-20 16:34:05" itemprop="dateModified" datetime="2025-09-20T16:34:05+08:00">2025-09-20</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Crimson 是 Crimson OSD 的代码名称，它是下一代用于多核心可扩展性的 OSD 。它通过快速网络和存储设备提高性能，采用包括 DPDK 和 SPDK 的顶级技术。BlueStore 继续支持 HDD 和 SSD。Crimson 旨在与早期版本的 OSD 守护进程与类 Ceph OSD 兼容。</p>
<p>Crimson 基于 SeaStar C++ 框架构建，是核心 Ceph 对象存储守护进程 OSD 组件的新实现，并替换了 Ceph OSD 。Crimson OSD 最小化延迟并增加 CPU 处理器用量。它使用高性能异步 IO 和新的线程架构，旨在最小化上下文切换和用于跨通信的操作间的线程通信。</p>
<p><strong>以下分析基于 v19.2.1 进行分析。</strong></p>
<span id="more"></span>

<h1 id="一、架构对比"><a href="#一、架构对比" class="headerlink" title="一、架构对比"></a>一、架构对比</h1><p>Ceph OSD 是 Ceph 集群的一部分，负责通过网络提供对象访问、维护冗余和高可用性，并将对象持久化到本地存储设备。作为 Classic OSD 的重写版本，Crimson OSD 从客户端和其他 OSD 的角度兼容现有的 RADOS 协议，提供相同的接口和功能。Ceph OSD 的模块（例如 Messenger、OSD 服务和 ObjectStore）在其职责上保持不变，但跨组件交互的形式和内部资源管理经过了大幅重构，以应用无共享设计和自下而上的用户空间任务调度。</p>
<p>经典 OSD 的架构对多核处理器并不友好，因为每个组件都包含工作线程池，并且每个组件之间共享队列。举个简单的例子，一个 PG 操作首先需要由一个 Messenger 工作线程处理，将原始数据流组装或解码成一条消息，然后放入消息队列进行调度。之后， PG 工作线程获取该消息，经过必要的处理后，将请求以事务的形式交给 ObjectStore 。事务提交后， PG 将完成操作，并通过发送队列和 Messenger 工作线程再次发送回复。虽然可以通过向池中添加更多线程将工作负载扩展到多个 CPU ，但这些线程默认共享资源，因此需要使用锁，从而引入争用。实际情况会更加复杂，因为每个组件内部都会实现更多的线程池，并且如果跨 OSD 进行复制，数据路径也会更长。</p>
<p><img src="https://bugwz.com/assets/images/ceph-crimson-old-arch.png" alt="经典 OSD 架构"></p>
<p>经典架构面临的一个主要挑战是，锁争用开销会随着任务和核心数量的增加而迅速增长，并且每个锁定点在某些情况下都可能成为扩展瓶颈。此外，即使在无争用的情况下，这些锁和队列也会产生延迟成本。多年来，人们在分析和优化更细粒度的资源管理和快速路径实现以跳过排队方面付出了巨大的努力。未来唾手可得的成果将会减少，在类似的设计下，可扩展性似乎正在收敛到某个乘数。此外，还存在其他挑战。由于簿记工作会在工作线程之间委派任务，延迟问题将随着线程池和任务队列的出现而恶化。锁可能会强制上下文切换，这会使情况更加糟糕。</p>
<p>Crimson 项目希望通过无共享设计和运行至完成模型来解决 CPU 的可扩展性问题。该设计的基本原理是强制每个核心（或 CPU）运行一个固定线程，并在用户空间中调度非阻塞任务。请求及其资源按核心进行分片，因此它们可以在同一核心中处理直至完成。理想情况下，所有锁和上下文切换都不再需要，因为每个正在运行的非阻塞任务都拥有 CPU，直到其完成或协同让出。没有其他线程可以同时抢占该任务。如果无需与数据路径中的其他分片通信，则理想的性能将随着核心数量线性扩展，直到 IO 设备达到其极限。这种设计非常适合 Ceph OSD，因为在 OSD 级别，所有 IO 都已按 PG 分片。</p>
<p><img src="https://bugwz.com/assets/images/ceph-crimson-new-arch.png" alt="Crimson OSD 架构"></p>
<h1 id="二、配置解析流程"><a href="#二、配置解析流程" class="headerlink" title="二、配置解析流程"></a>二、配置解析流程</h1><p>配置解析的代码位于 <code>src/crimson/osd/main.cc</code> 文件中的 <code>auto early_config_result = crimson::osd::get_early_config(argc, argv);</code> 函数，该函数主要逻辑如下:</p>
<ul>
<li>创建一个子进程，在子进程中尝试解析参数后，将参数编码后通过管道传递给父进程；</li>
<li>父进程解析并返回参数给 main 函数中；</li>
</ul>
<p>子进程在 <code>_get_early_config</code> 函数中解析参数，其中 ceph 相关的参数使用 <code>ceph_argparse_early_args</code> 函数解析，并且根据 ceph 的 <code>crimson_seastar_cpu_cores</code> 参数来设置 <code>--cpuset $cpu_cores --thread-affinity 1</code> ；或者根据 ceph 的 <code>crimson_seastar_num_threads</code> 参数来设置 <code>--smp $smp --thread-affinity 0</code>。注意 <code>crimson_seastar_cpu_cores</code> 参数的优先级高于 <code>crimson_seastar_num_threads</code> 参数。</p>
<p>之后 <code>main</code> 函数中通过 <code>app.run</code> 函数调用，将解析到的参数传递给 <code>seastar</code> ，进而设置了 <code>seastar</code> 要启动的 <code>shard</code> 的数量及绑定 <code>cpu</code> 的配置。但是由于目前 <code>main</code> 中的 <code>seastar::async</code> 函数逻辑中没有显示的使用 <code>seastar::smp::count</code> 来将任务分发给多个 <code>shard</code> 执行，因此关于日志的配置，<code>prometheus</code> 的配置，<code>crimson osd</code> 的对象均是在 <code>shard 0</code> （即 <code>PRIMARY_CORE</code> ）上执行的。</p>
<h1 id="三、网络通信流程"><a href="#三、网络通信流程" class="headerlink" title="三、网络通信流程"></a>三、网络通信流程</h1><p>在 crimson osd 进程启动的时候，会调用 <code>OSD::start()</code> 函数，其内部会对 <code>public_msgr</code> 和 <code>cluster_msgr</code> 两个对象执行 <code>bind</code> 和 <code>start</code> 操作。</p>
<ul>
<li><code>bind 操作</code>: 对应的函数为 <code>SocketMessenger::bind</code> ， 该函数内部最终通过调用 seastar 的 <code>invoke_on_all</code> 下发 <code>seastar::listen(s_addr, lo)</code> 操作给所有 <code>shard</code> ，使所有的 <code>shard</code> 开始监听相同的端口；</li>
<li><code>start 操作</code>: 对应的函数为 <code>SocketMessenger::start</code> ， 该函数内部通过调用 <code>ShardedServerSocket::accept</code> ，并在其内部调用 seastar 的 <code>invoke_on_all</code> 方法使每个 shard 接收新连接请求。每个 <code>shard</code> 接收到请求后，会逐步调用 <code>SocketMessenger::accept</code> &#x3D;&gt; <code>SocketConnection::start_accept</code> &#x3D;&gt; <code>ProtocolV2::start_accept</code> &#x3D;&gt; <code>ProtocolV2::execute_accepting</code> 等函数逐步处理请求，最终会调用到 <code>OSD::do_ms_dispatch</code> 函数正式处理客户端请求。</li>
</ul>
<p>在 <code>OSD::do_ms_dispatch</code> 函数内部，针对于请求消息的类型，有如下操作：</p>
<ul>
<li><code>必须在 PRIMARY_CORE shard 上执行的操作</code>: 包括 <code>CEPH_MSG_OSD_MAP</code>、<code>MSG_COMMAND</code>、<code>MSG_OSD_MARK_ME_DOWN</code> 等；</li>
<li><code>其他可以在任意 shard 上执行的操作</code>：包括 <code>CEPH_MSG_OSD_MAP</code>、<code>CEPH_MSG_OSD_OP</code>、<code>MSG_COMMAND</code> 等；</li>
</ul>
<p><img src="https://bugwz.com/assets/images/ceph-crimson-osd-pg-shard.png" alt="Shards In OSD"></p>
<ul>
<li>由于 <code>OSD</code> 中的每个 <code>Shard</code> 都会监听网络信息，所以每个 <code>Shard</code> 都可以处理网络请求；</li>
<li>但是由于需要对请求按照 <code>PG</code> 映射到 <code>Shard</code> 中，所以内部引入了 <code>pg_to_shard_mapping</code> 的映射结构，每个请求都需要在 <code>Shard</code> 中检索映射表；</li>
<li>如果当前 <code>Shard</code> 中的映射表中缺少 <code>PG</code> 的映射信息，会将请求发送给 <code>Shard 0</code> 来尝试创建对应的映射记录，并将该记录广播给所有的 <code>Shard</code> ；</li>
</ul>
<p><strong>对于请求类型为 <code>CEPH_MSG_OSD_OP</code> 的关键代码链路如下:</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理对应的 op 请求</span></span><br><span class="line">seastar::future&lt;&gt; OSD::<span class="built_in">handle_osd_op</span>(crimson::net::ConnectionRef conn, Ref&lt;MOSDOp&gt; m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pg_shard_manager.<span class="built_in">start_pg_operation</span>&lt;ClientRequest&gt;(<span class="built_in">get_shard_services</span>(), conn, std::<span class="built_in">move</span>(m)).second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始 pg 操作</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; <span class="keyword">auto</span> <span class="title">start_pg_operation</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fut =</span><br><span class="line">        opref.<span class="keyword">template</span> enter_stage&lt;&gt;(opref.<span class="built_in">get_connection_pipeline</span>().await_active)</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 pg_to_shard_mapping 中获取 pg 与 shard 的对应关系，</span></span><br><span class="line">            <span class="comment">// 如果对应的映射关系不存在，则根据各 shard 的负载情况创建映射关系。</span></span><br><span class="line">            .<span class="built_in">then</span>([<span class="keyword">this</span>, &amp;opref] &#123; <span class="keyword">return</span> <span class="built_in">get_pg_to_shard_mapping</span>().<span class="built_in">get_or_create_pg_mapping</span>(opref.<span class="built_in">get_pgid</span>()); &#125;)</span><br><span class="line">            .<span class="built_in">then_wrapped</span>([<span class="keyword">this</span>, &amp;logger, op = std::<span class="built_in">move</span>(op)](<span class="keyword">auto</span> fut) <span class="keyword">mutable</span> &#123;</span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line"></span><br><span class="line">                <span class="keyword">auto</span> core = fut.<span class="built_in">get</span>();</span><br><span class="line">                logger.<span class="built_in">debug</span>(<span class="string">&quot;&#123;&#125;: can_create=&#123;&#125;, target-core=&#123;&#125;&quot;</span>, *op, T::<span class="built_in">can_create</span>(), core);</span><br><span class="line">                <span class="comment">// 处理已知 shard id 的 op 请求</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="keyword">template</span> <span class="built_in">with_remote_shard_state_and_op</span>&lt;T&gt;(</span><br><span class="line">                    core, std::<span class="built_in">move</span>(op), [<span class="keyword">this</span>](ShardServices&amp; target_shard_services, <span class="keyword">typename</span> T::IRef op) &#123;</span><br><span class="line">                        <span class="keyword">auto</span>&amp; opref = *op;</span><br><span class="line">                        <span class="keyword">auto</span>&amp; logger = crimson::<span class="built_in">get_logger</span>(ceph_subsys_osd);</span><br><span class="line">                        logger.<span class="built_in">debug</span>(<span class="string">&quot;&#123;&#125;: entering create_or_wait_pg&quot;</span>, opref);</span><br><span class="line">                        <span class="keyword">return</span> opref</span><br><span class="line">                            .<span class="keyword">template</span> enter_stage&lt;&gt;(</span><br><span class="line">                                opref.<span class="built_in">get_pershard_pipeline</span>(target_shard_services).create_or_wait_pg)</span><br><span class="line">                            .<span class="built_in">then</span>([<span class="keyword">this</span>, &amp;target_shard_services, op = std::<span class="built_in">move</span>(op)]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> <span class="built_in">constexpr</span> (T::<span class="built_in">can_create</span>()) &#123;</span><br><span class="line">                                    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="keyword">template</span> <span class="built_in">run_with_pg_maybe_create</span>&lt;T&gt;(std::<span class="built_in">move</span>(op),</span><br><span class="line">                                                                                        target_shard_services);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="keyword">template</span> <span class="built_in">run_with_pg_maybe_wait</span>&lt;T&gt;(std::<span class="built_in">move</span>(op),</span><br><span class="line">                                                                                    target_shard_services);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(id, std::<span class="built_in">move</span>(fut));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取或创建 pg 和 shard 的映射关系</span></span><br><span class="line"><span class="function">seastar::future&lt;<span class="type">core_id_t</span>&gt; <span class="title">PGShardMapping::get_or_create_pg_mapping</span><span class="params">(<span class="type">spg_t</span> pgid, <span class="type">core_id_t</span> core_expected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_PREFIX</span>(PGShardMapping::get_or_create_pg_mapping);</span><br><span class="line">    <span class="keyword">auto</span> find_iter = pg_to_core.<span class="built_in">find</span>(pgid);</span><br><span class="line">    <span class="keyword">if</span> (find_iter != pg_to_core.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> core_found = find_iter-&gt;second;</span><br><span class="line">        <span class="comment">// 一些校验逻辑</span></span><br><span class="line">        <span class="built_in">assert</span>(core_found != NULL_CORE);</span><br><span class="line">        <span class="keyword">if</span> (core_expected != NULL_CORE &amp;&amp; core_expected != core_found) &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;the mapping is inconsistent for pg &#123;&#125;: core &#123;&#125;, expected &#123;&#125;&quot;</span>, pgid, core_found, core_expected);</span><br><span class="line">            <span class="built_in">ceph_abort</span>(<span class="string">&quot;The pg mapping is inconsistent!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seastar::<span class="built_in">make_ready_future</span>&lt;<span class="type">core_id_t</span>&gt;(core_found);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">DEBUG</span>(<span class="string">&quot;calling primary to add mapping for pg &#123;&#125; to the expected core &#123;&#125;&quot;</span>, pgid, core_expected);</span><br><span class="line">        <span class="comment">// 如果没有找到 pg 和 shard 的映射关系，则需要创建映射，</span></span><br><span class="line">        <span class="comment">// 创建操作必须由 shard 0 执行。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">container</span>()</span><br><span class="line">            .<span class="built_in">invoke_on</span>(</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                [pgid, core_expected, FNAME](<span class="keyword">auto</span>&amp; primary_mapping) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> core_to_update = core_expected;</span><br><span class="line">                    <span class="comment">// 在 shard 0 中判断对应的映射关系是否存在，</span></span><br><span class="line">                    <span class="comment">// 如果存在且校验正常则可使用该映射关系</span></span><br><span class="line">                    <span class="keyword">auto</span> find_iter = primary_mapping.pg_to_core.<span class="built_in">find</span>(pgid);</span><br><span class="line">                    <span class="keyword">if</span> (find_iter != primary_mapping.pg_to_core.<span class="built_in">end</span>()) &#123;</span><br><span class="line"></span><br><span class="line">                        ......</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果在 shard 0 中也没有找到映射关系，则创建映射</span></span><br><span class="line">                        <span class="built_in">ceph_assert_always</span>(primary_mapping.core_to_num_pgs.<span class="built_in">size</span>() &gt; <span class="number">0</span>);</span><br><span class="line">                        std::map&lt;<span class="type">core_id_t</span>, <span class="type">unsigned</span>&gt;::iterator count_iter;</span><br><span class="line">                        <span class="keyword">if</span> (core_expected == NULL_CORE) &#123;</span><br><span class="line">                            <span class="comment">// 从 shard 中选择 pg 映射数量最少的最为当前 pg 的关联 shard</span></span><br><span class="line">                            count_iter = std::<span class="built_in">min_element</span>(</span><br><span class="line">                                primary_mapping.core_to_num_pgs.<span class="built_in">begin</span>(),</span><br><span class="line">                                primary_mapping.core_to_num_pgs.<span class="built_in">end</span>(),</span><br><span class="line">                                [](<span class="type">const</span> <span class="keyword">auto</span>&amp; left, <span class="type">const</span> <span class="keyword">auto</span>&amp; right) &#123; <span class="keyword">return</span> left.second &lt; right.second; &#125;);</span><br><span class="line">                            core_to_update = count_iter-&gt;first;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        ......</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">assert</span>(core_to_update != NULL_CORE);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 广播同步</span></span><br><span class="line">                    <span class="comment">// 通过 invoke_on_others 确保所有 Core 的映射表同步更新</span></span><br><span class="line">                    <span class="comment">// 将变更的映射关系广播给其他所有的 shard</span></span><br><span class="line">                    <span class="keyword">return</span> primary_mapping.<span class="built_in">container</span>().<span class="built_in">invoke_on_others</span>(</span><br><span class="line">                        [pgid, core_to_update, FNAME](<span class="keyword">auto</span>&amp; other_mapping) &#123;</span><br><span class="line"></span><br><span class="line">                            ......</span><br><span class="line">                        &#125;);</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 op 请求</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt; <span class="keyword">auto</span> <span class="built_in">with_remote_shard_state_and_op</span>(<span class="type">core_id_t</span> core, <span class="keyword">typename</span> T::IRef&amp;&amp; op, F&amp;&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ceph_assert</span>(op-&gt;<span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果 op 请求的目标 shard 为当前 shard ，则在当前 shard 中处理</span></span><br><span class="line">    <span class="keyword">if</span> (seastar::<span class="built_in">this_shard_id</span>() == core) &#123;</span><br><span class="line">        <span class="keyword">auto</span> f_conn = op-&gt;<span class="built_in">prepare_remote_submission</span>();</span><br><span class="line">        op-&gt;<span class="built_in">finish_remote_submission</span>(std::<span class="built_in">move</span>(f_conn));</span><br><span class="line">        <span class="keyword">auto</span>&amp; target_shard_services = shard_services.<span class="built_in">local</span>();</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(std::<span class="built_in">move</span>(f), target_shard_services, std::<span class="built_in">move</span>(op));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则，将对应的 op 请求转发给对应的 shard 处理</span></span><br><span class="line">    logger.<span class="built_in">debug</span>(<span class="string">&quot;&#123;&#125;: send &#123;&#125; to the remote pg core &#123;&#125;&quot;</span>, opref, cc_seq, core);</span><br><span class="line">    <span class="keyword">return</span> opref.<span class="built_in">get_handle</span>().<span class="built_in">complete</span>().<span class="built_in">then</span>([<span class="keyword">this</span>, core, cc_seq, op = std::<span class="built_in">move</span>(op), f = std::<span class="built_in">move</span>(f)]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="built_in">get_local_state</span>().registry.<span class="built_in">remove_from_registry</span>(*op);</span><br><span class="line">        <span class="keyword">auto</span> f_conn = op-&gt;<span class="built_in">prepare_remote_submission</span>();</span><br><span class="line">        <span class="keyword">return</span> shard_services.<span class="built_in">invoke_on</span>(</span><br><span class="line">            core,</span><br><span class="line">            [<span class="keyword">this</span>, cc_seq, f = std::<span class="built_in">move</span>(f), op = std::<span class="built_in">move</span>(op), f_conn = std::<span class="built_in">move</span>(f_conn)](</span><br><span class="line">                <span class="keyword">auto</span>&amp; target_shard_services) <span class="keyword">mutable</span> &#123;</span><br><span class="line">                op-&gt;<span class="built_in">finish_remote_submission</span>(std::<span class="built_in">move</span>(f_conn));</span><br><span class="line">                target_shard_services.local_state.registry.<span class="built_in">add_to_registry</span>(*op);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="keyword">template</span> <span class="built_in">process_ordered_op_remotely</span>&lt;T&gt;(</span><br><span class="line">                    cc_seq, target_shard_services, std::<span class="built_in">move</span>(op), std::<span class="built_in">move</span>(f));</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、线程模型"><a href="#四、线程模型" class="headerlink" title="四、线程模型"></a>四、线程模型</h1><p>在服务启动时会通过解析 <code>crimson_seastar_cpu_cores</code> 或 <code>crimson_seastar_num_threads</code> 这两个配置来设置 <code>seastar</code> 框架的并发 <code>shard</code> 数量，之后在 <code>PRIMARY_CORE</code> 初始化环境，并通过 <code>seastar</code> 的 <code>invoke_on</code>、<code>invoke_on_others</code>、<code>invoke_on_all</code>、<code>seastar::smp::submit_to</code> 等方法来给 <code>shard</code> 下发任务，从而实现 <code>osd</code> 中相互独立的 <code>shard</code> 任务模型。</p>
<h2 id="4-1、shard-相关任务"><a href="#4-1、shard-相关任务" class="headerlink" title="4.1、shard 相关任务"></a>4.1、shard 相关任务</h2><p><strong>seastar 提供的不同的下发任务的方法比较:</strong></p>
<table>
<thead>
<tr>
<th>接口</th>
<th>目标 Shard</th>
<th>是否依赖 <code>sharded</code> 容器</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>invoke_on</code></td>
<td>指定单个 Shard</td>
<td>是</td>
<td>访问特定 Shard 上的对象</td>
</tr>
<tr>
<td><code>invoke_on_others</code></td>
<td>除当前 Shard 外的所有</td>
<td>是</td>
<td>广播操作（排除当前 Shard）</td>
</tr>
<tr>
<td><code>invoke_on_all</code></td>
<td>所有 Shard（包括当前）</td>
<td>是</td>
<td>全局初始化&#x2F;清理</td>
</tr>
<tr>
<td><code>smp::submit_to</code></td>
<td>指定单个 Shard</td>
<td>否</td>
<td>任意跨 Shard 任务</td>
</tr>
</tbody></table>
<p><strong><code>invoke_on</code> 的部分操作如下:</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"><span class="comment">// 更新配置值并通知所有观察者</span></span><br><span class="line"><span class="attribute">container</span>()<span class="selector-class">.invoke_on</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 0 号 shard 上停止 shards</span></span><br><span class="line">this-&gt;<span class="attribute">container</span>()<span class="selector-class">.invoke_on</span>(<span class="number">0</span>, [](auto&amp; ss) &#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 0 号 shard 上新增 pg 和 shard 的映射关系</span></span><br><span class="line"><span class="attribute">container</span>()<span class="selector-class">.invoke_on</span>(<span class="number">0</span>, [pgid, core_expected, FNAME](auto&amp;</span><br><span class="line"></span><br><span class="line">// 在 <span class="number">0</span> 号 shard 上移除 pg 和 shard 的映射关系</span><br><span class="line">container()<span class="selector-class">.invoke_on</span>(<span class="number">0</span>, [pgid, FNAME](auto&amp; primary_mapping) &#123; ... &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转发请求给特定 shard</span></span><br><span class="line">shard_services<span class="selector-class">.invoke_on</span>(core, ... )</span><br></pre></td></tr></table></figure>

<p><strong><code>invoke_on_others</code> 的部分操作如下:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"><span class="comment">// 更新 proxy 配置</span></span><br><span class="line"><span class="function"><span class="title">container</span><span class="params">()</span></span><span class="selector-class">.invoke_on_others</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播 pg shard 新增映射记录</span></span><br><span class="line">primary_mapping<span class="selector-class">.container</span>()<span class="selector-class">.invoke_on_others</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播 pg shard 移除映射记录</span></span><br><span class="line">primary_mapping<span class="selector-class">.container</span>()<span class="selector-class">.invoke_on_others</span>(...)</span><br></pre></td></tr></table></figure>

<p><strong><code>invoke_on_all</code> 的部分操作如下:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">seastar::listen</span><br><span class="line">ss.listener-&gt;<span class="built_in">accept</span>()</span><br><span class="line">ss.listener-&gt;<span class="built_in">abort_accept</span>()</span><br><span class="line">ss<span class="selector-class">.listener</span><span class="selector-class">.reset</span>()</span><br><span class="line">local_store<span class="selector-class">.mkfs</span>()</span><br><span class="line">local_store<span class="selector-class">.mount</span>()</span><br><span class="line">local_store<span class="selector-class">.umount</span>()</span><br><span class="line">local_store<span class="selector-class">.mount_managers</span>()</span><br><span class="line">local_store<span class="selector-class">.set_secondaries</span>(...)</span><br><span class="line">local_store<span class="selector-class">.mkfs_managers</span>()</span><br><span class="line">local_device<span class="selector-class">.do_shard_mount</span>()</span><br><span class="line">local_device<span class="selector-class">.shard_mount</span>()</span><br><span class="line">local_device<span class="selector-class">.shard_mkfs</span>()</span><br><span class="line">local_service<span class="selector-class">.local_state</span><span class="selector-class">.stop_pgs</span>()</span><br><span class="line">local_service<span class="selector-class">.local_state</span><span class="selector-class">.broadcast_map_to_pgs</span>(local_service, epoch)</span><br><span class="line">local_service<span class="selector-class">.local_state</span><span class="selector-class">.osdmap_gate</span><span class="selector-class">.got_map</span>(epoch)</span><br><span class="line">local_service<span class="selector-class">.local_state</span><span class="selector-class">.set_up_epoch</span>(e)</span><br><span class="line">local_service<span class="selector-class">.local_state</span><span class="selector-class">.update_shard_superblock</span>(superblock)</span><br><span class="line">local<span class="selector-class">.local_state</span><span class="selector-class">.update_map</span>(...)</span><br><span class="line">local<span class="selector-class">.local_state</span><span class="selector-class">.stop_registry</span>()</span><br><span class="line">osd_state.<span class="built_in">_set_active</span>()</span><br><span class="line">osd_state.<span class="built_in">_set_stopping</span>()</span><br></pre></td></tr></table></figure>

<p><strong><code>seastar::smp::submit_to</code> 的部分操作如下:</strong></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"><span class="comment">// 在 shard 0 上处理 CEPH_MSG_OSD_MAP/MSG_COMMAND/MSG_OSD_MARK_ME_DOWN 消息</span></span><br><span class="line">seastar<span class="type">::smp</span><span class="type">::submit_to</span>(PRIMARY_CORE, <span class="params">...</span> )</span><br></pre></td></tr></table></figure>

<h2 id="4-2、线程示例"><a href="#4-2、线程示例" class="headerlink" title="4.2、线程示例"></a>4.2、线程示例</h2><p><strong>当 <code>crimson_seastar_num_threads</code> 设置为 <code>2</code> 的时候，crimson osd 的线程情况:</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">[root@bugwz.host build]<span class="comment"># ps -T -p 270088</span></span><br><span class="line">    PID    SPID TTY          TIME CMD</span><br><span class="line"><span class="number"> 270088 </span><span class="number"> 270088 </span>pts/11   00:30:31 crimson-osd</span><br><span class="line"><span class="number"> 270088 </span><span class="number"> 270130 </span>pts/11   00:22:41 reactor-1</span><br><span class="line"><span class="number"> 270088 </span><span class="number"> 270131 </span>pts/11   00:00:00 syscall-0</span><br><span class="line"><span class="number"> 270088 </span><span class="number"> 270132 </span>pts/11   00:00:00 syscall-1</span><br><span class="line"><span class="number"> 270088 </span><span class="number"> 270133 </span>pts/11   00:00:00 crimson-osd</span><br><span class="line"><span class="number"> 270088 </span><span class="number"> 270134 </span>pts/11   00:00:00 reactor-1</span><br></pre></td></tr></table></figure>

<p><strong>当 <code>crimson_seastar_num_threads</code> 设置为 <code>8</code> 的时候，crimson osd 的线程情况:</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">[root@bugwz.host build]<span class="comment"># ps -T -p 345103</span></span><br><span class="line">    PID    SPID TTY          TIME CMD</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345103 </span>pts/15   00:00:04 crimson-osd</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345145 </span>pts/15   00:00:02 reactor-1</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345146 </span>pts/15   00:00:02 reactor-2</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345147 </span>pts/15   00:00:02 reactor-3</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345148 </span>pts/15   00:00:02 reactor-4</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345149 </span>pts/15   00:00:02 reactor-5</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345150 </span>pts/15   00:00:02 reactor-6</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345151 </span>pts/15   00:00:02 reactor-7</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345152 </span>pts/15   00:00:00 syscall-7</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345153 </span>pts/15   00:00:00 syscall-0</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345154 </span>pts/15   00:00:00 syscall-4</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345155 </span>pts/15   00:00:00 syscall-3</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345156 </span>pts/15   00:00:00 syscall-2</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345157 </span>pts/15   00:00:00 syscall-5</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345158 </span>pts/15   00:00:00 syscall-1</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345159 </span>pts/15   00:00:00 syscall-6</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345160 </span>pts/15   00:00:00 crimson-osd</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345161 </span>pts/15   00:00:00 reactor-1</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345162 </span>pts/15   00:00:00 reactor-4</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345163 </span>pts/15   00:00:00 reactor-5</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345164 </span>pts/15   00:00:00 reactor-6</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345165 </span>pts/15   00:00:00 reactor-7</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345166 </span>pts/15   00:00:00 reactor-2</span><br><span class="line"><span class="number"> 345103 </span><span class="number"> 345167 </span>pts/15   00:00:00 reactor-3</span><br></pre></td></tr></table></figure>

<h1 id="五、存储模块设计"><a href="#五、存储模块设计" class="headerlink" title="五、存储模块设计"></a>五、存储模块设计</h1><h2 id="5-1、后端对象存储类型"><a href="#5-1、后端对象存储类型" class="headerlink" title="5.1、后端对象存储类型"></a>5.1、后端对象存储类型</h2><p>main 函数中会通过 <code>crimson::os::FuturizedStore::create</code> 函数来创建 <code>store</code> 对象。根据 <code>osd_objectstore</code> 和 <code>osd_data</code> 参数来配置 <code>store</code> 对象。其中 <code>osd_objectstore</code> 参数指定了后端对象存储的类型，支持的参数有 <code>alienstore/cyanstore/seastore</code> ，默认为 <code>alienstore</code> （即后端存储为 <code>bluestore</code> ）。其中 <code>osd_data</code> 参数指定了数据存储目录（比如当使用 <code>vstart.sh</code> 部署集群时，对应的配置默认为 <code>./build/dev/osd$id</code> ）。</p>
<p><strong>对象存储类型:</strong></p>
<ul>
<li><strong><code>alienstore</code></strong>: 是 seastar 线程中的一个代理，主要是与 bluestore 进行通信。由于 io 任务会与 bluestore 进行通信，因此无需针对多个 osd 分片进行特殊处理。BlueStore 中没有针对 crimson 的定制，因为 bluestore 依赖于第三方 RocksDB 项目，而该项目仍然采用线程化设计，因此无法真正将其扩展为无共享设计。然而，在 crimson 能够提供经过优化且足够稳定的原生存储后端 seastore 之前，使用合理的开销来换取完善的存储后端解决方案是可以接受的。</li>
<li><strong><code>cyanstore</code></strong>: crimson osd 中的 cyanstore 与 classic osd 中的 memstore 相对应。为了支持多分片，唯一的变化是每个分片创建独立的 cyanstore 实例。一个目标是确保虚拟 IO 操作能够在同一核心中完成，以帮助识别 osd 级别的可扩展性问题（如果有）。另一个目标是在 osd 级别与 Classic 进行直接性能比较，而不会受到 objectstore 的复杂影响。</li>
<li><strong><code>seastore</code></strong>: seastore 是 crimson osd 的原生 objectstore 解决方案，它使用 seastar 框架开发并采用相同的设计原则。</li>
</ul>
<p>在 seastore 初始化的时候，会根据 <code>seastore_main_device_type</code> 参数来初始化 <code>seastore</code> 主设备，该参数可选值为 <code>SSD/RANDOM_BLOCK_SSD</code> （代码中还实现了 <code>HDD/ZBD</code> ，但是目前并不支持） ，默认为 <code>SSD</code> 。 在调用 <code>Device::make_device(root, d_type)</code> 函数创建 <code>device</code> 的过程中，会针对不同的设备类型又做了一些区分。</p>
<p><strong>seastore 设备类型对比:</strong></p>
<table>
<thead>
<tr>
<th>device_type</th>
<th>backend_type</th>
<th>create func</th>
</tr>
</thead>
<tbody><tr>
<td>HDD</td>
<td>backend_type_t::SEGMENTED</td>
<td>SegmentManager::get_segment_manager</td>
</tr>
<tr>
<td>SSD</td>
<td>backend_type_t::SEGMENTED</td>
<td>SegmentManager::get_segment_manager</td>
</tr>
<tr>
<td>ZBD</td>
<td>backend_type_t::SEGMENTED</td>
<td>SegmentManager::get_segment_manager</td>
</tr>
<tr>
<td>RANDOM_BLOCK_SSD</td>
<td>backend_type_t::RANDOM_BLOCK</td>
<td>get_rb_device</td>
</tr>
</tbody></table>
<h2 id="5-2、段存储格式信息"><a href="#5-2、段存储格式信息" class="headerlink" title="5.2、段存储格式信息"></a>5.2、段存储格式信息</h2><p>当使用 <code>vstart.sh</code> 脚本部署测试集群后会发现 <code>build/dev/osd*/</code> 目录下会存在一个 <code>block</code> 文件，该文件对应的就是一个 <code>osd</code> 组件后端的对象存储，由于一个 <code>osd</code> 中可能会启用多个 <code>seastar shard</code> ，并且由于 <code>shard</code> 间数据的隔离，因此需要对这大块存储空间进行切割，使每个 <code>shard</code> 各负责一块空间，从而实现操作数据的隔离。</p>
<p><strong>后端存储的格式化规则:</strong></p>
<ul>
<li>开始部分为 superblock 空间，存储这个该存储空间的规划及使用信息；</li>
<li>剩余空间平均分配给每个 shard ，实现独立的操作空间；</li>
</ul>
<p><strong>创建 superblock 及 shard 空间规划函数如下:</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">block_sm_superblock_t</span> <span class="title">make_superblock</span><span class="params">(<span class="type">device_id_t</span> device_id, <span class="type">device_config_t</span> sm_config, <span class="type">const</span> seastar::stat_data&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_PREFIX</span>(block_make_superblock);</span><br><span class="line">    <span class="keyword">using</span> crimson::common::get_conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// seastore_device_size 默认为 50G</span></span><br><span class="line">    <span class="keyword">auto</span> config_size = <span class="built_in">get_conf</span>&lt;Option::<span class="type">size_t</span>&gt;(<span class="string">&quot;seastore_device_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> size = (data.size == <span class="number">0</span>) ? config_size : data.size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单个 segment 的大小，默认为 64M</span></span><br><span class="line">    <span class="keyword">auto</span> config_segment_size = <span class="built_in">get_conf</span>&lt;Option::<span class="type">size_t</span>&gt;(<span class="string">&quot;seastore_segment_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 segment 数量： 总大小除以单个 segment 的大小</span></span><br><span class="line">    <span class="type">size_t</span> raw_segments = size / config_segment_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个 shard 所需要的段状态跟踪器大小</span></span><br><span class="line">    <span class="comment">// 默认为一个 data.block_size 大小，如果计算出的每个 shard 所管理的 segments 数量超过 data.block_size 大小，</span></span><br><span class="line">    <span class="comment">// 则返回超过 segments 数量的 data.block_size 的倍数值。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// seastar::smp::count 为 crimson osd 启动时指定的 shard 数量</span></span><br><span class="line">    <span class="comment">// data.block_size 默认为 4096</span></span><br><span class="line">    <span class="type">size_t</span> shard_tracker_size = SegmentStateTracker::<span class="built_in">get_raw_size</span>(raw_segments / seastar::smp::count, data.block_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算全部 shard 的段状态跟踪器的总大小</span></span><br><span class="line">    <span class="type">size_t</span> total_tracker_size = shard_tracker_size * seastar::smp::count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始的偏移应该从 superblock 之后开始</span></span><br><span class="line">    <span class="type">size_t</span> tracker_off = data.block_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算减去 superblock 及所有段状态跟踪器总大小之后的剩余空间可分配的 segments 数量</span></span><br><span class="line">    <span class="type">size_t</span> segments = (size - tracker_off - total_tracker_size) / config_segment_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个 shard 可分配的 segments 数量</span></span><br><span class="line">    <span class="type">size_t</span> segments_per_shard = segments / seastar::smp::count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化每个 shard 信息</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">block_shard_info_t</span>&gt; <span class="title">shard_infos</span><span class="params">(seastar::smp::count)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; seastar::smp::count; i++) &#123;</span><br><span class="line">        <span class="comment">// 每个 shard 管理的 segments 总大小</span></span><br><span class="line">        shard_infos[i].size = segments_per_shard * config_segment_size;</span><br><span class="line">        <span class="comment">// 每个 shard 管理的 segments 数量</span></span><br><span class="line">        shard_infos[i].segments = segments_per_shard;</span><br><span class="line">        <span class="comment">// 标记每个 shard 的段状态跟踪器的在全部空间中的偏移</span></span><br><span class="line">        shard_infos[i].tracker_offset = tracker_off + i * shard_tracker_size;</span><br><span class="line">        <span class="comment">// 标记每个 shard 的 segment 数据起始位置在全部空间中的偏移</span></span><br><span class="line">        shard_infos[i].first_segment_offset = tracker_off + total_tracker_size + i * segments_per_shard * config_segment_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出日志信息</span></span><br><span class="line">    <span class="built_in">INFO</span>(<span class="string">&quot;&#123;&#125; disk_size=&#123;&#125;, segment_size=&#123;&#125;, block_size=&#123;&#125;&quot;</span>,</span><br><span class="line">         <span class="type">device_id_printer_t</span>&#123;device_id&#125;,</span><br><span class="line">         size,</span><br><span class="line">         <span class="built_in">uint64_t</span>(config_segment_size),</span><br><span class="line">         data.block_size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; seastar::smp::count; i++) &#123;</span><br><span class="line">        <span class="built_in">INFO</span>(<span class="string">&quot;shard &#123;&#125; infos:&quot;</span>, i, shard_infos[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 superblock 全部信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">block_sm_superblock_t</span>&#123;seastar::smp::count, config_segment_size, data.block_size, shard_infos, std::<span class="built_in">move</span>(sm_config)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、客户端使用方式"><a href="#六、客户端使用方式" class="headerlink" title="六、客户端使用方式"></a>六、客户端使用方式</h1><p>由于 crimson osd 只支持 <code>message v2</code> 协议，所以我们在挂载 cephfs&#x2F;cephrbd 等的时候需要使用 <code>message v2</code> 的方式。</p>
<p><strong>相关命令:</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"><span class="comment"># 挂载 cephrbd - kernel 方式</span></span><br><span class="line">rbd device <span class="built_in">map</span> <span class="operator">-</span>t krbd rbdpool<span class="symbol">/rbdimg01</span> <span class="operator">-</span>o mount_timeout<span class="operator">=</span><span class="number">5</span>,ms_mode<span class="operator">=</span>crc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载 cephrbd - nbd 方式</span></span><br><span class="line">rbd device <span class="built_in">map</span> <span class="operator">-</span>t nbd rbdpool<span class="symbol">/rbdimg01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消挂载 cephrbd</span></span><br><span class="line">rbd device unmap rbdpool<span class="symbol">/rbdimg01</span> <span class="operator">-</span>t krbd</span><br><span class="line">rbd device unmap rbdpool<span class="symbol">/rbdimg01</span> <span class="operator">-</span>t nbd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载 cephfs - kernel 方式</span></span><br><span class="line">mount <span class="operator">-</span>t ceph <span class="number">10.10</span>.<span class="number">10.1</span>:<span class="number">3300</span>:<span class="symbol">/</span> <span class="symbol">/mnt/kernel-cephfs</span> <span class="operator">-</span>o name<span class="operator">=</span>admin,secret<span class="operator">=</span>AQBVokZoak<span class="operator">+</span>LJRAAqgeJr6j77v729bfvBl<span class="operator">/</span>Z3g<span class="operator">==</span>,ms_mode<span class="operator">=</span>crc,mount_timeout<span class="operator">=</span><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载 cephfs - fuse 方式</span></span><br><span class="line">ceph-fuse <span class="operator">-</span>c <span class="symbol">/etc/ceph/ceph.conf</span> <span class="operator">-</span>n client.admin <span class="operator">-</span>m <span class="number">10.10</span>.<span class="number">10.1</span>:<span class="number">3300</span> <span class="symbol">/mnt/fuse-cephfs</span> <span class="operator">-</span>-client_mountpoint <span class="symbol">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消挂载 cephfs</span></span><br><span class="line">umount <span class="symbol">/mnt/kernel-cephfs</span></span><br><span class="line">fusermount <span class="operator">-</span>u <span class="operator">/</span>mnt<span class="operator">/</span>fuse-cephfs</span><br></pre></td></tr></table></figure>

<p><strong>相关代码实现:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选监听地址</span></span><br><span class="line"><span class="function"><span class="type">entity_addrvec_t</span> <span class="title">pick_addresses</span><span class="params">(<span class="type">int</span> what)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_PREFIX</span>(osd.cc : pick_addresses);</span><br><span class="line">    <span class="type">entity_addrvec_t</span> addrs;</span><br><span class="line">    crimson::common::CephContext cct;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅筛选 message v2 的地址</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> flags = what | CEPH_PICK_ADDRESS_MSGR2;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">int</span> r = ::<span class="built_in">pick_addresses</span>(&amp;cct, flags, &amp;addrs, <span class="number">-1</span>); r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to pick address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> addr : addrs.v) &#123;</span><br><span class="line">        <span class="built_in">INFO</span>(<span class="string">&quot;picked address &#123;&#125;&quot;</span>, addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addrs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收请求</span></span><br><span class="line">seastar::future&lt;&gt; SocketMessenger::<span class="built_in">start</span>(<span class="type">const</span> <span class="type">dispatchers_t</span>&amp; _dispatchers)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(seastar::<span class="built_in">this_shard_id</span>() == sid);</span><br><span class="line">    dispatchers.<span class="built_in">assign</span>(_dispatchers);</span><br><span class="line">    <span class="keyword">if</span> (listener) &#123;</span><br><span class="line">        <span class="comment">// 仅支持 message v2 的地址</span></span><br><span class="line">        <span class="built_in">ceph_assert</span>(<span class="built_in">get_myaddr</span>().<span class="built_in">is_msgr2</span>());</span><br><span class="line">        <span class="built_in">ceph_assert</span>(<span class="built_in">get_myaddr</span>().<span class="built_in">get_port</span>() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收端口请求</span></span><br><span class="line">        <span class="keyword">return</span> listener-&gt;<span class="built_in">accept</span>([<span class="keyword">this</span>](SocketRef _socket, <span class="type">entity_addr_t</span> peer_addr) &#123;</span><br><span class="line">            <span class="built_in">assert</span>(<span class="built_in">get_myaddr</span>().<span class="built_in">is_msgr2</span>());</span><br><span class="line">            SocketFRef socket = seastar::<span class="built_in">make_foreign</span>(std::<span class="built_in">move</span>(_socket));</span><br><span class="line">            <span class="keyword">if</span> (listener-&gt;<span class="built_in">is_fixed_shard_dispatching</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">accept</span>(std::<span class="built_in">move</span>(socket), peer_addr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> seastar::smp::<span class="built_in">submit_to</span>(sid, [<span class="keyword">this</span>, peer_addr, socket = std::<span class="built_in">move</span>(socket)]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">accept</span>(std::<span class="built_in">move</span>(socket), peer_addr);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seastar::<span class="built_in">now</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、其他特性实现"><a href="#七、其他特性实现" class="headerlink" title="七、其他特性实现"></a>七、其他特性实现</h1><h2 id="7-1、冷热存储分离"><a href="#7-1、冷热存储分离" class="headerlink" title="7.1、冷热存储分离"></a>7.1、冷热存储分离</h2><p>当使用 <code>vstart.sh</code> 脚本部署测试的时候，我们会发现 <code>--seastore-secondary-devs</code> 和 <code>--seastore-secondary-devs-type</code> 配置，如果指定了这两个参数，该脚本便会通过 <code>dd</code> 格式化对应盘，然后创建 <code>./dev/osd$id/block.$type.1</code> 目录，之后执行 <code>ln -s $device ./dev/osd$id/block.$type.1/block</code> 创建一个软链文件。详细的代码可以查看: <a target="_blank" rel="noopener" href="https://github.com/ceph/ceph/blob/v19.2.1/src/vstart.sh#L1194">https://github.com/ceph/ceph/blob/v19.2.1/src/vstart.sh#L1194</a> 。</p>
<p>按照官方解释这两个参数是用来指定次要块设备的列表和类型，进一步分析 <a target="_blank" rel="noopener" href="https://docs.ceph.com/en/latest/dev/crimson/crimson/">crimson 官方文档</a> 我们发现这两个配置可用于实现 ceph 的冷热存储分离特性，即随着时间的推移逐步将较快设备（主设备）中的冷数据迁移到较慢的设备（次要设备）中，通常要求次要设备的速度不应该比主设备更快。我们能发现该特性与 <a target="_blank" rel="noopener" href="https://docs.ceph.com/en/latest/rados/operations/cache-tiering/">Cache Tiering</a> 特性比较相似，之后也会做一下对比分析。</p>
<p><strong>关于主设备剔除数据到次要设备的相关参数:</strong></p>
<ul>
<li><code>seastore_multiple_tiers_stop_evict_ratio</code>: 当主设备的使用率低于此值时，停止将冷数据逐出到冷层。默认值为 0.5 。</li>
<li><code>seastore_multiple_tiers_default_evict_ratio</code>: 当主设备的使用率达到此值时，开始将冷数据迁移到次要设备。默认值为 0.6 。</li>
<li><code>seastore_multiple_tiers_fast_evict_ratio</code>: 当主设备的使用率达到此值时，开始执行快速逐出。默认值为 0.7 。</li>
</ul>
<h1 id="八、模块解析"><a href="#八、模块解析" class="headerlink" title="八、模块解析"></a>八、模块解析</h1><h1 id="九、代码逻辑梳理"><a href="#九、代码逻辑梳理" class="headerlink" title="九、代码逻辑梳理"></a>九、代码逻辑梳理</h1><p><code>main</code> 函数中启动的 <code>seastar::async</code> 异步任务的关键逻辑如下:</p>
<ul>
<li>设置日志级别并打开日志文件；</li>
<li>启动 <code>prometheus api server</code> ；</li>
<li>创建 <code>client/cluster/hb_front/hb_back</code> 消息管理器 <code>SocketMessenger</code> ；</li>
<li>创建 <code>store</code> 对象；</li>
<li>创建、初始化、启动 <code>crimson osd</code> 对象；</li>
</ul>
<h2 id="9-1、消息管理器创建逻辑"><a href="#9-1、消息管理器创建逻辑" class="headerlink" title="9.1、消息管理器创建逻辑"></a>9.1、消息管理器创建逻辑</h2><p>通过调用 <code>crimson::net::Messenger::create</code> 函数来依次创建 <code>client/cluster/hb_front/hb_back</code> 消息管理器，最终创建的对象类型为 <code>SocketMessenger</code> 。</p>
<p>其中创建 <code>client/cluster</code> 消息对象的时候 <code>dispatch_only_on_this_shard</code> 参数为 <code>false</code> ，意味着接收到的消息可能会交由其他的 <code>shard</code> 进行处理；创建 <code>hb_front/hb_back</code> 消息对象的时候 <code>dispatch_only_on_this_shard</code> 参数为 <code>true</code> ，意味着接收到的消息仅会由当前 <code>shard</code> 处理。</p>
<h2 id="9-2、store-对象创建逻辑"><a href="#9-2、store-对象创建逻辑" class="headerlink" title="9.2、store 对象创建逻辑"></a>9.2、store 对象创建逻辑</h2><p>通过调用 <code>crimson::os::FuturizedStore::create</code> 函数来创建 <code>store</code> 对象。根据 <code>osd_objectstore</code> 和 <code>osd_data</code> 参数来配置 <code>store</code> 对象。其中 <code>osd_objectstore</code> 参数指定了后端对象存储的类型，支持的参数有 <code>alienstore/cyanstore/seastore</code> ，默认为 <code>alienstore</code> （即后端存储为 <code>bluestore</code> ）。其中 <code>osd_data</code> 参数指定了数据存储目录（比如当使用 <code>vstart.sh</code> 部署集群时，对应的配置默认为 <code>./build/dev/osd$id</code> ）。</p>
<p><strong>crimson 支持以下三个 objectstore 后端:</strong></p>
<ul>
<li>alienstore: 提供与早期版本的对象存储（即 BlueStore）的兼容性。</li>
<li>cyanstore: 用于测试的模拟后端，由易失性内存实施。此对象存储在典型的 osd 中的 memstore 后建模。</li>
<li>seastore: 为 crimson osd 设计的新对象存储。对多个分片支持的路径因后端的特定目标而异。</li>
</ul>
<h2 id="9-3、crimson-osd-mkfs-逻辑"><a href="#9-3、crimson-osd-mkfs-逻辑" class="headerlink" title="9.3、crimson osd mkfs 逻辑"></a>9.3、crimson osd mkfs 逻辑</h2><p>由于在启动 <code>osd</code> 组件之前，我们需要初始化 <code>osd</code> 的文件系统环境，为此需要执行 <code>OSD::mkfs</code> 函数（相关操作顺序可以参考 <code>vstart.sh</code> 脚本中在启动 <code>osd</code> 组件的步骤，其中在启动 <code>osd</code> 之前需要先对其存储路径的环境执行 <code>mkfs</code> 操作。）</p>
<p><strong>OSD::mkfs 函数中关键逻辑为:</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"><span class="number">1</span>. store<span class="selector-class">.start</span>()</span><br><span class="line">store<span class="selector-class">.mkfs</span>(osd_uuid) <span class="comment">// 重点</span></span><br><span class="line"><span class="number">2</span>. store<span class="selector-class">.mount</span>()</span><br><span class="line"><span class="number">3</span>. <span class="built_in">open_or_create_meta_coll</span>(store)</span><br><span class="line"><span class="number">4</span>. <span class="built_in">_write_superblock</span>(...)</span><br><span class="line"><span class="number">5</span>. store<span class="selector-class">.write_meta</span>(...)</span><br><span class="line"><span class="number">6</span>. store<span class="selector-class">.umount</span>()</span><br><span class="line"><span class="number">7</span>. store<span class="selector-class">.stop</span>()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>1. store.start()</strong></p>
</blockquote>
<p>由于 <code>store</code> 的类型存在三种： <code>alienstore/cyanstore/seastore</code> ， 所以对应的 start 逻辑也有三种。由于 <code>alienstore</code> 只是 <code>bluestore</code> 的代理，且实现比较简单，为此不做介绍；而 <code>cyanstore</code> 是作为一个内存存储模块而存在，仅作为开发测试使用，为此这里也不做介绍；所以以下仅介绍 <code>seastore</code> 的实现逻辑，对应的函数为 <code>SeaStore::start</code> 。</p>
<p><strong>SeaStore::start 函数中关联逻辑为:</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"><span class="number">1</span>. Device::<span class="built_in">make_device</span>(root, d_type)</span><br><span class="line"><span class="number">2</span>. device-&gt;<span class="built_in">start</span>()</span><br><span class="line"><span class="number">3</span>. shard_stores.<span class="built_in">start</span>(root, device.<span class="built_in">get</span>(), is_test)</span><br></pre></td></tr></table></figure>

<p><strong>1. Device::make_device(root, d_type) 逻辑解析:</strong><br>在 <code>seastore</code> 中有一个 <code>seastore_main_device_type</code> 参数，用于设置 <code>seastore</code> 主设备的类型，可选值为 <code>SSD/RANDOM_BLOCK_SSD</code> （代码中还实现了 <code>HDD/ZBD</code> ，但是目前并不支持） ，默认为 <code>SSD</code> 。</p>
<p><code>Device::make_device(root, d_type)</code> 函数内部在创建 <code>device</code> 的过程中，会针对不同的设备类型又做了一些区分，详细的类别分类如下:</p>
<table>
<thead>
<tr>
<th>device_type</th>
<th>backend_type</th>
<th>create func</th>
</tr>
</thead>
<tbody><tr>
<td>HDD</td>
<td>backend_type_t::SEGMENTED</td>
<td>SegmentManager::get_segment_manager</td>
</tr>
<tr>
<td>SSD</td>
<td>backend_type_t::SEGMENTED</td>
<td>SegmentManager::get_segment_manager</td>
</tr>
<tr>
<td>ZBD</td>
<td>backend_type_t::SEGMENTED</td>
<td>SegmentManager::get_segment_manager</td>
</tr>
<tr>
<td>RANDOM_BLOCK_SSD</td>
<td>backend_type_t::RANDOM_BLOCK</td>
<td>get_rb_device</td>
</tr>
</tbody></table>
<p>由于 <code>seastore_main_device_type</code> 默认为 <code>SSD</code> ，所以会通过 <code>SegmentManager::get_segment_manager</code> 函数来来创建一个 <code>segment_manager::block::BlockSegmentManager</code> 对象。</p>
<p><strong>2. device-&gt;start() 逻辑解析:</strong><br>当执行 <code>device-&gt;start()</code> 的时候，调用的就是 <code>BlockSegmentManager::start</code> 方法，继而调用的是 <code>shard_devices.start(device_path, superblock.config.spec.dtype)</code> ，由于 <code>shard_devices</code> 的类型为 <code>seastar::sharded</code> , 所以这里相当于调用了 <code>seastar::sharded::start</code> 函数来初始化了 <code>BlockSegmentManager</code> 对象。</p>
<p><strong>3. shard_stores.start(root, device.get(), is_test) 逻辑解析:</strong><br>之后的 <code>shard_stores.start(root, device.get(), is_test)</code> 函数执行中，由于 <code>shard_stores</code> 也是一个 <code>seastar::sharded</code> 封装的对象，所以其内部相当于调用了 <code>seastar::sharded::start</code> 函数来初始化了 <code>SeaStore::Shard</code> 对象。</p>
<blockquote>
<p><strong>2. store.mount()</strong></p>
</blockquote>
<p><code>store.mount()</code> 函数对应的是 <code>SeaStore::mount</code> 函数。</p>
<p><strong>SeaStore::mount 函数中关键逻辑为:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">device-&gt;<span class="built_in">mount</span>()</span><br><span class="line">device-&gt;<span class="built_in">get_sharded_device</span>()<span class="selector-class">.get_secondary_devices</span>()</span><br><span class="line">Device::<span class="built_in">make_device</span>(<span class="selector-tag">path</span>, dtype)</span><br><span class="line">sec_dev-&gt;<span class="built_in">start</span>()</span><br><span class="line">sec_dev-&gt;<span class="built_in">mount</span>()</span><br><span class="line"><span class="function"><span class="title">set_secondaries</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><code>device-&gt;mount()</code> 函数对应的是 BlockSegmentManager::mount 函数，这个之前解释过，其内部通过调用 <code>shard_devices.invoke_on_all</code> 来触发在每个 <code>shard</code> 中执行 <code>local_device.shard_mount()</code> 函数，因此每个 shard 中调用的函数其实是 <code>BlockSegmentManager::shard_mount()</code> ，该函数内部的执行逻辑主要包括打开 <code>device</code> ，读取 <code>superblock</code> 信息，校验 <code>superblock</code> 信息，更新 <code>tracker</code> 信息等。</p>
<blockquote>
<p><strong>3. open_or_create_meta_coll(store)</strong></p>
</blockquote>
<p><code>open_or_create_meta_coll(store)</code> 对应的函数是 <code>OSD::open_or_create_meta_coll</code> 。</p>
<p><strong>OSD::open_or_create_meta_coll 函数中关键逻辑为:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">store<span class="selector-class">.get_sharded_store</span>()<span class="selector-class">.open_collection</span>(coll_t::<span class="built_in">meta</span>())</span><br><span class="line">store<span class="selector-class">.get_sharded_store</span>()<span class="selector-class">.create_new_collection</span>(coll_t::<span class="built_in">meta</span>())</span><br><span class="line"><span class="function"><span class="title">OSDMeta</span><span class="params">(ch, store.get_sharded_store()</span></span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>4. _write_superblock(…)</strong></p>
</blockquote>
<p><code>_write_superblock(...)</code> 的完整调用为 <code>_write_superblock(store, std::move(meta_coll), std::move(superblock))</code> ，其对应的函数是 <code>OSD::_write_superblock</code> 。其内部主要的逻辑为将 <code>superblock</code> 信息写入存储中。</p>
<p><strong>OSD::_write_superblock 函数中关键逻辑为:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">meta_coll<span class="selector-class">.load_superblock</span>()</span><br><span class="line">meta_coll<span class="selector-class">.create</span>(t)</span><br><span class="line">meta_coll<span class="selector-class">.store_superblock</span>(t, superblock)</span><br><span class="line">store<span class="selector-class">.get_sharded_store</span>()<span class="selector-class">.do_transaction</span>(meta_coll<span class="selector-class">.collection</span>(), std::<span class="built_in">move</span>(t))</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>5. store.write_meta(…)</strong></p>
</blockquote>
<p>store.write_meta(…) 对应很多写元信息的操作，操作的元信息包括 <code>ceph_fsid</code> ，<code>magic</code> ，<code>whoami</code> ，<code>osd_key</code> ， <code>osdspec_affinity</code> ， <code>ready</code> 等字段。这些信息位于 <code>osd</code> 运行目录的各个配置对应的文件中。</p>
<blockquote>
<p><strong>6. store.umount()</strong></p>
</blockquote>
<p><code>store.umount()</code> 对应的函数为 <code>SeaStore::umount</code> ， 其内部会同通过调用 <code>shard_stores.invoke_on_all</code> 函数，让每个 <code>shard</code> 执行 <code>local_store.umount()</code> 函数。</p>
<blockquote>
<p><strong>7. store.stop()</strong></p>
</blockquote>
<p><code>store.stop()</code> 对应的函数为 <code>SeaStore::stop</code> 。</p>
<p><strong>SeaStore::stop 函数中关键逻辑为:</strong></p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">c</span></span><br><span class="line"><span class="variable">sec_dev</span>-&gt;<span class="function"><span class="title">stop</span>()</span></span><br><span class="line"><span class="variable">secondaries.clear</span>()</span><br><span class="line"><span class="variable">device</span>-&gt;<span class="function"><span class="title">stop</span>()</span></span><br><span class="line"><span class="variable">shard_stores.stop</span>()</span><br></pre></td></tr></table></figure>

<h3 id="9-3-1、store-mkfs-osd-uuid"><a href="#9-3-1、store-mkfs-osd-uuid" class="headerlink" title="9.3.1、store.mkfs(osd_uuid)"></a>9.3.1、store.mkfs(osd_uuid)</h3><p><strong>SeaStore::mkfs 函数中关键逻辑为:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"><span class="number">1</span>. <span class="built_in">read_meta</span>(<span class="string">&quot;mkfs_done&quot;</span>)</span><br><span class="line"><span class="number">2</span>. seastar::<span class="built_in">open_directory</span>(root)</span><br><span class="line">        root_f-&gt;<span class="built_in">list_directory</span>(...)</span><br><span class="line">            Device::<span class="built_in">make_device</span>(<span class="selector-tag">path</span>, dtype)</span><br><span class="line">            secondaries<span class="selector-class">.emplace_back</span>(std::<span class="built_in">move</span>(sec_dev))</span><br><span class="line">            p_sec_dev-&gt;<span class="built_in">start</span>()</span><br><span class="line">            p_sec_dev-&gt;<span class="built_in">mkfs</span>()</span><br><span class="line">            <span class="built_in">set_secondaries</span>()</span><br><span class="line"><span class="number">3</span>. device-&gt;<span class="built_in">mkfs</span>(...)</span><br><span class="line"><span class="number">4</span>. device-&gt;<span class="built_in">mount</span>()</span><br><span class="line"><span class="number">5</span>. local_store<span class="selector-class">.mkfs_managers</span>() <span class="comment">// shard_stores.invoke_on_all(...) // 重点</span></span><br><span class="line"><span class="number">6</span>. <span class="built_in">prepare_meta</span>(new_osd_fsid)</span><br><span class="line"><span class="number">7</span>. <span class="built_in">umount</span>()</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>read_meta(“mkfs_done”)</li>
</ol>
</blockquote>
<p><code>read_meta(&quot;mkfs_done&quot;)</code> 用于校验之前是否已经执行过 <code>mkfs</code> 操作，监测方式为读取 <code>store</code> 目录中的 <code>mkfs_done</code> 文件中的内容。</p>
<blockquote>
<ol>
<li>seastar::open_directory(root)</li>
</ol>
</blockquote>
<p><code>seastar::open_directory(root)</code> 的逻辑为检索 <code>store</code> 目录中的文件，筛选前缀名为 <code>block.</code> 的文件&#x2F;目录，通过解析该文件&#x2F;目录的后缀，从而尝试调用 <code>Device::make_device(path, dtype)</code> 函数来创建对应的 <code>device</code> ， 进而操作对应的 <code>device</code> 执行 <code>start</code> 和 <code>mkfs</code> 函数操作。</p>
<blockquote>
<ol>
<li>device-&gt;mkfs(…)</li>
</ol>
</blockquote>
<p><code>device-&gt;mkfs(...)</code> 对应的完整函数为 <code>device-&gt;mkfs(device_config_t::create_primary(new_osd_fsid, id, d_type, sds))</code> ， 由于 <code>seastore_main_device_type</code> 默认为 <code>SSD</code> ，所以这里的 <code>device-&gt;mkfs</code> 指的是 <code>BlockSegmentManager::mkfs</code> 函数。</p>
<p><code>BlockSegmentManager::mkfs</code> 函数中关键逻辑为:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">shard_devices<span class="selector-class">.local</span>()<span class="selector-class">.primary_mkfs</span>(sm_config)</span><br><span class="line">    <span class="built_in">check_create_device</span>(device_path, size)</span><br><span class="line">    <span class="built_in">open_device</span>(device_path)</span><br><span class="line">    <span class="built_in">make_superblock</span>(get_device_id(), sm_config, stat)</span><br><span class="line">    <span class="built_in">write_superblock</span>(get_device_id(), device, sb)</span><br><span class="line">    device<span class="selector-class">.close</span>()</span><br><span class="line">local_device<span class="selector-class">.shard_mkfs</span>() <span class="comment">// shard_devices.invoke_on_all(...)</span></span><br><span class="line">    <span class="built_in">open_device</span>(device_path)</span><br><span class="line">    <span class="built_in">read_superblock</span>(device, sd)</span><br><span class="line">    sb<span class="selector-class">.validate</span>()</span><br><span class="line">    tracker<span class="selector-class">.reset</span>(new SegmentStateTracker(shard_info.segments, sb.block_size))</span><br><span class="line">    tracker-&gt;<span class="built_in">write_out</span>(get_device_id(), device, shard_info<span class="selector-class">.tracker_offset</span>)</span><br><span class="line">    device<span class="selector-class">.close</span>()</span><br></pre></td></tr></table></figure>

<p>其中 <code>shard_devices.local().primary_mkfs(sm_config)</code> 对应的函数为 <code>BlockSegmentManager::primary_mkfs</code> 。其内部逻辑如下:</p>
<ul>
<li><code>check_create_device(device_path, size)</code>: 通过 <code>seastar::open_file_dma</code> 函数来打开对应的 <code>block</code> 文件，并通过 <code>f.truncate</code> 和 <code>f.allocate(0, size)</code> 函数来调整对应文件的大小，用于后续存储数据。该步骤中的 <code>seastore_block_create</code> 配置用于控制是否创建 <code>block</code> ， 该参数默认为 <code>true</code> ；<code>seastore_device_size</code> 配置用于控制 <code>block</code> 的文件大小，该参数默认为 <code>50GB</code> 。</li>
<li><code>open_device(device_path)</code>: 通过 <code>seastar::open_file_dma</code> 方法来打开对应的 <code>block</code> 文件，用于后续的数据操作。</li>
<li><code>make_superblock(get_device_id(), sm_config, stat)</code>: 初始化 <code>superblock</code> 信息。其内部根据 <code>seastar::smp::count</code> 的数量，<code>seastore_segment_size</code> 参数（用于控制单个 <code>segment</code> 的大小，默认为 <code>64M</code> ）等信息来初始化 <code>superblock</code> 信息。</li>
<li><code>write_superblock(get_device_id(), device, sb)</code>: 将序列化后的 <code>superblock</code> 信息写入 <code>block</code> 的文件头部。</li>
<li><code>device.close()</code>: 关闭打开的 <code>device</code> 。</li>
</ul>
<p>之后通过调用 <code>shard_devices.invoke_on_all(...)</code> 函数，该函数是 <code>Seastar</code> 框架中使用的方法，用于在所有的 <code>seastar shard</code> 上执行给定的函数。之后每个 <code>shard</code> 上执行 <code>local_device.shard_mkfs()</code> 函数。其内部回依次打开 <code>device</code> ，读取 <code>superblock</code> 信息，校验 <code>superblock</code> 信息，更新 <code>tracker</code> 信息等；之后便关闭 <code>device</code> 。</p>
<blockquote>
<ol>
<li>device-&gt;mount()</li>
</ol>
</blockquote>
<p><code>device-&gt;mount()</code> 对应的函数为 <code>BlockSegmentManager::mount</code> 。</p>
<p><code>BlockSegmentManager::mount</code> 函数中关键逻辑为:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">local_device<span class="selector-class">.shard_mount</span>() <span class="comment">// shard_devices.invoke_on_all(...)</span></span><br></pre></td></tr></table></figure>

<p>这里也是通过调用 <code>shard_devices.invoke_on_all</code> 来触发在每个 <code>shard</code> 中执行 <code>local_device.shard_mount()</code> 函数，因此每个 shard 中调用的函数其实是 <code>BlockSegmentManager::shard_mount()</code> ，该函数内部的执行逻辑主要包括打开 <code>device</code> ，读取 <code>superblock</code> 信息，校验 <code>superblock</code> 信息，更新 <code>tracker</code> 信息等。</p>
<blockquote>
<ol>
<li>local_store.mkfs_managers()</li>
</ol>
</blockquote>
<p>接着又通过调用 <code>shard_stores.invoke_on_all(...)</code> 来触发在每个 <code>shard</code> 中执行 <code>local_store.mkfs_managers()</code> 操作，对应的函数为 <code>SeaStore::Shard::mkfs_managers</code> 。</p>
<p><code>SeaStore::Shard::mkfs_managers</code> 函数中关键逻辑为:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"><span class="built_in">init_managers</span>()</span><br><span class="line">transaction_manager-&gt;<span class="built_in">mkfs</span>()</span><br><span class="line"><span class="built_in">init_managers</span>()</span><br><span class="line">transaction_manager-&gt;<span class="built_in">mount</span>()</span><br><span class="line"><span class="built_in">repeat_eagain</span>(...)</span><br><span class="line">    transaction_manager-&gt;<span class="built_in">with_transaction_intr</span>(...)</span><br><span class="line">        onode_manager-&gt;<span class="built_in">mkfs</span>(t)</span><br><span class="line">        collection_manager-&gt;<span class="built_in">mkfs</span>(t)</span><br><span class="line">        transaction_manager-&gt;<span class="built_in">write_collection_root</span>(t, coll_root)</span><br><span class="line">        transaction_manager-&gt;<span class="built_in">submit_transaction</span>(t)</span><br></pre></td></tr></table></figure>

<p>其中 <code>init_managers()</code> 函数指的是 <code>SeaStore::Shard::init_managers()</code> 函数，其内部会初始化 <code>transaction_manager</code> ， <code>collection_manager</code> ， <code>onode_manager</code> 对象。</p>
<ul>
<li><code>transaction_manager</code>: 初始化函数为 <code>TransactionManagerRef make_transaction_manager</code> ，该对象显然用于管理存储设备上的事务。</li>
<li><code>collection_manager</code>: 初始化函数为 <code>FlatCollectionManager::FlatCollectionManager</code> ；</li>
<li><code>onode_manager</code>: 初始化函数为 <code>FLTreeOnodeManager::FLTreeOnodeManager</code> ；</li>
</ul>
<p><strong>transaction_manager 相关执行逻辑:</strong></p>
<ul>
<li><code>transaction_manager-&gt;mkfs()</code>: 对应 <code>TransactionManager::mkfs</code> 函数；</li>
<li><code>transaction_manager-&gt;mount()</code>: 对应 <code>TransactionManager::mount</code> 函数；</li>
<li><code>transaction_manager-&gt;with_transaction_intr(...)</code>: 对应 <code>ExtentCallbackInterface::with_transaction_intr</code> 函数；</li>
</ul>
<p>其中 <code>TransactionManager::mkfs</code> 函数中关键逻辑为:</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">c</span></span><br><span class="line"><span class="variable">epm</span>-&gt;<span class="function"><span class="title">mount</span>()</span></span><br><span class="line"><span class="variable">journal</span>-&gt;<span class="function"><span class="title">open_for_mkfs</span>()</span></span><br><span class="line"><span class="variable">epm</span>-&gt;<span class="function"><span class="title">open_for_write</span>()</span></span><br><span class="line"><span class="function"><span class="title">with_transaction_intr</span>(...)</span></span><br><span class="line"><span class="function"><span class="title">close</span>()</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>TransactionManager::mount</code> 函数中关键逻辑为:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">cache-&gt;<span class="built_in">init</span>()</span><br><span class="line">epm-&gt;<span class="built_in">mount</span>()</span><br><span class="line">journal-&gt;<span class="built_in">replay</span>(...)</span><br><span class="line">journal-&gt;<span class="built_in">open_for_mount</span>()</span><br><span class="line">journal-&gt;<span class="built_in">get_trimmer</span>()<span class="selector-class">.set_journal_head</span>(start_seq)</span><br><span class="line"><span class="built_in">with_transaction_weak</span>(...)</span><br><span class="line">epm-&gt;<span class="built_in">open_for_write</span>()</span><br><span class="line">epm-&gt;<span class="built_in">start_background</span>()</span><br></pre></td></tr></table></figure>

<p>TODO:</p>
<p><strong>onode_manager 相关执行逻辑:</strong></p>
<p>相关操作为 onode_manager-&gt;mkfs(t) ， 对应的函数为 FLTreeOnodeManager::mkfs 函数。 之后继续调用 Btree::mkfs &#x3D;&gt; Node::mkfs</p>
<p>TODO:</p>
<p><strong>collection_manager 相关执行逻辑:</strong></p>
<p>相关操作为 collection_manager-&gt;mkfs(t)</p>
<p>TODO:</p>
<blockquote>
<ol>
<li>prepare_meta(new_osd_fsid)</li>
</ol>
</blockquote>
<p><code>prepare_meta(new_osd_fsid)</code> 函数对应的是 <code>SeaStore::prepare_meta</code> 函数，其内部主要是写入一些元信息到对应的数据目录的文件中，包括向 <code>fsid</code> 文件中写入集群 id 信息；向 <code>type</code> 文件中写入后后端存储类型（比如 <code>seastore</code> ） ； 往 <code>mkfs_done</code> 文件中写入 <code>yes</code> 。</p>
<blockquote>
<ol>
<li>umount()</li>
</ol>
</blockquote>
<p><code>umount()</code> 函数对应的是 <code>SeaStore::umount</code> 函数，其内部会通过 <code>shard_stores.invoke_on_all</code> 函数通知所有的 <code>shard</code> 执行 <code>local_store.umount()</code> 操作。</p>
<h2 id="9-4、crimson-osd-start-逻辑"><a href="#9-4、crimson-osd-start-逻辑" class="headerlink" title="9.4、crimson osd start 逻辑"></a>9.4、crimson osd start 逻辑</h2><p>当 <code>osd</code> 通过 <code>mkfs</code> 初始化之后才会被正式的启动，这时候就会调用 <code>OSD::start</code> 函数启动。需要注意该函数内部限制当前的 <code>shard</code> 为 <code>PRIMARY_CORE</code> 。其中 <code>store.start()</code> 和 <code>store.mount()</code> 的执行逻辑之前在 <code>osd mkfs</code> 的逻辑中已经描述过了，这里不再赘述。部分实现比较详细或逻辑接近，因此放在一块一起解释。</p>
<p><strong>OSD::start 函数中关键逻辑为:</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"></span><br><span class="line">store<span class="selector-class">.start</span>()</span><br><span class="line"><span class="number">1</span>. pg_to_shard_mappings<span class="selector-class">.start</span>(...)</span><br><span class="line"><span class="number">2</span>. osd_singleton_state<span class="selector-class">.start_single</span>(...)</span><br><span class="line"><span class="number">3</span>. osd_states<span class="selector-class">.start</span>()</span><br><span class="line"><span class="number">4</span>. shard_services<span class="selector-class">.start</span>(...)</span><br><span class="line"><span class="number">5</span>. heartbeat<span class="selector-class">.reset</span>(...)</span><br><span class="line">store<span class="selector-class">.mount</span>()</span><br><span class="line"><span class="number">6</span>. local_service<span class="selector-class">.report_stats</span>() <span class="comment">// shard_services.invoke_on_all(...)</span></span><br><span class="line"><span class="number">7</span>. store<span class="selector-class">.report_stats</span>()</span><br><span class="line"><span class="number">8</span>. stats_timer<span class="selector-class">.arm_periodic</span>(...)</span><br><span class="line"><span class="number">9</span>. <span class="built_in">open_meta_coll</span>()</span><br><span class="line"><span class="number">10</span>. pg_shard_manager<span class="selector-class">.get_meta_coll</span>()<span class="selector-class">.load_superblock</span>()</span><br><span class="line"><span class="number">11</span>. pg_shard_manager<span class="selector-class">.set_superblock</span>(superblock)</span><br><span class="line"><span class="number">12</span>. pg_shard_manager<span class="selector-class">.get_local_map</span>(superblock.current_epoch)</span><br><span class="line"><span class="number">13</span>. pg_shard_manager<span class="selector-class">.update_map</span>(std::move(map))</span><br><span class="line"><span class="number">14</span>. local_service<span class="selector-class">.local_state</span><span class="selector-class">.osdmap_gate</span><span class="selector-class">.got_map</span>(...) <span class="comment">// shard_services.invoke_on_all(...)</span></span><br><span class="line"><span class="number">15</span>. pg_shard_manager<span class="selector-class">.load_pgs</span>(store)</span><br><span class="line"><span class="number">16</span>. cluster_msgr-&gt;<span class="built_in">bind</span>(pick_addresses(CEPH_PICK_ADDRESS_CLUSTER))</span><br><span class="line">    cluster_msgr-&gt;<span class="built_in">start</span>(dispatchers)</span><br><span class="line">    public_msgr-&gt;<span class="built_in">bind</span>(pick_addresses(CEPH_PICK_ADDRESS_PUBLIC))</span><br><span class="line">    public_msgr-&gt;<span class="built_in">start</span>(dispatchers)</span><br><span class="line"><span class="number">17</span>. monc-&gt;<span class="built_in">start</span>()</span><br><span class="line">    mgrc-&gt;<span class="built_in">start</span>()</span><br><span class="line"><span class="number">18</span>. <span class="built_in">_add_me_to_crush</span>()</span><br><span class="line"><span class="number">19</span>. monc-&gt;<span class="built_in">renew_subs</span>()</span><br><span class="line"><span class="number">20</span>. heartbeat-&gt;<span class="built_in">start</span>(...)</span><br><span class="line"><span class="number">21</span>. <span class="built_in">start_asok_admin</span>()</span><br><span class="line"><span class="number">22</span>. log_client<span class="selector-class">.set_fsid</span>(monc-&gt;get_fsid())</span><br><span class="line"><span class="number">23</span>. <span class="built_in">start_boot</span>()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>1. pg_to_shard_mappings.start(…)</strong></p>
</blockquote>
<p><code>pg_to_shard_mappings.start(...)</code> 的原始调用信息为 <code>pg_to_shard_mappings.start(0, seastar::smp::count)</code> 。由于 <code>pg_to_shard_mappings</code> 的定义为 <code>seastar::sharded pg_to_shard_mappings</code> ，因此这里的 <code>start</code> 函数其实是调用 <code>seastar::sharded::start</code> 函数来初始化了 <code>PGShardMapping</code> 对象。在 <code>PGShardMapping</code> 对象初始化的过程中会向其内部的成员变量 <code>std::map core_to_num_pgs</code> 中添加 <code>seastar::smp::count</code> 个元素。</p>
<blockquote>
<p><strong>2. osd_singleton_state.start_single(…)</strong></p>
</blockquote>
<p><code>osd_singleton_state.start_single(...)</code> 的原始调用信息为 <code>osd_singleton_state.start_single(whoami, std::ref(*cluster_msgr), std::ref(*public_msgr), std::ref(*monc), std::ref(*mgrc))</code> 。由于 <code>osd_singleton_state</code> 的定义为 <code>seastar::sharded osd_singleton_state</code> ，因此这里的 <code>start_single</code> 函数其实是调用了 <code>seastar::sharded::start_single</code> 函数来创建了一个 <code>OSDSingletonState</code> 对象。在 <code>OSDSingletonState</code> 对象初始化的过程中会创建一些 <code>perf</code> 和 <code>recoverystate_perf</code> 对象指针。</p>
<blockquote>
<p><strong>3. osd_states.start()</strong></p>
</blockquote>
<p>由于 <code>osd_states</code> 的定义为 <code>seastar::sharded osd_states</code> ，因此这里的 <code>start</code> 函数其实是调用 <code>seastar::sharded::start</code> 函数来初始化了 <code>OSDState</code> 对象。</p>
<blockquote>
<p><strong>4. shard_services.start(…)</strong></p>
</blockquote>
<p><code>shard_services.start(...)</code> 的原始调用信息为 <code>shard_services.start(std::ref(osd_singleton_state), std::ref(pg_to_shard_mappings), whoami, startup_time, osd_singleton_state.local().perf, osd_singleton_state.local().recoverystate_perf, std::ref(store), std::ref(osd_states))</code> 。由于 <code>shard_services</code> 的定义为 <code>seastar::sharded shard_services</code> ，因此这里的 <code>start</code> 函数其实是调用 <code>seastar::sharded::start</code> 函数来初始化了 <code>ShardServices</code> 对象。</p>
<blockquote>
<p><strong>5. heartbeat.reset(…)</strong></p>
</blockquote>
<p>重置 <code>heartbeat</code> 对象。</p>
<blockquote>
<p><strong>6. local_service.report_stats()</strong></p>
</blockquote>
<p>该函数的调用被封装在 <code>shard_services.invoke_on_all</code> 内部，意味着这会让每个 <code>shard</code> 执行 <code>local_service.report_stats()</code> 函数。但是只有在 <code>crimson_osd_stat_interval</code> 配置了非零的情况下才会执行该逻辑。 <code>crimson_osd_stat_interval</code> 参数默认为 <code>0</code> 。</p>
<blockquote>
<p><strong>7. store.report_stats()</strong></p>
</blockquote>
<p><code>store.report_stats()</code> 对应的函数为 <code>SeaStore::report_stats</code> 。</p>
<p><strong>SeaStore::report_stats 函数中关键逻辑为:</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">local_store<span class="selector-class">.get_device_stats</span>(report_detail) <span class="comment">// shard_stores.invoke_on_all</span></span><br><span class="line">local_store<span class="selector-class">.get_io_stats</span>(report_detail) <span class="comment">// shard_stores.invoke_on_all</span></span><br><span class="line"><span class="built_in">INFO</span>(...);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>8. stats_timer.arm_periodic(…)</strong></p>
</blockquote>
<p><code>stats_timer.arm_periodic(...)</code> 对应的原始调用为 <code>stats_timer.arm_periodic(std::chrono::seconds(stats_seconds))</code> 。用于设置一个周期性的定时器，该定时器的运行是由 <code>Seastar</code> 框架的事件循环管理的，与函数调用的生命周期无关。</p>
<blockquote>
<p><strong>9. open_meta_coll</strong></p>
</blockquote>
<p><code>open_meta_coll</code> 对应的函数为 <code>OSD::open_meta_coll</code> 。需要注意该逻辑仅限 <code>PRIMARY_CORE</code> 对应的 <code>shard</code> 执行。</p>
<p><strong>SeaStore::report_stats 函数中关键逻辑为:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">store.get_sharded_store().open_collection(coll_t::meta())</span><br><span class="line">pg_shard_manager.init_meta_coll(ch, store.get_sharded_store())</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>10. pg_shard_manager.get_meta_coll().load_superblock()</strong></p>
</blockquote>
<p>对应的函数为 <code>OSDMeta::load_superblock</code> 。用于从 <code>store</code> 存储中读取 <code>superblock</code> 信息。</p>
<blockquote>
<p><strong>11. pg_shard_manager.set_superblock(superblock)</strong></p>
</blockquote>
<p>对应的函数为 <code>PGShardManager::set_superblock</code> 。</p>
<p><strong>PGShardManager::set_superblock 函数中关键逻辑为:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"><span class="function"><span class="title">get_osd_singleton_state</span><span class="params">()</span></span><span class="selector-class">.set_singleton_superblock</span>(superblock)</span><br><span class="line">local_service<span class="selector-class">.local_state</span><span class="selector-class">.update_shard_superblock</span>(superblock) <span class="comment">// shard_services.invoke_on_all</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>12. pg_shard_manager.get_local_map(superblock.current_epoch)</strong></p>
</blockquote>
<p>对应的函数为 <code>OSDSingletonState::get_local_map</code> 。</p>
<blockquote>
<p><strong>13. pg_shard_manager.update_map(std::move(map))</strong></p>
</blockquote>
<p>对应的函数为 <code>PGShardManager::update_map</code> 。</p>
<p><strong>PGShardManager::update_map 函数中关键逻辑为:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"><span class="function"><span class="title">get_osd_singleton_state</span><span class="params">()</span></span><span class="selector-class">.update_map</span>(...)</span><br><span class="line">local<span class="selector-class">.local_state</span><span class="selector-class">.update_map</span>(...) <span class="comment">// shard_services.invoke_on_all</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>14. local_service.local_state.osdmap_gate.got_map(…)</strong></p>
</blockquote>
<p>原始的调用为 <code>local_service.local_state.osdmap_gate.got_map(osdmap-&gt;get_epoch())</code> ， 该函数的调用被封装在 <code>shard_services.invoke_on_all</code> 内部，意味着这会让每个 <code>shard</code> 执行 <code>local_service.local_state.osdmap_gate.got_map(osdmap-&gt;get_epoch())</code> 函数。</p>
<blockquote>
<p><strong>15. pg_shard_manager.load_pgs(store)</strong></p>
</blockquote>
<p>对应的函数为 <code>PGShardManager::load_pgs</code> 。</p>
<p><strong>PGShardManager::load_pgs 函数中关键逻辑为:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">store.list_collections()</span><br><span class="line">// seastar::parallel_for_each</span><br><span class="line">get_pg_to_shard_mapping().get_or_create_pg_mapping(pgid, shard_core)</span><br><span class="line">shard_services.load_pg(pgid)</span><br><span class="line">per_shard_state.pg_map.pg_loaded(pgid, std::<span class="keyword">move</span>(pg))</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>16. cluster_msgr 和 public_msgr</strong></p>
</blockquote>
<p><strong>对应的批量的原始调用为:</strong></p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">c</span></span><br><span class="line"><span class="variable">cluster_msgr</span>-&gt;<span class="function"><span class="title">bind</span>(<span class="title">pick_addresses</span>(<span class="variable">CEPH_PICK_ADDRESS_CLUSTER</span>))</span></span><br><span class="line"><span class="variable">cluster_msgr</span>-&gt;<span class="function"><span class="title">start</span>(<span class="variable">dispatchers</span>)</span></span><br><span class="line"><span class="variable">public_msgr</span>-&gt;<span class="function"><span class="title">bind</span>(<span class="title">pick_addresses</span>(<span class="variable">CEPH_PICK_ADDRESS_PUBLIC</span>))</span></span><br><span class="line"><span class="variable">public_msgr</span>-&gt;<span class="function"><span class="title">start</span>(<span class="variable">dispatchers</span>)</span></span><br></pre></td></tr></table></figure>

<p><code>pick_addresses</code> 函数执行的时候，其内部仅会选择 <code>message v2</code> 的地址，因此从这里可以看出在 <code>crimson osd</code> 中不支持 <code>message v1</code> 。</p>
<p><code>bind</code> 函数对应的是 <code>SocketMessenger::bind</code> 。 <code>start</code> 函数对应的是 <code>SocketMessenger::start</code> 。</p>
<p><strong>SocketMessenger::bind 函数中关键逻辑为:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"><span class="function"><span class="title">try_bind</span><span class="params">(addrs, local_conf()</span></span>-&gt;ms_bind_port_min, <span class="built_in">local_conf</span>()-&gt;ms_bind_port_max)</span><br><span class="line"><span class="function"><span class="title">do_listen</span><span class="params">(entity_addrvec_t&#123;to_bind&#125;)</span></span></span><br><span class="line">ShardedServerSocket::<span class="built_in">create</span>(dispatch_only_on_sid)</span><br><span class="line">listener-&gt;<span class="built_in">listen</span>(listen_addr)</span><br><span class="line">    seastar::<span class="built_in">listen</span>(s_addr, lo) <span class="comment">// this-&gt;container().invoke_on_all</span></span><br></pre></td></tr></table></figure>

<p>从上面中可以看出会让每个 <code>shard</code> 都监听相同的端口。</p>
<p><strong>SocketMessenger::start 函数中关键逻辑为:</strong></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">listener-&gt;accept([this](<span class="name">SocketRef</span> _socket, entity_addr_t peer_addr) &#123;</span><br><span class="line">    assert(<span class="name">get_myaddr</span>().is_msgr2())<span class="comment">;</span></span><br><span class="line">    SocketFRef socket = seastar:<span class="symbol">:make_foreign</span>(<span class="name">std</span>:<span class="symbol">:move</span>(<span class="name">_socket</span>))<span class="comment">;</span></span><br><span class="line">    // 对于 client 和 cluster 的消息，这里的 fix 是 false </span><br><span class="line">    // 对于 heart beat 的消息，这里的 fix 是 true</span><br><span class="line">    if (<span class="name">listener-&gt;is_fixed_shard_dispatching</span>()) &#123;</span><br><span class="line">        return accept(<span class="name">std</span>:<span class="symbol">:move</span>(<span class="name">socket</span>), peer_addr)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        // 转发请求到对应的 shard 中</span><br><span class="line">        return seastar:<span class="symbol">:smp</span>:<span class="symbol">:submit_to</span>(<span class="name">sid</span>, [this, peer_addr, socket = std:<span class="symbol">:move</span>(<span class="name">socket</span>)]() mutable &#123;</span><br><span class="line">            return accept(<span class="name">std</span>:<span class="symbol">:move</span>(<span class="name">socket</span>), peer_addr)<span class="comment">;</span></span><br><span class="line">        &#125;)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>17. monc 和 mgrc 的 start</strong></p>
</blockquote>
<p><strong>对应的批量的原始调用为:</strong></p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">c</span></span><br><span class="line"><span class="variable">monc</span>-&gt;<span class="function"><span class="title">start</span>()</span></span><br><span class="line"><span class="variable">mgrc</span>-&gt;<span class="function"><span class="title">start</span>()</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>monc-&gt;start()</code> 对应的函数为 <code>crimson::mon::Client::start</code> 。 <code>mgrc-&gt;start()</code> 对应的函数为 <code>crimson::mgr::Client::start</code> 。</p>
<p><strong>crimson::mon::Client::start 函数中关键逻辑为:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">auth_registry<span class="selector-class">.refresh_config</span>()</span><br><span class="line"><span class="function"><span class="title">load_keyring</span><span class="params">()</span></span></span><br><span class="line">monmap<span class="selector-class">.build_initial</span>(crimson::common::<span class="built_in">local_conf</span>(), false)</span><br><span class="line"><span class="function"><span class="title">authenticate</span><span class="params">()</span></span></span><br><span class="line">timer<span class="selector-class">.arm_periodic</span>(interval)</span><br></pre></td></tr></table></figure>

<p><strong>crimson::mgr::Client::start 函数中关键逻辑为:</strong></p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">c</span></span><br><span class="line"><span class="variable">seastar</span>::<span class="function"><span class="title"><span class="built_in">now</span></span>()</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>18. _add_me_to_crush()</strong></p>
</blockquote>
<p>该函数对应的是 <code>OSD::_add_me_to_crush</code> 。在该函数中，如果 <code>osd_crush_update_on_start</code> 配置为 <code>true</code> ，则会在 <code>osd</code> 启动时尝试将自己的信息添加到 <code>crush map</code> 中。</p>
<p><strong>OSD::_add_me_to_crush 函数中关键逻辑为:</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line"><span class="function"><span class="title">local_conf</span><span class="params">()</span></span>.get_val&lt;bool&gt;(<span class="string">&quot;osd_crush_update_on_start&quot;</span>)</span><br><span class="line"><span class="function"><span class="title">local_conf</span><span class="params">()</span></span>.get_val&lt;double&gt;(<span class="string">&quot;osd_crush_initial_weight&quot;</span>)</span><br><span class="line">store<span class="selector-class">.stat</span>()</span><br><span class="line"><span class="function"><span class="title">get_weight</span><span class="params">()</span></span></span><br><span class="line">loc<span class="selector-class">.init_on_startup</span>()</span><br><span class="line">monc-&gt;<span class="built_in">run_command</span>(std::<span class="built_in">move</span>(cmd), &#123;&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>19. monc-&gt;renew_subs()</strong></p>
</blockquote>
<p>对应的函数为 <code>crimson::mon::Client::renew_subs</code> 。 内部逻辑为向 <code>monitor</code> 发送 <code>CEPH_MSG_MON_SUBSCRIBE</code> 消息，用于订阅 <code>osd_pg_creates</code> ， <code>mgrmap</code> ， <code>osdmap</code> 的变更消息。</p>
<blockquote>
<p><strong>20. heartbeat-&gt;start(…)</strong></p>
</blockquote>
<p>原始的调用为 <code>heartbeat-&gt;start(pick_addresses(CEPH_PICK_ADDRESS_PUBLIC), pick_addresses(CEPH_PICK_ADDRESS_CLUSTER))</code> , 对应的函数为 <code>Heartbeat::start</code> 。</p>
<blockquote>
<p><strong>21. start_asok_admin()</strong></p>
</blockquote>
<p>对应的函数为 <code>OSD::start_asok_admin</code> 。 用于创建本地的 <code>socket</code> 文件，并注册可执行的命令。</p>
<blockquote>
<p><strong>22. log_client.set_fsid(monc-&gt;get_fsid())</strong></p>
</blockquote>
<p>设置日志记录中的 <code>fsid</code> 信息。</p>
<blockquote>
<p><strong>23. start_boot()</strong></p>
</blockquote>
<p>对应的函数为 <code>OSD::start_boot</code> 。</p>
<p><strong>OSD::start_boot 函数中关键逻辑为:</strong></p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">pg_shard_manager.set_preboot()</span><br><span class="line">monc-&gt;get_version(&quot;osdmap&quot;)</span><br><span class="line">_preboot(oldest, newest)</span><br></pre></td></tr></table></figure>

<h1 id="十、相关资料"><a href="#十、相关资料" class="headerlink" title="十、相关资料"></a>十、相关资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://ceph.io/en/news/crimson/">https://ceph.io/en/news/crimson/</a></li>
<li><a target="_blank" rel="noopener" href="https://ceph.io/en/news/blog/2023/crimson-multi-core-scalability/">https://ceph.io/en/news/blog/2023/crimson-multi-core-scalability/</a></li>
<li><a target="_blank" rel="noopener" href="https://ceph.io/en/news/blog/2025/crimson-T-release/">https://ceph.io/en/news/blog/2025/crimson-T-release/</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.ceph.com/en/latest/dev/crimson/crimson/">https://docs.ceph.com/en/latest/dev/crimson/crimson/</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.ceph.com/en/latest/cephadm/install/#bootstrap-a-new-cluster">https://docs.ceph.com/en/latest/cephadm/install/#bootstrap-a-new-cluster</a></li>
<li><a target="_blank" rel="noopener" href="https://www.51cto.com/article/749735.html">https://www.51cto.com/article/749735.html</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/667949613">https://zhuanlan.zhihu.com/p/667949613</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.redhat.com/zh-cn/documentation/red_hat_ceph_storage/7/html/administration_guide/crimson">https://docs.redhat.com/zh-cn/documentation/red_hat_ceph_storage/7/html/administration_guide/crimson</a></li>
<li><a target="_blank" rel="noopener" href="https://ceph.io/en/news/blog/2023/crimson-multi-core-scalability/">https://ceph.io/en/news/blog/2023/crimson-multi-core-scalability/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.icviews.cn/semiCommunity/postDetail/6586">https://www.icviews.cn/semiCommunity/postDetail/6586</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Crimson/" rel="tag"># Crimson</a>
              <a href="/tags/Seastore/" rel="tag"># Seastore</a>
              <a href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" rel="tag"># 异步编程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/09/19/mymap_myset/" rel="prev" title="Mymap Myset">
      <i class="fa fa-chevron-left"></i> Mymap Myset
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/09/19/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/" rel="next" title="约瑟夫环问题">
      约瑟夫环问题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC82MDkyNS8zNzM5NQ=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%9E%B6%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.</span> <span class="nav-text">一、架构对比</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">二、配置解析流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">三、网络通信流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">四、线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1%E3%80%81shard-%E7%9B%B8%E5%85%B3%E4%BB%BB%E5%8A%A1"><span class="nav-number">4.1.</span> <span class="nav-text">4.1、shard 相关任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.2.</span> <span class="nav-text">4.2、线程示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.</span> <span class="nav-text">五、存储模块设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1%E3%80%81%E5%90%8E%E7%AB%AF%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">5.1、后端对象存储类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2%E3%80%81%E6%AE%B5%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F%E4%BF%A1%E6%81%AF"><span class="nav-number">5.2.</span> <span class="nav-text">5.2、段存储格式信息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">六、客户端使用方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.</span> <span class="nav-text">七、其他特性实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1%E3%80%81%E5%86%B7%E7%83%AD%E5%AD%98%E5%82%A8%E5%88%86%E7%A6%BB"><span class="nav-number">7.1.</span> <span class="nav-text">7.1、冷热存储分离</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90"><span class="nav-number">8.</span> <span class="nav-text">八、模块解析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E6%A2%B3%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">九、代码逻辑梳理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1%E3%80%81%E6%B6%88%E6%81%AF%E7%AE%A1%E7%90%86%E5%99%A8%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91"><span class="nav-number">9.1.</span> <span class="nav-text">9.1、消息管理器创建逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2%E3%80%81store-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E9%80%BB%E8%BE%91"><span class="nav-number">9.2.</span> <span class="nav-text">9.2、store 对象创建逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3%E3%80%81crimson-osd-mkfs-%E9%80%BB%E8%BE%91"><span class="nav-number">9.3.</span> <span class="nav-text">9.3、crimson osd mkfs 逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-1%E3%80%81store-mkfs-osd-uuid"><span class="nav-number">9.3.1.</span> <span class="nav-text">9.3.1、store.mkfs(osd_uuid)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4%E3%80%81crimson-osd-start-%E9%80%BB%E8%BE%91"><span class="nav-number">9.4.</span> <span class="nav-text">9.4、crimson osd start 逻辑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99"><span class="nav-number">10.</span> <span class="nav-text">十、相关资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lzy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">lzy</p>
  <div class="site-description" itemprop="description">选择有时候比努力更重要</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hoshilzy1026" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hoshilzy1026" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:18338064521@163.com" title="E-Mail → mailto:18338064521@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/6888391895" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;6888391895" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/31529112/ffhoshi" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;31529112&#x2F;ffhoshi" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>



      </div>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=36019737&auto=1&height=66"></iframe>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-12 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lzy</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">35k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:07</span>
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
